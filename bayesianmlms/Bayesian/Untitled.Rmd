---
title: ""
date: "`r Sys.Date()`"
output:
  rmdformats::robobook:
    highlight: kate
    thumbnails: true
    gallery: true
    lightbox: true
    fig_width: 16
    fig_height: 9
---

```{r setup, include=FALSE}
## Global options
knitr::opts_chunk$set(cache = TRUE)
```



# เตรียมตัวก่อนเรียน

บทเรียนนี้จะกล่าวถึงการวิเคราะห์โมเดลพหุระดับด้วยวิธีการแบบเบส์ ซึ่งมีความแตกต่างไปจากการวิเคราะห์ด้วยวิธีการแบบดั้งเดิมที่เรียกว่าวิธีการแบบ frequentist ส่วนแรกของบทเรียนจะปูพื้นฐานเกี่ยวกับสถิติแบบเบส์ก่อน จากนั้นจึงกล่าวถึงการใช้สถิติแบบเบส์ในการวิเคราะห์โมเดลพหุระดับ

โปรแกรมที่ใช้ในการบรรยายประกอบด้วย

- Jamovi 

- R

- JAGS (Just Another Gibb Sampler)

- STAN

ทั้งนี้เพื่อให้ไม่เป็นการเสียเวลา ขอให้ผู้เรียนดาวน์โหลดและติดตั้งโปรแกรมดังกล่าวให้พร้อมก่อนวันที่เรียน



# ความรู้พื้นฐาน

หัวข้อนี้เป็นความรู้พื้นฐานเกี่ยวกับสถิติแบบดั้งเดิม และ สถิติแบบเบส์ โดยจะกล่าวถึงข้อตกลงเบื้องต้นของสถิติแต่ละประเภท และข้อจำกัดของสถิติแบบดั้งเดิมที่สามารถใช้สถิติแบบเบส์เข้ามาช่วยแก้ปัญหาได้ รายละเอียดมีดังนี้


## สถิติแบบ Frequentist

สถิติแบบดั้งเดิมหรือที่เรียกกันว่า frequentist เป็นสถิติวิเคราะห์ที่ถูกใช้งานเป็นหลักในปัจจุบัน สถิติเกือบทุกตัวที่ผู้เรียนได้เรียนมาจนถึงปัจจุบันนี้ล้วนเป็นสถิติวิเคราะห์ภายใต้กระบวนทัศน์แบบ frequentist ทั้งสิ้น สถิติแบบ frequentist นี้มีข้อตกลงเบื้องต้นว่า **(1) พารามิเตอร์เป็นค่าคงที่** ที่มีอยู่จริงในประชากรเป้าหมาย อย่างไรก็ตามด้วยข้อจำกัดที่ไม่สามารถเก็บรวบรวมข้อมูลจากทั้งประชากรได้ทำให้ผู้วิเคราะห์ไม่ทราบค่าพารามิเตอร์ดังกล่าว และจะประมาณโดยใช้ข้อมูลจากตัวอย่าง **(2) ข้อมูลตัวอย่าง (sample data) เขียนแทนด้วย $\bf{x}= \left \{\bf{x_1}, \bf{x_2},...,\bf{x_n}  \right \}$ เป็นค่าที่สุ่มมาจากการประชากร** ดังนั้นตัวอย่างที่สุ่มได้จึงเป็นค่าสุ่มที่และมีความเป็นไปได้ทั้งหมดเท่ากับ \binom{N}{n} เมื่อ $N$ คือขนาดประชากร และ $n$ คือขนาดตัวอย่าง จากข้อตกลงเบื้องต้นข้อที่ (2) นี้จึงทำให้ **(3) ค่าสถิติที่ประมาณได้จากข้อมูลตัวอย่างเป็นตัวแปรสุ่มที่มีการแจกแจงความน่าจะเป็น เรียกการแจกแจงความน่าจะเป็นของค่าสถิตินี้ว่า การแจกแจงความน่าจะเป็นของฟังก์ชันที่ได้จากตัวอย่างสุ่ม (sampling distribution)** 


<center>![](/Users/siwachoat/Library/Mobile Documents/com~apple~CloudDocs/markdown/multilevel/sampling.png){width=70%}</center>


ลักษณะการแจกแจงความน่าจะเป็นของค่าสถิติดังกล่าวมักประมาณได้ด้วย 2 วิธีการ วิธีการแรก ประมาณโดยใช้ทฤษฎีลิมิตลู่เข้าสู่ส่วนกลาง (central limit theorem) ซึ่งเป็นการคาดการณ์ลักษณะการแจกแจงของค่าสถิติในเชิงทฤษฎี เช่น การประมาณช่วงความเชื่อมั่นของค่าเฉลี่ยมีสูตรเป็น $\overline{X}\pm t_{\alpha/2,n-1} \frac{S}{\sqrt{n}}$ จะเห็นว่าการประมาณช่วงความเชื่อมั่นดังกล่าวมีการใช้การแจกแจงที (student t distribution) ในการคำนวณส่วน margin of error การแจกแจงดังกล่าวพิสูจน์ในทางทฤษฎีโดยใช้ central limit theorem ได้ว่า เป็น sampling distribution ของ $\overline{X}$ หากข้อมูลตัวอย่างที่ใช้ในการวิเคราะห์สุ่มมาจากประชากรที่มีการแจกแจงแบบปกติหรือใกล้เคียง แต่ไม่ทราบค่าความแปรปรวนของประชากร หรือถ้าหากประชากรไม่ได้มีการแจกแจงแบบปกติ แต่ตัวอย่างมีขนาดใหญ่เพียงพอ ก็ยังสามารถใช้ sampling distribution ดังกล่าวประมาณการแจกแจงของ $\overline{X}$ ได้อยู่ หรือในการทดสอบสมมุติฐาน $H_0: \mu=\mu_0$ สถิติทดสอบที่ใช้คือ $t^*=\frac{\overline{X}-\mu_0}{S/ \sqrt{n}}$ จะมี sampling distributionในทางทฤษฎีเป็นการแจกแจงแบบที ที่มีองศาความเป็นอิสระเท่ากับ $n-1$ เช่นเดียวกันหากข้อกำหนดเบื้องต้นของ central limit theorem เป็นจริงหรือใกล้เคียง การทราบการแจกแจงของค่าสถิติดังกล่าวทำให้ผู้วิเคราะห์สามารถประเมินความคลาดเคลื่อนในการตัดสินใจของการทดสอบสมมุติฐาน และสรุปผลได้ดังที่ได้เรียนไปแล้วในรายวิชาพื้นฐาน


ความถูกต้องของทฤษฎีนี้ขึ้นอยู่กับปัจจัยแวดล้อมที่เกี่ยวข้องว่ามีความสอดคล้องกับทฤษฎีมากน้อยเพียงใด ปัจจัยหนึ่งที่มีความสำคัญคือขนาดตัวอย่าง กล่าวคือหากขนาดตัวอย่างมีค่าน้อยเกินไป หรือการแจกแจงของข้อมูลมีความเบี่ยงเบนออกไปจากข้อตกลงเบื้องต้นของการวิเคราะห์ไปมาก ค่าสถิติที่คำนวณได้อาจไม่มีลักษณะการแจกแจงที่เป็นไปตามทฤษฎี และส่งผลให้การอนุมานเชิงสถิติมีความคลาดเคลื่อน อีกวิธีการหนึ่งที่สามารถใช้ในการประมาณ sampling distribution ของค่าสถิติได้คือใช้วิธีการสุ่มซ้ำ (resampling method) เช่น boostraping หรือ jackknife เพื่อประมาณแนวโน้มการแจกแจงของค่าสถิติ เป็นต้น

---

```{r echo=F}
dat<-iris
names(dat)[1]<-c("Ach")
```

```{r}
t.test(dat$Ach, mu=5.5)

```

**คำถาม**

1. output ข้างต้นแสดงผลการประมาณช่วงความเชื่อมั่น และทดสอบสมมุติฐานทางสถิติเกี่ยวกับผลสัมฤทธิ์ทางการเรียนของนักเรียน (คะแนนเต็ม 10) โดยจากการประมาณด้วยช่วงความเชื่อมั่น 95% ในข้างต้นพบว่ามีค่าเท่ากับ $[5.71, 5.98]$ ซึ่งหมายความว่าอะไร?


2. จากผลการทดสอบสมมุติฐาน $H_0: \mu_{Ach}=5.5$ พบว่ามีค่า p-value < .000 หมายความว่าอะไร?

3. เราสามารถตัดสินใจยอมรับสมมุติฐาน $H_0$ ได้หรือไม่?

---

จากข้อตกลงเบื้องต้นของสถิติแบบ frequentist นี้ทำให้การวิเคราะห์ข้อมูลเกิดข้อจำกัดต่าง ๆ ดังนี้

1. ด้านที่สำคัญคือด้านการแปลผลการวิเคราะห์ที่จะเห็นว่าความหมายของผลการวิเคราะห์ต่าง ๆ เป็นการกล่าวถึงพารามิเตอร์ที่สนใจแบบอ้อม ๆ ทั้งสิ้น ไม่มีการวิเคราะห์ใดที่สามารถอ้างอิงไปยังพารามิเตอร์ที่สนใจได้โดยตรง ทั้งนี้เป็นเพราะการอนุมานเชิงสถิติแบบ frequentist พึ่งพาเครื่องมือหลักคือ samping distribution ของค่าสถิติ ในขณะที่พารามิเตอร์ถูกสมมุติให้เป็นค่าคงที่ตั้งแต่ต้น probability statement ต่าง ๆ จึงเป็นของค่าสถิติทั้งสิ้น ดังความความเชื่อมั่นที่รับประกันในช่วงความเชือมั่น และค่าความคลาดเคลื่อนในการทดสอบสมมุติฐานจึงเป็นค่าความน่าจะเป็นที่ใช้รับประกันความเป็นไปได้ของค่าสถิติทั้งสิ้นไม่ใช่ของค่าพารามิเตอร์ที่สนใจจริง ๆ ในการวิเคราะห์

2. ด้านที่สองคือด้านการประมาณค่าพารามิเตอร์ภายใต้โมเดลซับซ้อน เครื่องมือสำคัญสำหรับประมาณค่าพารามิเตอร์ในโมเดลต่าง ๆ ของสถิติแบบ frequentist คือตัวประมาณ เช่น ตัวประมาณกำลังสองน้อยสุด ตัวประมาณภาวะความควรจะเป็นสูงสุด ซึ่งล้วนเป็นวิธีการที่จะหาค่าประมาณที่ดีที่สุดโดยอิงจากจุดต่ำสุด หรือจุดสูงสุดของฟังก์ชันวัตถุประสงค์ ดังตัวอย่างในรูปด้านล่าง ซึ่งในกรณีที่โมเดลมีความซับซ้อนมาก ๆ ฟังก์ชันวัตถุประสงค์ดังกล่าวจะมีความซับซ้อนโดยมีจำนวนมิติที่สูงขึ้น และอาจมีจุดสูงต่ำ และ/หรือ จุดต่ำสุดสัมพัทธ์จำนวนมาก ซึ่งเป็นอุปสรรคให้การประมาณค่าด้วยวิธีการในข้างต้นอาจได้ค่าประมาณที่คลาดเคลื่อนไปจากค่าที่เหมาะสมที่สุด หรืออัลกอริทึมไม่สามารถหาค่าประมาณที่เหมาะสมได้ภายใต้จำนวนรอบของการประมาณที่กำหนด

<center>![](/Users/siwachoat/Library/Mobile Documents/com~apple~CloudDocs/markdown/multilevel/Screen Shot 2564-10-18 at 18.00.57.png){width=80%}</center>

</br>

3. สืบเนื่องจากที่การอนุมานเชิงสถิติแบบ frequentist นั้นมักอิงกับทฤษฎีความน่าจะเป็นที่อิงข้อกำหนดเบื้องต้นที่ขนาดตัวอย่างต้องมีขนาดใหญ่เพียงพอ ซึ่งทำให้สถิติแบบ frequentist มักทำงานได้ไม่ดีในกรณีที่ตัวอย่างมีขนาดเล็ก


## สถิติแบบเบส์ (Bayesian Statistics)

สถิติแบบเบส์เป็นกระบวนทัศน์ในการวิเคราะห์ข้อมูลอีกลักษณะหนึ่งที่มีความแตกต่างจากไปกระบวนทัศน์แบบดั้งเดิมที่นักวิเคราะห์ข้อมูลทั่วไปคุ้นเคยกัน ซึ่งทำให้สถิติแบบเบส์มีจุดเด่นและสามารถแก้ไขข้อจำกัดที่พบในสถิติแบบ frequentist ได้ ความแตกต่างดังกล่าวเริ่มตั้งแต่ข้อตกลงเบื้องต้นของสถิติแบบเบส์ที่แตกต่างจากสถิติแบบดั้งเดิมอย่างมาก กล่าวคือ

**(1) พารามิเตอร์เป็นตัวแปรสุ่ม** สถิติแบบเบส์มองว่าพารามิเตอร์เป็นค่าที่ผู้วิเคราะห์สนใจจะศึกษาและต้องการทราบอย่างแท้จริง แต่อย่างไรก็ตามเนื่องจากผู้วิเคราะห์ไม่ทราบข้อมูลประชากร การคาดการณ์หรือความเชื่อ (belief) เกี่ยวกับพารามิเตอร์ดังกล่าวจึงมีความไม่แน่นอน สภาพดังกล่าวจึงสมเหตุสมผลที่จะกำหนด probability statement ให้กับพารามิเตอร์ในโมเดล

จากข้อกำหนดนี้ผลการประมาณค่าพารามิเตอร์ที่ได้จากวิธีการแบบเบส์จึงจะไม่ได้ค่าประมาณแบบค่าเดียว แต่จะได้เป็นการประมาณการแจกแจงของพารามิเตอร์แทน เช่น การประมาณค่าเฉลี่ยผลสัมฤทธิ์ของนักเรียน ผลการวิเคราะห์แบบเบส์จะไม่ได้ให้เป็นค่าประมาณเพียงค่าเดียวคือ 5.84 คะแนน ดัง output ข้างต้น แต่จะให้เป็นการแจกแจงของพารามิเตอร์ค่าเฉลี่ยผลสัมฤทธิ์ทางการเรียน ซึ่งเรียกว่าการแจกแจงความน่าจะเป็นภายหลัง (posterior distribution) และสารสนเทศเกี่ยวกับค่าเฉลี่ยของผลสัมฤทธิ์ดังกล่าวจะถูกสกัดออกมาจากการแจกแจงนี้ 


**(2) ข้อมูลตัวอย่างเป็นค่าคงที่** ถึงแม้ว่าในความเป็นจริงตัวอย่างที่สุ่มมาจากประชากรจะมีความเป็นไปได้ที่หลากหลาย และมีความไม่แน่นอนในการได้มาซึ่งตัวอย่างแต่ละชุด อย่างไรก็ตามเมื่อดำเนินการสุ่มตัวอย่างมาทำการวิเคราะห์แล้ว ความเป็นไปได้จำนวนมากก่อนการสุ่มตัวอย่างจะเหลือเพียงความเป็นไปได้เดียว สถิติแบบเบส์จึงถือว่าข้อมูลตัวอย่างเป็นค่าคงที่ ไม่มีการกำหนด probability statetment ให้กับข้อมูลตัวอย่างนี้


สถิติแบบเบส์สามารถนำมาใช้เพื่อแก้ไขข้อจำกัดที่เกิดขึ้นจากสถิติแบบ frequentist ได้ดังนี้

1. จากข้อกำหนดเบื้องต้นข้างต้น การอนุมานเชิงสถิติด้วยสถิติแบบเบส์จะดำเนินการผ่านการแจกแจงความน่าจะเป็นของพารามิเตอร์โดยตรงที่เรียกว่า การแจกแจงความน่าจะเป็นภายหลัง (posterior distribution) การแจกแจงดังกล่าวเป็นเครื่องมือสำคัญในการอนุมานเชิงสถิติแบบเบส์ แทน sampling distribution ในการอนุมานเชิงสถิติแบบดั้งเดิม ซึ่งจุดนี้ทำให้สถิติแบบเบส์สร้างความแตกต่างอย่างมากเมื่อเปรียบเทียบกันสถิติแบบดั้งเดิม โดยจะเห็นว่าการประมาณค่าพารามิเตอร์แบบเบส์ไม่ได้อิงกับค่าสถิติเพียงค่าเดียวเหมือนกับสถิติแบบดั้งเดิม แต่อิงกับการแจกแจงความน่าจะเป็นภายหลัง

2. การที่สถิติแบบเบส์ใช้การแจกแจงความน่าจะเป็นภายหลังของพารามิเตอร์เป็นเครื่องมือหลักในการอนุมานเชิงสถิติ จึงทำให้การวิเคราะห์ทำได้อย่างตรงไปตรงมาโดยไม่ต้องอาศัยทฤษฎีหรือวิธีการที่ซับซ้อนเหมือนกับสถิติแบบดั้งเดิม กล่าวคือผู้วิเคราะห์ใช้เพียงสถิติพื้นฐาน เช่น ค่าเฉลี่ย มัธยฐาน ฐานนิยม ส่วนเบี่ยงเบนมาตรฐาน หรือเปอร์เซ็นไทล์ เป็นเครื่องมือในการสรุปสารสนเทศเกี่ยวกับพารามิเตอร์ที่สนใจออกมาจากการแจกแจงความน่าจะเป็นภายหลังที่ประมาณได้ ก็เพียงพอแล้ว นอกจากนี้การแปลผลเพื่ออนุมานเกี่ยวกับพารามิเตอร์ยังทำได้ง่ายและตรงไปตรงมา และได้ข้อสรุปโดยตรงไปยังปริภูมิของพารามิเตอร์ที่เป็นเป้าหมาย แตกต่างจากข้อสรุปที่ได้จากสถิติแบบดั้งเดิมที่เป็นข้อสรุปเกี่ยวกับการแจกแจงของค่าสถิติซึ่งอยู่บนปริภูมิตัวอย่างเท่านั้น 


3. การประมาณการแจกแจงความน่าจะเป็นภายหลังของพารามิเตอร์ในโมเดล จะใช้สารสนเทศสองส่วนด้วยกัน ส่วนแรกเป็นสมมุติฐานหรือความเชื่อเบื้องต้น (prior belief) เกี่ยวกับพารามิเตอร์ที่สนใจ ซึ่งกำหนดอยู่ในรูปการแจกแจงความน่าจะเป็นที่เรียกว่า การแจกแจงความน่าจะเป็นก่อนหน้าของพารามิเตอร์ (prior distribution) และส่วนที่สองคือสารสนเทศที่ได้จากข้อมูลตัวอย่าง ซึ่งแตกต่างจากสถิติแบบดั้งเดิมที่จะใช้สารสนเทศจากข้อมูลตัวอย่างเท่านั้น  

ลองพิจารณาตัวอย่างต่อไปนี้

สมมุติว่าต้องการคาดการณ์คะแนนสอบของนายบูม ที่มีความเป็นไปได้ 4 แบบดังรูป

![](/Users/siwachoat/Library/Mobile Documents/com~apple~CloudDocs/markdown/multilevel/b1.png){width=80%}


ก่อนการเก็บรวบรวมข้อมูลจริงในชั้นเรียนของนายบูม สมมุติว่าผู้วิเคราะห์มีข้อมูลในอดีตที่เกี่ยวข้องกับคะแนนสอบของนายบูมดังนี้

1. ไม่มีข้อมูลใด ๆ ที่เป็นประโยชน์ (ให้น้ำหนักกับความเป็นไปได้ A1, A2, A3 และ A4 อย่างไร?)

2. หากทราบเพิ่มเติมว่าการสอบที่ผ่าน ๆ มาโดยเฉลี่ยนายบูมสอบได้คะแนนคิดเป็นอันดับที่ 4 ของชั้นเรียนนี้ (น้ำหนักของความเป็นไปได้ทั้ง 4 จะเหมือนเดิมมั้ย?)

3. หากทราบเพิ่มเติมอีกว่า การสอบที่ผ่าน ๆ มา แก้วซึ่งเป็นเพื่อนในห้องเรียนของนายบูม สอบได้คะแนน 38 คะแนน คิดเป็นคะแนนที่น้อยที่สุดในชั้นเรียนนี้ (น้ำหนักของความเป็นไปได้ทั้ง 4 เหมือนเดิมหรือไม่?)

4. หากทราบอีกว่า ในการสอบที่ผ่าน ๆ มา นิดสอบได้คะแนนโดยเฉลี่ยคิดเป็น 89 คะแนน ซึ่งเป็นอันดับที่ 3 ของชั้นเรียนนี้ (น้ำหนักของความเป็นไปได้ทั้ง 4 เหมือนเดิมหรือไม่?)


![การแจกแจงก่อนหน้าของคะแนนสอบนายบูม](/Users/siwachoat/Library/Mobile Documents/com~apple~CloudDocs/markdown/multilevel/b2.png){width=80%}

ผู้วิเคราะห์สามารถปรับสารสนเทศในการแจกแจงความน่าจะเป็นก่อนหน้าในข้างต้นได้ หากมีการเก็บรวบรวมข้อมูลตัวอย่างเพิ่มเติม เช่น

สมมุติว่าการแจกแจงความน่าจะเป็นก่อนหน้าของคะแนนนายบูมเป็นแบบ uniform และมีข้อมูลการสอบครั้งล่าสุดเพิ่มเติมดังรูป 

![](/Users/siwachoat/Library/Mobile Documents/com~apple~CloudDocs/markdown/multilevel/b3.png){width=80%}



อีกตัวอย่างหนึ่ง สมมุติว่า การแจกแจงความน่าจะเป็นก่อนหน้าของคะแนนนายบูมมีน้ำหนักสูงที่ A3 และมีข้อมูลการสอบครั้งล่าสุดเพิ่มเติมดังรูป

![](/Users/siwachoat/Library/Mobile Documents/com~apple~CloudDocs/markdown/multilevel/b4.png){width=80%}


# ทฤษฎีบทของเบส์ (Bayes' theorem)


คำถามที่เกิดขึ้นจากตัวอย่างในข้างต้นคือ จะสามารถจัดสรรหรือปรับปรุงน้ำหนักให้กับแต่ละความเป็นไปได้ในการแจกแจงความน่าจะเป็นก่อนหน้าอย่างไร เมื่อมีข้อมูลเพิ่มเติม คำตอบคือ เราสามารถใช้ทฤษฎีบทของเบส์เพื่อดำเนินการดังกล่าวได้ ทฤษฎีบทของเบส์มีรากฐานมาจากการคำนวณความน่าจะเป็นแบบมีเงื่อนไขดังนี้ $P(A|B)=P(A \cap  B)/P(B)$

ดังนั้นหากกำหนดให้ $\theta$ คือพารามิเตอร์ภายในโมเดล และ $\bf{x}$ คือข้อมูลตัวอย่าง การแจกแจงความน่าจะเป็นภายหลังของพารามิเตอร์ที่ต้องการคือ $p(\theta|\bf{x})$ ซึ่งสามารถคำนวณได้จาก


$p(\theta|\bf{x})=\frac{p(\theta,\bf{x})}{p(\bf{x})}$

จากสมการในรูปข้างต้น เราสามารถปรับรูปสมการใหม่ได้ดังนี้

$p(\theta|\bf{x})p(\bf{x})=p(\theta,\bf{x})$ ------- (1)

ในทางกลับกันจากสมการความน่าจะเป็นแบบมีเงื่อนไขจะได้ว่า $p(\bf{x}|\theta)=p(\theta, \bf{x})/p(\bf{\theta})$ ดังนั้น

$p(\bf{x}|\theta)p(\bf{\theta})=p(\theta,\bf{x})$ ------- (2)


จากสมการที่ (1) กับ (2) จะได้ว่า

$p(\theta|\bf{x})p(\bf{x})=p(\bf{x}|\theta)p(\bf{\theta})$

ดังนั้นจะได้ว่าการแจกแจงความน่าจะเป็นภายหลังสามารถคำนวณได้จาก

<center> $p(\bf{\theta}|\bf{x})=\frac{p(\bf{x}|\theta)p(\theta)}{p(\bf{x})}$ </center>

เมื่อ $p(\bf{\theta}|\bf{x})$ คือการแจกแจงความน่าจะเป็นภายหลังของพารามิเตอร์ $\theta$ จะเห็นว่าเป็นการแจกแจงความน่าจะเป็นภายหลังของพารามิเตอร์ดังกล่าวเมื่อกำหนดข้อมูลตัวอย่าง $\bf{x}$ ส่วน $p(\bf{x}|\theta)$ คือฟังก์ชันภาวะความควรจะเป็น $p(\theta)$ คือฟังก์ชันความน่าจะเป็นก่อนหน้าของพารามิเตอร์ (prior distribution) และ $p(\bf{x})$ คือค่าคงที่ 

สมการข้างต้นจึงสามารถเขียนใหม่ได้ดังนี้

<center>$p(\bf{\theta}|\bf{x}) \propto  p(\bf{x}|\theta)p(\theta)$</center>

จากสมการในข้างต้นจะเห็นว่าการแจกแจงความน่าจะเป็นภายหลังของพารามิเตอร์ เกิดจากการนำสารสนเทศสองส่วนเข้ามาประมวลผลร่วมกัน ได้แก่ สมมุติฐานหรือความเชื่อเบื้องต้น (prior belief) เกี่ยวกับพารามิเตอร์ในโมเดล ที่กำหนดผ่านการแจกแจงความน่าจะเป็นก่อนหน้า และสารสนเทศจากข้อมูลตัวอย่างภายในฟังก์ชันภาวะความควรจะเป็น 




# ตัวอย่างการอนุมานเชิงสถิติแบบเบส์

โดยปกติขั้นตอนสำคัญของการอนุมานเชิงสถิติแบบเบส์มี 5 ขั้นตอน ได้แก่

1. การระบุขอบเขตด้านตัวแปร

2. กำหนดโมเดลของค่าสังเกต

3. กำหนดการแจกแจงความน่าจะเป็นเบื้องต้นของพารามิเตอร์

4. ประมาณการแจกแจงความน่าจะเป็นภายหลัง

5. วิเคราะห์ผลลัพธ์ที่ได้จากการแจกแจงความน่าจะเป็นภายหลัง


หัวข้อนี้จะแสดงตัวอย่างการอนุมานเชิงสถิติแบบเบส์ โดยใช้ตัวอย่างง่าย ๆ ดังนี้

### กำหนดตัวแปรในการวิเคราะห์

สมมุติว่าผู้วิจัยต้องการวิเคราะห์ความลำเอียงในการออกหน้าหัวหรือก้อยของเหรียญที่ผลิตขึ้นมารุ่นหนึ่ง การวิเคราะห์นี้ตัวแปรที่สนใจจึงเป็นผลลัพธ์ที่สังเกตได้จากการโยนเหรียญในแต่ละครั้ง กำหนดให้ $y_i$ แทนค่าสังเกตที่ได้จากการโยนเหรียญในครั้งที่ $i$ จะได้ว่า

$y_i=\left\{\begin{matrix}
1 & ; H\\ 
0 & ; T
\end{matrix}\right.$


### กำหนดโมเดลของค่าสังเกต

เมื่อกำหนดตัวแปรที่สนใจแล้วจะพบว่าตัวแปรที่สนใจมีเพียงตัวแปรตาม 1 ตัว โดยมีค่าสังเกตที่เป็นไปได้เพียง 2 ค่าได้แก่ H หรือ T ซึ่งแทนด้วย 1 กับ 0 ตามลำดับ โมเดลของค่าสังเกต $y_i$ นี้จึงสามารถกำหนดได้ด้วยการแจกแจงความน่าจะเป็นแบบ Bernoulli กล่าวคือ ความน่าจะเป็นที่จะออกหน้าหัวมีค่าเท่ากับ $p(y_i=1|\theta)=\theta$ และความน่าจะเป็นที่ออกหน้าก้อยมีค่าเท่ากับ $p(y_i=0|\theta)=1-\theta$ ซึ่งเขียนเป็นสมการรวมได้ดังนี้

$p(y_i|\theta)=\theta^{y_i}(1-\theta)^{1-y_i}$ เมื่อ $i = 1,2,3,...,n$

จากโมเดลในข้างต้นจะเห็นว่าการเกิดค่าสังเกต $y_i$ ขึ้นอยู่กับพารามิเตอร์ $\theta$ ที่มีค่าอยู่บนช่วง $[0,1]$ หากพารามิเตอร์ดังกล่าวมีค่าเท่ากับ $\theta=0.5$ นั่นหมายถึงโอกาสในการออกหน้าหัวและก้อยมีค่าเท่ากัน  แต่ถ้าหากพารามิเตอร์ $\theta>0.5$ นั่นหมายถึงโอกาสในการออกหน้าหัวมีมากกว่า จากความหมายดังกล่าวทำให้สามารถมองได้ว่าพารามิเตอร์ $\theta$ เป็นพารามิเตอร์ความลำเอียงของเหรียญ หากประมาณพารามิเตอร์ดังกล่าวได้จะสามารถสรุปความลำเอียงของเหรียญได้


เนื่องจากเราไม่ได้เก็บรวบรวมข้อมูลเพียงค่าสังเกตเดียว แต่เราทำการทดลองซ้ำ ๆ จำนวน $n$ ครั้ง เนื่องจากการทดลองแต่ละครั้งเป็นอิสระซึ่งกันและกัน ทำให้โมเดลของชุดค่าสังเกตหรือเรียกอย่างเป็นทางการว่า ฟังก์ชันภาวะความควรจะเป็นดังนี้

$p(\bf{y}|\theta)=p(y_1|\theta)p(y_2|\theta)...p(y_n|\theta)$ 

ซึ่งมีค่าเท่ากับ

$p(\bf{y}|\theta)=\theta^{\sum_{i=1}^ny_i}(1-\theta)^{n-\sum_{i=1}^ny_i}$

ในฟังก์ชันภาวะความควรจะเป็นนี้จะให้ค่าความน่าจะเป็นหรือค่าความหนาแน่นของข้อมูลตัวอย่าง $\bf{y}$ บนแต่ละค่าที่เป็นไปได้ของพารามิเตอร์ $\theta$ เนื่องจากข้อมูลตัวอย่างเป็นค่าคงที่ ดังนั้นค่าความหนาแน่นนี้จึงเปลี่ยนแปลงไปตามค่าของพารามิเตอร์ $\theta$ โดยหากค่าความหนาแน่นนี้มีค่าสูง ณ ค่า $\theta$ ค่าใด นั่นหมายถึงว่าพารามิเตอร์ค่านั้นทำให้โมเดลของค่าสังเกตกับค่าสังเกตจริงมีความสอดคล้องกันสูง ข้อสังเกตนี้ถูกนำไปใช้เพื่อหาค่าประมาณด้วยวิธีภาวะความควรจะเป็นสูงสุด (maximum likelihood: ML) แต่ในวิธีการแบบเบส์จะนำสารสนเทศส่วนนี้ไปประมวลร่วมกับความเป็นไปได้ของพารามิเตอร์ในการแจกแจงความน่าจะเป็นเบื้องต้นก่อน

### กำหนดการแจกแจงความน่าจะเป็นเบื้องต้นของพารามิเตอร์


การกำหนดการแจกแจงความน่าจะเป็นเบื้องต้นของพารามิเตอร์ $\theta$ สามารถทำได้หลายลักษณะ ทั้งแบบไม่ต่อเนื่อง และแบบต่อเนื่อง ขึ้นอยู่กับขอบเขตของการวิเคราะห์ ข้อมูลในอดีตที่ใช้สนับสนุน และธรรมชาติของพารามิเตอร์นั้น ในตัวอย่างข้างต้นพารามิเตอร์ $\theta$ ต้องมีค่าอยู่บนช่วง $[0,1]$

เพื่อให้ตัวอย่างนี้ทำความเข้าใจได้ง่าย จึงเลือกกำหนดการแจกแจงความน่าจะเป็นเบื้องต้นของพารามิเตอร์ $\theta$ เป็นการแจกแจงแบบไม่ต่อเนื่อง โดยมีค่าที่เป็นไปได้เท่ากับ 0.0, 0.1, 0.2, 0.3, ...., 1.0 และมีการแจกแจงของความน่าจะเป็นก่อนหน้าดังรูป

```{r}
# prior distribution
theta<-seq(0,1,0.1)
p.theta<-c(0.01,0.04,0.075,0.1,0.15,0.25,0.15,0.1,0.075,0.04,0.01)
plot(theta,p.theta, 
     xlab=expression(theta), 
    ylab=expression(p(theta)), 
    type="h", lwd=2, col="orange",
    main="Prior Distribution")
points(theta,p.theta, type="p",pch=16, cex=2, col="orange")
```

### การประมาณการแจกแจงความน่าจะเป็นภายหลัง

จากการทดลองโยนเหรียญจำนวน 10 ครั้งพบว่า ออกหน้าหัวจำนวน 6 ครั้ง ดังนั้นจะได้ว่า

$p(\bf{y}|\theta)=\theta^{6}(1-\theta)^4$

จากขอบเขตของ $theta$ ที่กำหนดในการแจกแจงความน่าจะเป็นเบื้องต้นจะได้ว่าฟังก์ชันภาวะความควรจะเป็น มีลักษณะดังรูป

```{r}
# likelihood function
L<-theta^6*(1-theta)^4
plot(theta,L, 
     xlab=expression(theta), 
    ylab="p(y|theta)",
    type="h", lwd=2, col="orange",
    main="Likelihood Function")
points(theta,L, type="p",pch=16, cex=2, col="orange")
```

จากทฤษฎีบทของเบส์เราสามารถรวมสารสนเทศจากการแจกแจงความน่าจะเป็นเบื้องต้น กับฟังก์ชันภาวะความควรจะเป็นได้ดังนี้

```{r}
# marginal y
p.y<-sum(p.theta*L)

par(mfrow=c(1,2))
# posterior of theta given y
post.theta<-L*p.theta/p.y
plot(theta,post.theta, 
     xlab=expression(theta), 
    ylab="p(theta|y)",
    type="h", lwd=2, col="blue",
    ylim=c(0,0.5),
    main="Posterior Distribution")
points(theta,post.theta, type="p",pch=16, cex=2, col="blue")

# prior and posterior in the same plot
plot(theta,p.theta, 
     xlab=expression(theta), 
    ylab="Probability", 
    type="l", lwd=2, col="orange",
    ylim=c(0,0.5))
points(theta,p.theta, type="p",pch=16, cex=2, col="orange")

points(theta,post.theta, 
    type="l", lwd=2, col="blue")
points(theta,post.theta, type="p",pch=16, cex=2, col="blue")
legend(-0.05,0.48, legend=c("Prior","Posterior"), col=c("orange","blue"), lty=1, bty="n", lwd=2)
```


### การอนุมานเชิงสถิติจากการแจกแจงความน่าจะเป็นภายหลัง

เมื่อได้การแจกแจงความน่าจะเป็นภายหลังที่ต้องการแล้ว ผู้วิเคราะห์สามารถวิเคราะห์การแจกแจงดังกล่าวเพื่ออนุมานเกี่ยวกับพารามิเตอร์ความลำเอียงที่ต้องการศึกษาได้ โดยสามารถทำได้หลายลักษณะ ทั้งการประมาณค่าแบบจุด การประมาณค่าแบบช่วง และการทดสอบสมมุติฐาน รายละเอียดดังนี้

**(1) การประมาณค่าแบบจุด**

การประมาณค่าแบบจุดสามารถทำได้โดยใช้สถิติพื้นฐานสรุปแนวโน้มสู่ส่วนกลางของค่าพารามิเตอร์ จากการแจกแจงความน่าจะเป็นภายหลัง เช่น ค่าเฉลี่ย มัธยฐาน และฐานนิยม นอกจากนี้ยังสามารถคำนวณค่าส่วนเบี่ยงเบนมาตรฐานเพื่อประเมินระดับความน่าเชื่อถือของค่าประมาณแบบจุดดังกล่าวได้อีกด้วย จากการแจกแจงความน่าจะเป็นภายหลังข้างต้น จะได้ว่า

```{r}
# mean = expected value of theta
mean.theta<-sum(post.theta*theta)
sd.theta<-sqrt(sum(post.theta*(theta-mean.theta)^2))
mean.theta
sd.theta
```

**(2) การประมาณค่าแบบช่วง**

ช่วงการประมาณที่ได้จากวิธีแบบเบส์จะเรียกว่า ช่วงความน่าเชื่อถือ (credible interval) การประมาณค่าพารามิเตอร์แบบช่วงจากการแจกแจงความน่าจะเป็นภายหลังสามารถทำได้หลายวิธีการ วิธีการง่าย ๆ คือการใช้ค่าเฉลี่ยบวกลบด้วยส่วนเบี่ยงเบนมาตรฐานของพารามิเตอร์ อีกวิธีการหนึ่งที่มีประสิทธิภาพมากกว่าคือการหาช่วงแบบ highest density interval (HDI) กล่าวคือเป็นช่วงการประมาณที่มีความหนาแน่นมากที่สุดที่ทำให้ค่าความน่าจะเป็นของพารามิเตอร์ภายในช่วงดังกล่าวเท่ากับค่าที่กำหนดเช่น ช่วง 95% HDI ของพารามิเตอร์ $\theta$ ในข้างต้นจะมีค่าประมาณ $[0.4,0.8]$

ช่วงดังกล่าวมีความแตกต่างจาก 95% confidence interval อย่างไร??


**(3) การทดสอบสมมุติฐาน**

การทดสอบสมมุติฐานด้วยวิธีการแบบเบส์มีความยืดหยุ่นสูงมาก และสามารถทำได้หลายวิธีการ วิธีการแรกเรียกว่า **maximum a posteriori (MAP) test** มีรายละเอียดดังนี้

กำหนดให้ $H_0$ และ $H_1$ เป็นสมมุติฐานที่ต้องการเปรียบเทียบ ในกรณีนี้จะเห็นว่ามีความไม่แน่นอนว่าสมมุติฐานใดเป็นสมมุติฐานที่ถูกต้องกันแน่ ดังนั้นจึงสามารถกำหนดการแจกแจงความน่าจะเป็นก่อนหน้าของสมมุติฐานทั้งสองได้ ดังนี้

$p(H_0) = p_0$ และ $p(H_1)=p_1$ โดยที่ $p_0+p_1=1$

และกำหนดให้ $p(\bf{y}|H_0)$ กับ $p(\bf{y}|H_1)$ คือฟังก์ชันภาวะความควรจะเป็นบนสมมุติฐานทั้งสอง ซึ่งจากทฤษฎีบทของเบส์จะได้ว่า

$p(H_0|\bf{y})=\frac{p(\bf{y}|H_0)p(H_0)}{p(\bf{y})}$

$p(H_1|\bf{y})=\frac{p(\bf{y}|H_1)p(H_1)}{p(\bf{y})}$

การตัดสินใจว่าควรเลือกเชื่อสมมุติฐานใด สามารถทำได้โดยดูจากอัตราส่วนที่เรียกว่า posterior odd ซึ่งมีค่าเท่ากับ

$\frac{p(H_0|\bf{y})}{p(H_1|\bf{y})}=\frac{p(\bf{y}|H_0)p(H_0)}{p(\bf{y}|H_1)p(H_1)}$

โดยหากอัตราส่วนข้างต้นมีค่ามากกว่า 1 แสดงว่า สมมุติฐาน $H_0$ มีแนวโน้มน่าเชื่อถือมากกว่า ในทางกลับกันหากอัตราส่วนดังกล่าวมีค่าน้อยกว่า 1 แสดงว่าสมมุติฐาน $H_1$ มีแนวโน้มน่าเชื่อถือมากกว่า

จากตัวอย่างโยนเหรียญ หากต้องการทดสอบว่าเหรียญมีความเที่ยงตรงหรือไม่ อาจกำหนดสมมุติฐานเป็นดังนี้

$H_0: \theta = 0.5$ vs $H_1: \theta>0.5$


```{r}
prior.H<-c(0.5,0.5) # prior for H0 and H1 respectively.
# calculate likelihood
L.H0<-0.5^6*(1-0.5)^4
theta.H1<-theta[theta>0.5]
L.H1<-sum(theta.H1^6*(1-theta.H1)^4)

# calculate posterior odd
(prior.H[1]*L.H0)/(prior.H[2]*L.H1)

```

อีกวิธีการหนึ่งที่สามารถทำได้เรียกว่า minimum cost hypothesis test รายละเอียดมีดังนี้

กำหนดให้ 

- $C_{10}$ คือ cost ของการเลือก $H1$ โดยที่ $H_0$ ถูกต้อง (cost ของการเกิด type I error)
- $C_{01}$ คือ cost ของการเลือก $H_0$ โดยที่ $H_1$ ถูกต้อง (cost ของการเกิด type II error)

เกณฑ์การพิจารณาจะใช้ค่าความเสี่ยงภายหลัง (posterior risk) ดังนี้

$\frac{p(H_0|\bf{y})C_{10}}{p(H_1|\bf{y})C_{01}}$

จากตัวอย่างโยนเหรียญสมมุติว่า $C_{10}=5C_{01}$

```{r}
c10<-5
c01<-1

# posterior risk of accepting H0
(prior.H[2]*L.H1)*c01

# posterior risk of accepting H1
(prior.H[1]*L.H0)*c10

# risk ratio
(prior.H[1]*L.H0)*c10/(prior.H[2]*L.H1)*c01
```

อีกวิธีการที่ง่ายกว่าสองวิธีการแรกมากคือ วิธี ROPE ซึ่งเป็นการเปรียบเทียบกันระหว่างช่วงความน่าเชื่อถือแบบ HDI กับช่วง ROPE ที่เรียกว่า region of practical equivalence ซึ่งเป็นช่วงที่ยอมรับได้ในทางปฏิบัติ (โดยผู้วิเคราะห์) ว่าหากพารามิเตอร์ยังมีค่าอยู่ในช่วง ROPE ดังกล่าวอยู่ แสดงว่ายังไม่แตกต่างจาก $H_0$ โดยหากช่วง HDI ครอบคลุมช่วง ROPE เราจะสามารถยอมรับ $H_0$ ได้ แต่หากช่วง HDI ไม่มีส่วนใดที่ครอบคลุมช่วง ROPE เลย แสดงว่าไม่ช่วงเชื่อถือ $H_0$ อย่างยิ่ง


### การคัดเลือกโมเดล (model selection)

การคัดเลือกโมเดลเป็นวิธีการหนึ่งที่สามารถใช้ในการทดสอบมสมมุติฐานของผู้วิเคราะห์ รวมทั้งใช้เปรียบเทียบและคัดเลือกโมเดลที่เหมาะสมที่สุดสำหรับอธิบายข้อมูล  สถิติตัวหนึ่งที่มีความสำคัญคือ bayes factor 
วัตถุประสงค์ของ bayes factor ถูกใช้เพื่อวัดว่าข้อมูลตัวอย่างที่เก็บรวบรวมมมานี้สนับสนุนโมเดลหรือสมมุติฐานตัวใดมากกว่ากัน bayes factor มีค่าเท่ากับอัตราส่วนระหว่างค่าภาวะความควรจะเป็นของสมมุติฐานสองตัวบนชุดข้อมูลตัวอย่างเดียวกัน สมมุติให้ $H_1$ คือโมเดลตามสมมุติฐานที่ 1 และ $H_2$ คือโมเดลตามสมมุติฐานที่ 2 และ $\bf{x}$ คือชุดข้อมูลตัวอย่าง จะได้ว่าสถิติ bayes factor (BF) มีค่าเท่ากับ

$BF = \frac{p(\bf{x}|H_1)}{p(\bf{x}|H_2)}=\frac{p(H_1|\bf{x})}{p(H_2|\bf{x})}\times \frac{p(H_2)}{p(H_1)}$

จากนิยามข้างต้นจะเห็นว่า bayes factor ตามนิยามดังกล่าวสามารถเขียนใหม่ในรูปผลคูณระหว่างอัตราส่วนสองตัว ได้แก่ อัตราส่วนระหว่างการแจกแจงความน่าจะเป็นภายหลังกับอัตราส่วนระหว่างการแจกแจงความน่าจะเป็นก่อนหน้าของสมมุติฐานที่ 1 ต่อสมมุติฐานที่ 2

จากนิยามนี้สามารถแปลผลได้ว่าหาก $BF$ มีค่ามากกว่า 1 นั่นหมายถึงข้อมูลที่มีสนับสนุนโมเดลตามสมมุติฐาน $H_1$ มากกว่า ในทางกลับกันหาก $BF$ มีค่าน้อยกว่า 1 นั่นหมายความว่าข้อมูลที่มีสนับสนุนโมเดลตามสมมุติฐาน $H_2$ มากกว่า [Harold Jeffery (1998)](https://books.google.co.th/books?id=vh9Act9rtzQC&pg=PA432&redir_esc=y#v=onepage&q&f=false) ได้เสนอสเกลการแปลความหมายสถิติ bayes factor ไว้ดังนี้

![](/Users/siwachoat/Library/Mobile Documents/com~apple~CloudDocs/markdown/multilevel/BF.png){width=60%}

การคำนวณและการใช้งาน bayes factor จะกล่าวถึงในสัปดาห์ที่สองของหัวข้อนี้


นอกจากสถิติ bayes factor แล้วยังมีสถิติอีกหลายตัวที่สามารถใช้เปรียบเทียบและคัดเลือกโมเดลแบบเบส์ได้ เช่น deviance information criterion (DIC), widely applicable information criterion (WAIC) และ leave-one-out cross-validation (LOO) สถิติทั้งหมดที่กล่าวมานี้ใช้สะท้อนความแตกต่างกันระหว่างข้อมูลตัวอย่าง $y$ กับค่าทำนายที่ generate จากโมเดลการวิเคราะห์ $\hat{y}$ ค่าที่ได้จากสถิติดังกล่าวจึงใช้สะท้อนความคลาดเคลื่อนของแต่ละโมเดลเมื่อเปรียบเทียบกับข้อมูลจริง โมเดลที่มีค่าสถิติดังกล่าวต่ำกว่าจะเป็นโมเดลที่มีความเหมาะสมมากกว่า


# Monte Carlo Markov Chain (MCMC)

ตัวอย่างที่แสดงให้ดูในหัวข้อข้างต้นเป็นตัวอย่างที่ง่ายมากทำให้การคำนวณการแจกแจงความน่าจะเป็นภายหลังสามารถคำนวณมือได้โดยสะดวก นอกจากนี้ยังสามารถพิสูจน์ในรูปของสูตรปิดทางคณิตศาสตร์ได้ด้วย อย่างไรก็ตามในสถานการณ์ทั่วไปการคำนวณการแจกแจงความน่าจะเป็นภายหลังดังกล่าวมักมีความซับซ้อนและไม่สามารถคำนวณมือได้ โดยเฉพาะในโมเดลพหุระดับ ปัจจุบันวิธีการที่ถูกนำมาแทนการคำนวณทางคณิตศาสตร์คือการใช้ลูกโซ่มาร์คอฟมอนติคาร์โล (MCMC) วิธีการนี้ถูกออกแบบให้สุ่มตัวอย่างพารามิเตอร์ภายใต้กระบวนการลูกโซ่ของมาร์คอฟ ซึ่งรับประกันว่าเมื่อจำนวนรอบของการสุ่มตัวอย่างมีจำนวนมากเพียงพอ ตัวอย่างของพารามิเตอร์ดังกล่าวจะถูกสุ่มมาจากการแจกแจงของประชากรที่เป็นการแจกแจงความน่าจะเป็นภายหลังของพารามิเตอร์ตามต้องการ ในการทำงานผู้วิเคราะห์จะใช้ตัวอย่างสุ่มที่ถูกตรวจสอบคุณสมบัติแล้ว มาประมาณการแจกแจงความน่าจะเป็นภายหลัง การอนุมานเชิงสถิติต่าง ๆ ที่ได้กล่าวไว้บ้างก่อนหน้านี้สามารถทำได้โดยตรงผ่านการวิเคราะห์ตัวอย่างของพารามิเตอร์ดังกล่าว 

ปัจจุบันโปรแกรมสำเร็จรูปที่ช่วยทำ MCMC ให้กับผู้วิเคราะห์มีหลายตัว ได้แก่ BUGS, JAGS, Stan รวมทั้ง R อีกหลาย package นอกจากนี้โปรแกรม Mplus และ MLWins ยังมีโมดูลสำเร็จรูปสำหรับประมาณค่าพารามิเตอร์แบบเบส์สำหรับโมเดลพหุระดับอีกด้วย 

บทเรียนนี้จะทำ MCMC ด้วย 2 วิธีการ วิธีการแรกคือการทำ MCMC บนโปรแกรม  JAGS ที่สั่งการทำงานบนโปรแกรม R และวิธีการที่สองคือการทำ MCMC ด้วย package-brms ซึ่งเป็น high-level API ของโปรแกรม Stan โดยถูกพัฒนาขึ้นมาสำหรับวิเคราะห์โมเดลพหุระดับโดยเฉพาะ จุดเด่นของ package-brms คือใช้หลักภาษาที่ง่ายเกือบจะเหมือนกับ package-lme4 ที่ได้เรียนไปในบทเรียนก่อนหน้า นอกจากนี้ยังสามารถวิเคราะห์ได้หลายโมเดลตั้งแต่โมเดลแบบตัวแปรตามตัวเดียวไปถึงตัวแปรตามหลายตัว และมีขอบเขตครอบคลุมไปถึง generalized linear model แบบพหุระดับอีกด้วย จุดเด่นอีกประการหนึ่งของ package-brms คืออิงกับโปรแกรม Stan ที่ใช้อัลกอริทึม Hamiltonian Monte Carlo ร่วมกับอัลกอริึม No-U-Turn Sampler (NUTS) ซึ่งมีประสิทธิภาพสูงกว่า Gibb sampler ที่ใช้ใน BUGS และ JAGS อัลกอริทึมดังกล่าวจะลู่เข้าสู่สถานะคงที่ (steady state) ซึ่งก็คือได้ตัวอย่างที่สุ่มจากการแจกแจงความน่าจะเป็นภายหลังไวจึงเหมาะกับโมเดลซับซ้อนที่มีพารามิเตอร์จำนวนมาก นอกจากนี้อัลกอริทึมดังกล่าวยังไม่ต้องการการกำหนดการแจกแจงความน่าจะเป็นก่อนหน้าแบบวงศ์คู่สังยุค (conjugacy prior) เหมือนกับอัลกอริทึม Gibb sampler อีกด้วย จึงทำให้มีความยืดหยุ่นในการวิเคราะห์ที่สูงขึ้นมาก อย่างไรก็ตามข้อจำกัดของ Stan คือการสุ่มตัวอย่างในแต่ละรอบจะใช้เวลาที่มากกว่า BUGS และ JAGS (Bürkner, 2017)

# JAGS (Just Another Gibb Sampler)

JAGS สามารถรันได้บน 3 platforms ได้แก่ Mac, Windows และ Linux บทเรียนนี้จะควบคุมโปรแกรม JAGS ผ่านโปรแกรม R โดยใช้ package-rjags ดังนั้นผู้วิเคราะห์จะใช้โปรแกรม R ในการทำงานส่วนใหญ่ ท้ังการเตรียมข้อมูล และการวิเคราะห์ผลลัพธ์จากลูกโซ่มาร์คอฟ ส่วนที่จะเขียนเป็นภาษาของ JAGS คือส่วนการระบุโมเดลการวิเคราะห์เท่านั้น การกำหนดโมเดลใน JAGS ใข้หลักภาษาเดียวกับ BUGS  โดยทั่วไปโมเดลการวิเคราะห์แบบเบส์ในโปรแกรม JAGS จะมีส่วนประกอบ 3 ส่วน ได้แก่

1. likelihood function(s) 

2. prior distribution

3. deterministic model

prior และ likelihood function เป็นส่วนประกอบที่เรียกว่า stochastic node ซึ่งนิยามโดยใช้สัญลักษณ์ `~` ส่วน deterministic model เป็นส่วนค่าคงที่หรือส่วนโมเดลเชิงคณิตศาสตร์ที่ใช้แสดงความสัมพันธ์ระหว่างตัวแปรการนิยามส่วนนี้จะใช้สัญลักษณ์ `<-`

ตัวอย่างด้านล่างแสดงการเขียนโมเดลการวิเคราะห์การถดถอยอย่างง่ายแบบเบส์ เพื่อวิเคราะห์ความสัมพันธ์ระหว่างผลสัมฤทธิ์ทางการเรียน (ACH) กับความตั้งใจเรียนของนักเรียน (ATT)

กำหนดให้ $y$ แทน ACH และ $x$ แทน ATT  เนื่องจากตัวแปรตามในโมเดลเป็นตัวแปรต่อเนื่อง ในกรณีนี้จึงกำหนดให้

$y_i \sim N(\mu_i, \sigma^2)$

สังเกตว่าการแจกแจงของค่าสังเกตในข้างต้นมีค่าเฉลี่ยที่ห้อย $i$ ทั้งนี้เป็นเพราะเรากำลังวิเคราะห์การถดถอย ดังนั้นค่าเฉลี่ยของ $y$ จึงมีการเปลี่ยนแปลงไปตามค่าของตัวแปรอิสระ $x_i$ ค่าเฉลี่ยดังกล่าวจึงเป็นค่าเฉลี่ยที่มีเงื่อนไข และสามารถเขียนเป็นสมการแสดงความสัมพันธ์ได้ดังนี้

$\mu_i = \beta_0 + \beta_1x_i$

โมเดลข้างต้นมีพารามิเตอร์จำนวน 3 ตัว จำแนกเป็นสองกลุ่ม กลุ่มแรกคือพารามิเตอร์อิทธิพลคงที่ (fixed-effect parameter) ได้แก่ $\beta_0$ และ $\beta_1$ และกลุ่มที่สองคือพารามิเตอร์ความแปรปรวนของอิทธิพลสุ่ม ได้แก่ $\sigma^2$


## การแจกแจงความน่าจะเป็นก่อนหน้า

การแจกแจงความน่าจะเป็นก่อนหน้าใช้สะท้อนความเชื่อเบื้องต้นในพารามิเตอร์ต่าง ๆ ของโมเดล ความเชื่อดังกล่าวมาได้จากทั้งผลการศึกษาในอดีต หลักเหตุผล และประสบการณ์ของนักวิจัย นอกจากนี้ยังควรต้องพิจารณาธรรมชาติหรือค่าที่เป็นไปได้ของพารามิเตอร์ประกอบด้วย

โดยทั่วไปการกำหนดการแจกแจงความน่าจะเป็นก่อนหน้าสามารถทำได้ 2 ลักษณะ ลักษณะแรกเรียกว่า การแจกแจงความน่าจะเป็นก่อนหน้าแบบไม่ให้สารสนเทศ (non-informative prior distribution) และการแจกแจงความน่าจะเป็นก่อนหน้าแบบให้สารสนเทศ (informative prior distribution)

การแจกแจงความน่าจะเป็นก่อนหน้าของพารามิเตอร์อิทธิพลคงที่สามารถเลือกใช้ได้หลายการแจกแจง เช่น การแจกแจงแบบ uniform ที่เป็น noninformative prior การแจกแจงแบบปกติ ที่เป็นไปได้ทั้ง noninformative และ informative prior ขึ้นอยู่กับการกำหนดพารามิเตอร์ค่าเฉลี่ย (mean) และค่าความถูกต้อง (precision) โดยที่ค่าความถูกต้องดังกล่าวเป็นส่วนกลับของพารามิเตอร์ความแปรปรวน (variance) ดังนี้ precision = 1/variance

จากตัวอย่างข้างต้นกำหนดให้

$\beta_0 \sim N(0,10^{-4})$

$\beta_1 \sim N(0,10^{-4})$

การกำหนดข้างต้นคือการแจกแจงความน่าจะเป็นแบบปกติที่มีค่าเฉลี่ยเท่ากับ 0 และความแปรปรวนเท่ากับ 10000 ซึ่งเรียกได้ว่าเป็นการแจกแจงความน่าจะเป็นก่อนหน้าแบบไม่ให้สารสนเทศ รูปด้่านล่างแสดงลักษณะการแจกแจงแบบปกติข้างต้น จากรูปจะเห็นว่าการแจกแจงดังกล่าวมีขอบเขตที่กว้างพารามิเตอร์ส่วนใหญ่จะมีค่าตกอยู่ในช่วง -200 ถึง 200

```{r echo=F}
b0<-rnorm(100000,0,100)
b1<-rnorm(100000,0,100)
par(mfrow=c(1,2), mar=c(4,4,1,1))
plot(density(b0), xlab=expression(beta[0]), main="", ylim=c(0,0.005))
plot(density(b1), xlab=expression(beta[1]), main="", ylim=c(0,0.005))
```

การแจกแจงความน่าจะเป็นก่อนหน้าของส่วนเบี่ยงเบนมาตรฐานหรือความแปรปรวน มีความจำเป็นต้องเลือกการแจกแจงที่ domain ของการแจกแจงมีค่าไม่ติดลบ โดยปกติมักกำหนดให้ความแปรปรวนดังกล่าวมีการแจกแจงแบบแกมมาผกผัน (inverse gamma distribution)

จากตัวอย่างข้างต้น กำหนดให้

$sigma^2 \sim IG(a,b)$

โดยที่ $IG$ คือการแจกแจงแบบ inverse-gamma

**Note:** ในเชิงทฤษฎีหากกำหนดให้ $sigma^2 \sim IG(a,b)$ จะได้ว่า

$p(\sigma^2|a,b) \propto  (\sigma^2)^{-a-1}exp(\frac{-b}{\sigma^2})$

หากกำหนดให้ $a \rightarrow 0$ และ $b \rightarrow 0$ แล้วฟังก์ชันความหนาแน่นในข้างต้นจะเขียนใหม่ได้เป็น

$p(\sigma^2|a,b) \propto  \frac{1}{\sigma^2}$ เรียกว่า Jeffery prior ซึ่งเป็น noninformative prior ที่ใช้ได้ตัวหนึ่งของพารามิเตอร์ความแปรปรวน

ดังนั้นในกรณีนี้จึงกำหนดให้

$sigma^2 \sim IG(0.0001,0.0001)$


รูปด้านล่างแสดงรายการของการแจกแจงความน่าจะเป็นที่สามารถกำหนดได้ใน BUGS และ JAGS

![](/Users/siwachoat/Library/Mobile Documents/com~apple~CloudDocs/markdown/multilevel/distribution.png){width=80%}

จากการระบุโมเดลข้างต้นทำให้สามารถเขียน syntax เพื่อระบุโมเดลใน JAGS ได้ดังนี้

```{r eval=F}
model{
  
  for(i in 1:n)
  {
    # likelihood function
    y[i]~dnorm(mu[i],tau) #where tau is precision = 1/sigma2
    
    # deteministic model
    mu[i]<-b0+b1x[i] 
  }
  
  # prior distribution
  b0~dnorm(0,10^-4)
  b1~dnorm(0,10^-4)
  
  tau~gamma(0.0001,0.0001)
  sigma2<-1/tau # deteministic model
}
```

## การประมวลผลด้วย JAGS

การประมวลผลด้วย JAGS มี 4 ขั้นตอนหลักได้แก่

**(1) เตรียมข้อมูล**

**(2) ระบุโมเดล **

**(3) ส่งข้อมูลและโมเดลไปประมวลผลบน JAGS**

**(4) ตรวจสอบการลู่เข้าของ MCMC**

**(5) วิเคราะห์และแปลผล**

### การระบุโมเดล

ขั้นตอนนี้สามารถทำได้ดังตัวอย่างข้างต้น และเมื่อระบุโมเดลในโปรแกรม R เรียบร้อยแล้ว ผู้วิเคราะห์จำเป็นต้องเขียนโมเดลดังกล่าวในรูปของไฟล์ .txt โดยใช้คำสั่ง `writeLines(modelString, con="model.txt")` ดังตัวอย่างด้านล่าง

```{r}
modelString<-"model{
  
  for(i in 1:n)
  {
    # likelihood function
    y[i]~dnorm(mu[i],tau) #where tau is precision = 1/sigma2
    
    # deteministic model
    mu[i]<-b0+b1*x[i] 
  }
  
  # prior distribution
  b0~dnorm(0,10^-4)
  b1~dnorm(0,10^-4)
  
  tau~dgamma(0.0001,0.0001)
  sigma2<-1/tau # deteministic model
}" #Wrap model syntax into String object

writeLines(modelString, con="/Users/siwachoat/Library/Mobile Documents/com~apple~CloudDocs/markdown/multilevel/modelfiles/simReg.txt") # write modelString to model.txt


```


### การสั่งประมวลผล

สมมุติว่าข้อมูลที่ใช้ในการวิเคราะห์เป็นดังรูป โดยเก็บไว้ในตัวแปร `dat.reg` (ข้อมูลในตัวอย่างนี้ได้จากการจำลองด้วยเทคนิค Monte Carlo) โดยใช้ syntax ด้านล่าง

```{r}
ATT<-rnorm(100,30,10)
ACH<-30+0.55*ATT+rnorm(100,0,5)
dat.reg<-data.frame(ATT,ACH)
```

```{r}
head(dat.reg)
par(mar=c(4,4,1,1))
plot(ATT,ACH, pch=16, xlab="ATT", ylab="ACH")
```

การประมวลผลโมเดลข้างต้นผ่านโปรแกรม JAGS จะต้องใช้คำสั่ง 2 ตัวได้แก่ฟังก์ชัน `jag.model()` และ `coda.samples()` ที่มีอากิวเมนท์สำคัญดังนี้

```{r}
setwd("/Users/siwachoat/Library/Mobile Documents/com~apple~CloudDocs/markdown/multilevel/modelfiles/")

library(rjags)
dataList<-list(y=dat.reg$ACH, x=dat.reg$ATT, n=length(dat.reg$ACH))
initsList<-list(b0=1, b1=1, tau=1)

model<-jags.model(file = "simReg.txt",
                  data = dataList,
                  inits = initsList,
                  n.chains = 3)
update(model, n.iter=2000) # n.burnin
samples<-coda.samples(model,
                      variable.names=c("b0","b1","sigma2"),
                      n.iter = 10000,
                      thin=1)
head(samples)
```

อีก package หนึ่งที่สามารถเรียก JAGS จาก R ได้คือ package-runjags ซึ่งมีจุดเด่นคือสามารถสั่งประมวลแบบคู่ขนาน (parallel) แยกตาม core ของ CPU ได้ในกรณีที่ผู้วิเคราะห์กำหนดให้สุ่มตัวอย่างจากลูกโซ่มาร์คอฟที่มีจำนวนมากกว่า 1 ลูกโซ่ ตัวอย่างคำสั่งเป็นดังนี้

```{r eval=F}
setwd("/Users/siwachoat/Library/Mobile Documents/com~apple~CloudDocs/markdown/multilevel/modelfiles/")

library(runjags)
dataList<-list(y=dat.reg$ACH, x=dat.reg$ATT, n=length(dat.reg$ACH))
initsList<-list(b0=1, b1=1, tau=1)

runjag.output<-run.jags(method="parallel",
                model="simReg.txt",
                monitor=c("b0","b1","sigma2"),
                data=dataList,
                inits=initsList,
                n.chains=3,
                burnin=2000,
                sample=10000, #n.iter
                thin=1,
                summarise=FALSE,
                plots=FALSE)
  
samples<-as.mcmc.list(runjag.output)
head(samples)
plot(samples)
```


### การวินิจฉัยการลู่เข้าของ MCMC 

การวิเคราะห์ผลลัพธ์ที่ได้จาก MCMC มีวัตถุประสงค์ 2 ประการ ประการแรกคือการวิเคราะห์เพื่อตรวจสอบ/วินิจฉัยว่าตัวอย่างที่ได้จาก MCMC ในข้างต้น เป็นตัวอย่างที่สุ่มได้จากการแจกแจงความน่าจะเป็นภายหลังที่เป็นเป้าหมายแล้วหรือไม่ (ลูกโซ่ที่สร้างขึ้นลู่เข้าสู่ posterior distribution เป้าหมายแล้วหรือไม่) และประการที่สองคือการวิเคราะห์ผลลัพธ์จาก MCMC เพื่อตอบวัตถุประสงค์ของการวิเคราะห์ข้อมูล


โดยปกติการพิจารณาการลู่เข้าของ MCMC อาจพิจารณาใน 2 มิติ มิติแรกคือการตรวจสอบว่ามีตัวอย่างส่วนใดส่วนหนึ่งของลูกโซ่ที่ลู่ออกหรือมีค่าอยู่นอกเหนือช่วงที่ควรจะเป็นการแจกแจงความน่าจะเป็นภายหลังหรือไม่ โดยปกติตัวอย่างสุ่มที่ได้จาก MCMC จะมีแนวโน้มที่ลู่เข้าหาการแจกแจงความน่าจะเป็นภายหลังมากขึ้นเรื่อย ๆ แต่ในบางสถานการณ์ที่โมเดลมีความซับซ้อน และการระบุโมเดลทำได้ไม่ดีนัก อาจทำให้การลู่เข้าดังกล่าวเป็นไปได้ช้าถึงช้ามาก หรืออาจไม่สามารถลู่เข้าสู่การแจกแจงความน่าจะเป็นภายหลังที่ต้องการได้เลย 

ในความเป็นจริงเราไม่สามารถทราบได้ว่าสถานะคงตัวของลูกโซ่มาร์คอฟนั้น เป็นการแจกแจงความน่าจะเป็นภายหลังจริง ๆ หรือไม่ การพิจารณาจึงต้องอาศัยทั้งวิธีการทางสถิติที่ช่วยตรวจสอบการลู่ออกของลูกโซ่ และวิจารณญาณของผู้วิเคราะห์ ในหัวข้อนี้จะกล่าวถึงวิธีการทางสถิติที่สำคัญบางตัว เช่น

**(1) Trace plot** พล็อตค่าของพารามิเตอร์ที่สุ่มมาจากอัลกอริทึม MCMC เรียงตามลำดับตั้งแต่ลำดับแรกไปจนถึงลำดับสุดท้าย ตัวอย่างดังรูปด้านล่าง


```{r}
library(MCMCvis)
MCMCtrace(samples, params=c("b0","b1","sigma2"), pdf=F)
```


**(2) Potential Scale Reduction ($\hat{R}$ หรือ RSRF)**

![](/Users/siwachoat/Library/Mobile Documents/com~apple~CloudDocs/markdown/multilevel/multiple chain.png){width=50%}

วิธีหนึ่งที่สามารถใช้ตรวจสอบการลู่ออกของลูกโซ่ คือการสร้างลูกโซ่เพื่อประมาณค่าพารามิเตอร์เดียวกันหลาย ๆ ตัว โดยกำหนดค่าเริ่มต้นของแต่ละลูกโซ่ให้แตกต่างกัน หากลูกโซ่ดังกล่าวมีพฤติกรรมที่แตกต่างกันจะสามารถบ่งชี้ได้ว่าตัวอย่างพารามิเตอร์ที่สุ่มจาก MCMC นี้ลู่ออกจากการแจกแจงความน่าจะเป็นภายหลังที่ต้องการ 


การวิเคราะห์นี้สามารถพิจารณาได้จากทั้ง trace plot ในข้างต้น และการใช้ค่าสถิติ $\hat{R}$ ที่มีคำนวณจากอัตราส่วนระหว่างความแปรปรวนรวมต่อความแปรปรวนภายในลูกโซ่ของตัวอย่างพารามิเตอร์


$\hat{R}=\sqrt{\frac{Var(\theta)}{W}}$

เมื่อ $Var(\theta)=(1-\frac{1}{n}W+\frac{1}{n}B)$, $W=\frac{1}{m}\sum_{j=1}^mS^2_j$,

$S_j^2=\frac{1}{n-1}\sum_{i=1}^n(\theta_{ij}-\overline{\theta}_j)^2$ และ $B=\frac{n}{m-n}\sum_{j=1}^m(\overline{\theta}_j-\overline{\theta}_{..})^2$

Rule of Thumb: $\hat{R}>1.1$ บ่งชี้ว่าลูกโซ่ของพารามิเตอร์นั้นมีการลู่ออก

```{r}
MCMCsummary(samples)
```


อีกวิธีการคือการพิจารณาเปรียบเทียบค่าคลาดเคลื่อนมาตรฐานระหว่าง Naive SE กับ Time-series SE หากทั้งสองค่านี้มีความแตกต่างกันมากในพารามิเตอร์ตัวใด บ่งชี้ว่าตัวอย่างของพารามิเตอร์ตัวนั้นเกิดอัตสหสัมพันธ์ซึ่งกันและกันสูง

```{r}
summary(samples)
```

การแก้ปัญหาในกรณีนี้มีหลายวิธีการซึ่งต้องเลือกทำตามความเหมาะสม

- กำหนด burnin period เพื่อตัดตัวอย่างส่วนแรกที่ยังไม่ลู่เข้าสู่การแจกแจงความน่าจะเป็นภายหลังออกจากการวิเคราะห์

- กำหนดจำนวน iteration เพิ่มขึ้นสำหรับ chain ที่ลู่เข้าช้า

- บางกรณีอาจต้องทำการระบุค่าเริ่มต้นใหม่ เพื่อให้การลู่เข้าทำได้ง่ายขึ้น

- [Reparameterization](https://mc-stan.org/docs/2_22/stan-users-guide/reparameterization-section.html)



มิติที่สองคือการพิจารณาว่าจำนวนรอบของการทวนซ้ำ (iteration) มีความเพียงพอหรือไม่ ปัจจัยหนึ่งที่ควรนำมาพิจารณาร่วมคืออัตสหสัมพันธ์ระหว่างตัวอย่าง ทั้งนี้เป็นเพราะลูกโซ่มาร์คอฟเป็นกระบวนการที่ตัวอย่างแต่ละตัวที่สุ่มขึ้นมาจะมีความสัมพันธ์กับตัวอย่างก่อนหน้า ดังนั้นหาความสัมพันธ์ดังกล่าวมีค่าสูงมากเกินไปจะทำให้ตัวอย่างที่ได้ยังไม่เป็นตัวแทนของการแจกแจงความน่าจะเป็นภายหลังที่ต้องการ

วิธีการหนึ่งที่ใช้พิจารณาว่าตัวอย่างมีความเพียงพอแล้วหรือไม่ คืออาจพิจารณาได้จากตัวชี้วัด effective sample size (ESS) โดยหากำหนดให้ $T$ คือจำนวน iteration ของ MCMC ที่สุ่มตัวอย่าง $x_1, x_2, ..., x_T$ ตามลำดับ และ $n_0$ คือระยะห่างที่น้อยที่สุดที่ทำให้ $x_t$ กับ $x_{t+n_0}$ เป็นอิสระซึ่งกันและกัน (หรือมีความสัมพันธ์กันน้อยมากจนตัดทิ้งได้) ดังนั้นตัวอย่างที่เป็นอิสระซึ่งกันและกัน คือตัวอย่างย่อย (sub-sample) 

<center>$x_{n_0}, x_{2n_0},x_{3n_0}...,x_{T}$</center>

ดังนั้นค่า ESS จะมีค่าเท่ากับ $T/n_0$ ซึ่งหมายถึงลูกโซ่ขนาด $T$ ที่สร้างขึ้นมีประสิทธิภาพจริงเทียบเท่าขนาดตัวอย่างเท่าใด

อีกวิธีการหนึ่งที่สามารถใช้ตรวจสอบอัตสหสัมพันธ์ระหว่างตัวอย่างในลูกโซ่มาร์คอฟได้ อีกทั้งยังสามารถใช้ประมาณระยะห่าง $n_0$ ได้ คือการพิจารณาค่าสัมประสิทธิ์อัตสหสัมพันธ์ (autocorrelation coefficient) และแผนภาพอัตสหสัมพันธ์ (autocorrelation plot) 


```{r}
autocorr.diag(samples)
autocorr.plot(samples[[1]])
```


เมื่อเกิดสถานการณ์ที่ตัวอย่างในลูกโซ่มีความสัมพันธ์กันอีกสูง การแก้ปัญหาอาจทำได้โดยตัดตัวอย่างลูกโซ่ระหว่าง $x_{n_0}$ กับ $x_{2n_0}$ ออก เรียกว่า thining และในบางกรณีอาจจำเป็นต้องเพิ่มจำนวน iteration เพื่อให้มีจำนวนตัวอย่างเพียงพอที่จะเป็นตัวแทนของการแจกแจงความน่าจะเป็นภายหลังด้วย นอกจากนี้การรวมตัวอย่างจากหลายลูกโซ่เข้าด้วยก็ช่วยแก้ปัญหาดังกล่าวได้ 


## การอนุมานเชิงสถิติแบบเบส์


จากผลการวินิจฉัย MCMC ในข้างต้น เราทำการประมวลผลใหม่ดังนี้

```{r}
setwd("/Users/siwachoat/Library/Mobile Documents/com~apple~CloudDocs/markdown/multilevel/modelfiles/")

#dataList<-list(y=dat.reg$ACH, x=dat.reg$ATT, n=length(dat.reg$ACH))
#initsList<-list(b0=1, b1=1, tau=1)

model<-jags.model(file = "simReg.txt",
                  data = dataList,
                  inits = initsList,
                  n.chains = 3)
update(model, n.iter=2000) # n.burnin
samples<-coda.samples(model,
                      variable.names=c("b0","b1","sigma2"),
                      n.iter = 30000,
                      thin=15)
MCMCsummary(samples)
MCMCtrace(samples, params=c("b0","b1","sigma2"), pdf=F)
autocorr.diag(samples)
autocorr.plot(samples[[1]])
```

### การประมาณค่าพารามิเตอร์

```{r}
summary(samples)

```

### การประมาณค่าแบบช่วงและการทดสอบสมมุติฐานของพารามิเตอร์

ฟังก์ชัน `plotPost()` สามารถใช้ประมาณช่วงความน่าเชื่อถือแบบ HDI ได้โดยง่าย ฟังก์ชันนี้มีอาร์กิวเมนท์ได้แก่

- codasamples

- cenTend

- compVal

- ROPE

- credMass

$H_0: \beta_1 =0$

```{r}
#library(googledrive)
setwd("/Users/siwachoat/Library/Mobile Documents/com~apple~CloudDocs/markdown/multilevel")
#drive_download("https://drive.google.com/file/d/0B3lh4V2Mrl14SF94US1YTkNVaHM/view?resourcekey=0-bYI7GCSuypi3a5aFt0O-qg")
source("DBDA2E-utilities.R") # (Kruschke, 2015)
plotPost(samples[,"b1"], compVal=0, cenTend="median", ROPE=c(0,0.1), credMass=0.95)
```

**Note:** ROPE ย่อมาจาก region of pratical equivalence ซึ่งก็คือช่วงการยอมรับเชิงปฏิบัติ หลักการง่าย ๆ คือ การทดสอบสมมุติฐาน $H_0: \theta = \theta_0$ แทบจะมีมีโอกาสที่ค่าเฉลี่ยตัวอย่างของพารามิเตอร์ $\theta$ ที่สุ่มจาก MCMC จะมีค่าเท่ากับ $\theta_0$ อย่างพอดี การกำหนดช่วงการยอมรับเชิงปฏิบัติ ทำให้ผู้วิเคราะห์มีเกณฑ์การพิจารณาว่าควรตัดสินใจเชื่อ $H_0$ หรือไม่ จากการเปรียบเทียบ ROPE กับช่วง HDI หากช่วง HDI ครอบคลุมช่วง ROPE อยู่นั้นแสดงว่ายังมีโอกาสสูงที่พารามิเตอร์จะมีค่าเป็นไปตามสมมุติฐาน $H_0$

$H_0: \beta_1 =0.6$


```{r}
plotPost(samples[,"b1"], compVal=0.6, cenTend="median", ROPE=c(0.55,0.65), credMass=0.95)
```




## ตัวอย่างโยนเหรียญ (รอบที่ 2)

- จากตัวอย่างที่ 1 จะได้ว่าโมเดลของค่าสังเกตเป็นฟังก์ชันความน่าจะเป็นแบบ Bernuolli ที่มีพารามิเตอร์เป็น $\theta$ เขียนแทนด้วย

<center>$y_i \sim Ber(\theta)$ โดยที่ $i=1,2,...,n$</center>


- อย่างไรก็ตามในกรณีนี้ผู้วิเคราะห์ต้องการกำหนดการแจกแจงความน่าจะเป็นก่อนหน้าแบบต่อเนื่องให้กับพารามิเตอร์ความลำเอียง $\theta$ เนื่องจากพารามิเตอร์ดังกล่าวต้องมีค่าอยู่บนช่วง $[0,1]$ การแจกแจงความน่าจะเป็นที่เหมาะสมจึงเป็นการแจกแจงแบบบีต้า (beta distribution) ที่มีพารามิเตอร์ตำแหน่ง $a$ และพารามิเตอร์สเกล $b$ ดังนั้น

<center>$\theta \sim Beta(a,b)$</center>

พารามิเตอร์ทั้งสองตัวของการแจกแจงแบบบีต้าทำให้รูปทรงการแจกแจงมีความแตกต่างกัน ซึ่งสามารถใช้สะท้อนความเชื่อเกี่ยวกับความลำเอียงของเหรียญที่แตกต่างกันได้เป็นอย่างดี รูปด้านล่างแสดงตัวอย่างโค้งความหนาแน่นของการแจกแจงแบบบีต้า เมื่อกำหนดพารามิเตอร์ต่าง ๆ 

![](/Users/siwachoat/Library/Mobile Documents/com~apple~CloudDocs/markdown/multilevel/beta.png){width=80%}
Kruschke (2012)

</br>

จากการกำหนดในข้างต้นจะสามารถเขียน syntax ของโมเดลในโปรแรกม JAGS ได้ดังนี้

```{r eval=F}
model{

# likelihood part    
for (i in 1:n)
{
  y[i]~dbern(theta)
  
}
  
# prior part
  theta~beta(a,b)

# deterministic part
  a<-3
  b<-2
}

```

การประมวลผลโมเดลข้างต้นด้วยโปรแกรม JAGS บน R จำเป็นต้องมีการ wrap up คำสั่งข้างต้นให้เป็น text file เพื่อส่งออกไปยังโปรแกรม R โดยเขียนคำสั่งดังนี้

```{r}
coin_model="

model{

# likelihood part    
for (i in 1:n)
{
  y[i]~dbern(theta)
  
}
  
# prior part
  theta~dbeta(a,b)

# deterministic part
  a<-3
  b<-2
}

"
writeLines(coin_model, con="/Users/siwachoat/Library/Mobile Documents/com~apple~CloudDocs/markdown/multilevel/modelfiles/coin_model.txt")
```

ขั้นตอนถัดมาคือการประมาณการแจกแจงความน่าจะเป็นภายหลังของพารามิเตอร์ $\theta$ โดยใช้เทคนิค MCMC ผ่านโปรแกรม JAGS ซึ่งสามารถสั่งงานได้ผ่านฟังก์ชัน `jag.model()` โดยฟังก์ชันนี้มีอาร์กิวเมนท์ที่สำคัญที่เกี่ยวข้องกับการระบุคุณลักษณะของลูกโซ่มาร์คอฟที่ต้องการสร้างขึ้น ได้แก่

- ข้อมูลค่าสังเกต ในที่นี้สมมุติว่าทำการทดลอง 20 ครั้งได้ผลเป็นดังนี้

```{r}
y<-rbinom(20,1,0.65)
data.list<-list(y=y, n=20)
```

- `n.chains`


```{r}
library(rjags)
fit<-jags.model(file="/Users/siwachoat/Library/Mobile Documents/com~apple~CloudDocs/markdown/multilevel/modelfiles/coin_model.txt", data=data.list,
                n.chains = 3)
samples<-coda.samples(fit,variable.names=c("theta"),n.iter=5000)
```

```{r}
plot(samples)
autocorr.diag(samples)
summary(samples)
```


เหรียญเที่ยงตรงหรือไม่?? ---> กำหนด ROPE = [0.48,0.52]

```{r}
plotPost(samples[,"theta"], compVal=0.5, cenTend="median", ROPE=c(0.48,0.1), credMass=0.95)
```



# Multilevel Modelling

หัวข้อนี้จะกล่าวถึงการวิเคราะห์ multilevel model ด้วยวิธีการแบบเบส์ จากชุดข้อมูล hsb สมมุติว่านักวิจัยมีคำถามวิจัยดังนี้

1. ผลสัมฤทธิ์ทางการเรียนวิชาคณิตศาสตร์ของนักเรียนมีความแตกต่างกันระหว่างโรงเรียนหรือไม่?

2. โรงเรียนโดยเฉลี่ยแล้วนักเรียนมีเศราฐานะทางบ้านสูงจะมีค่าเฉลี่ยผลสัมฤทธิ์ทางคณิตศาสตร์สูงด้วยหรือไม่?

3. ความสัมพันธ์ในระดับนักเรียนระหว่าง SES กับ mathach มีมากน้อยแค่ไหน? ความสัมพันธ์ดังกล่าวมีความแตกต่างกันไปตามโรงเรียนหรือไม่อย่างไร?

4. เมื่อเปรียบเทียบกันระหว่างโรงเรียนรัฐบาลกับโรงเรียนในเครือคาทอลิก ในมิติของผลสัมฤทธิ์ทางการเรียนวิชาคณิตศาตร์ และระดับความสััมพันธ์ระหว่าง ses กับ mathach มีความแตกต่างกันหรือไม่ เมื่อมีการควบคุมความผันแปรของ mathach ด้วยค่าเฉลี่ยเศรษฐานะของนักเรียนในแต่ละโรงเรียนแล้ว

จงออกแบบการวิเคราะห์เพื่อตอบคำถามวิจัยในข้างต้น


## One-Way ANOVA with random effect

null model หรือโมเดลการวิเคราะห์ความแปรปรวนแบบอิทธิพลสุ่มมีสมการดังนี้


level-1 model: $y_{ij}=\beta_{0j}+\epsilon_{ij}$

level-2 model: $\beta_{0j}=\gamma_{00}+u_{0j}$

combined model: $y_{ij}=\gamma_{00}+u_{0j}+\epsilon_{ij}$

โดยที่ตัวแปรตามคือ mathach ในชุดข้อมูล hsb หากดำเนินการวิเคราะห์ข้อมูลด้วยวิธีการแบบดั้งเดิม จะได้ผลการวิเคราะห์เป็นดังนี้

```{r}
library(foreign)
dat1<-read.spss("/Users/siwachoat/Downloads/hsb1.sav", to.data.frame = TRUE)
dat2<-read.spss("/Users/siwachoat/Library/Mobile Documents/com~apple~CloudDocs/เอกสารประกอบการสอน/2756714/HLM/hsb2.sav", to.data.frame=TRUE)
dat<-merge(dat1,dat2, by="schoolid")
library(lme4)
library(lmerTest)
fit<-lmer(mathach~1+(1|schoolid), data=dat1)
ranova(fit) #reduce random-effect term
summary(fit)
performance::icc(fit)

# reliability of the sample mean (Raudenbush & Bryk (2002) p.46)
nj<-table(dat1$schoolid)
reliaj<-8.614/(8.614+39.148/nj)
hist(reliaj)
mean(reliaj)
```

```{r}
#calculate level-1 residual
res1<-dat1$mathach-predict(fit)
res1<-data.frame(schoolid=dat1$schoolid, res1)
#calculate level-2 residual
res2<-coef(fit)$schoolid-12.6370
names(res2)<-"res2"
res2<-data.frame(schoolid=as.numeric(names(table(dat1$schoolid))), res2)


#normality
ggplot(res1)+geom_histogram(aes(x=res1))
ggplot(res2)+geom_histogram(aes(x=res2))

library(ggpubr)
ggqqplot(res1$res1)
ggqqplot(res2$res2)

#homogeneity of variance
res1%>%group_by(schoolid)%>%summarise(var.e=var(res1))%>%summary()
res1%>%group_by(schoolid)%>%summarise(var.e=var(res1))%>%ggplot(aes(x=var.e))+geom_density()
```

หากดำเนินการวิเคราะห์ด้วยวิธีการแบบ bayes โดยใช้โปรแกรม JAGS อาจดำเนินการได้ดังนี้


```{r}
library(rjags)

#generate model file
null.model<-"model{

for (i in 1:n)
{
y[i]~dnorm(mu[i],inv.sigma2)
mu[i]<-beta0j[schoolid[i]]
}

for (j in tab)
{
beta0j[j]~dnorm(gamma00, inv.tau00)
}

inv.sigma2~dgamma(0.0001,0.0001)
inv.tau00~dgamma(0.0001,0.0001)
gamma00~dnorm(0,10^-4) T(0,) #half-normal distribution

sigma2<-inv.sigma2^(-1)
tau00<-inv.tau00^(-1)

icc<-tau00/(tau00+sigma2)

}"

writeLines(null.model,con="null_model.txt")

datlist<-list(y=dat1$mathach,schoolid=dat1$schoolid, n=length(dat1$mathach),
              tab=as.numeric(names(table(dat1$schoolid))))
fit.null<-jags.model(file="null_model.txt",
                     data=datlist,
                     n.chains=3)

update(fit.null,n.iter=2000) #n.burnin
output<-coda.samples(fit.null,
                     variable.names=c("gamma00","tau00","sigma2","icc"),
                     n.iter=30000,
                     thin=2)

library(MCMCvis)
MCMCtrace(output, params=c("gamma00","icc"), pdf=F)
MCMCsummary(output)
summary(output)
```

```{r}
plotPost(output[,"icc"], compVal=0.05, cenTend="median", ROPE=c(0.04,0.06), credMass=0.95,
         xlab="ICC")
```




```{r}
library(rjags)

#generate model file
null.model<-"model{

for (i in 1:n)
{
y[i]~dnorm(mu[i],inv.sigma2[schoolid[i]])
mu[i]<-beta0j[schoolid[i]]
}

for (j in tab)
{
beta0j[j]~dnorm(gamma00, inv.tau00)
inv.sigma2[j]~dgamma(0.0001,0.0001)
sigma2[j]<-inv.sigma2[j]^(-1)

}

inv.tau00~dgamma(0.0001,0.0001)
gamma00~dnorm(0,10^-4) T(0,) #half-normal distribution
tau00<-inv.tau00^(-1)
}"

writeLines(null.model,con="null_model.txt")

datlist<-list(y=dat1$mathach,schoolid=dat1$schoolid, n=length(dat1$mathach),
              tab=as.numeric(names(table(dat1$schoolid))))
fit.hetero<-jags.model(file="null_model.txt",
                     data=datlist,
                     n.chains=3)

update(fit.hetero,n.iter=2000) #n.burnin
output<-coda.samples(fit.hetero,
                     variable.names=c("gamma00","tau00","sigma2"),
                     n.iter=30000,
                     thin=2)

library(MCMCvis)
MCMCsummary(output)
#summary(output)
```

การเปรียบเทียบโมเดลแบบเบส์สามารถทำได้หลายวิธีการ วิธีการหนึ่งคือการใช้ดัชนี DIC ซึ่ง JAGS คำนวณให้ DIC มีสูตรคำนวณดังนี้

กำหนดให้ deviance มีค่าเท่ากับ$D(\theta)=-2log(p(\bf{y}|\theta))+C$ โดยที่ $C$ คือค่าคงที่

การคำนวณค่า DIC มีหลายวิธีการ วิธีการหลักนำเสนอโดย Spiegelhalter และคณะ (2002) และ Gelman และคณะ (2004) ดังนี้

- Spiegelhalter et al. (2002) กำหนดให้ $p_D=\overline{D(\theta})-D(\overline{\theta})$

- Gelman และคณะ (2004) กำหนดให้ $p_D=\frac{1}{2}\overline{Var(D(\theta))}$

$DIC = p_d+\overline{D(\theta)}$

หรือ

$DIC = D(\overline{\theta})+2p_D$

จากสูตรในข้างต้นจะเห็นว่าโมเดลที่มีค่า DIC ต่ำกว่าจะเป็นโมเดลที่มีความเหมาะสมมากกว่า 

```{r}
dic.samples(fit.null, n.iter=30000, thin = 2)
dic.samples(fit.hetero, n.iter=30000, thin = 2)

```

 
## package-brms

ผู้เรียนจะเห็นว่าการระบุโมเดลในภาษา JAGS ข้างต้นจำเป็นต้องอาศัยความเชี่ยวชาญพอสมควร นอกจากนี้ยังค่อนข้างใช้เวลาในการเขียนโมเดลถึงแม้จะเป็นโมเดลพื้นฐานอย่าง one-way ANOVA ในข้างต้น ปัจจุบันมี package หลายตัวที่ทำหน้าที่เป็นส่วนต่อประสานระหว่างผู้ใช้กับ engine ต่าง ๆ ซึ่งใช้ภาษาที่เรียบง่ายกว่า ทำให้การ modelling ด้วยวิธีการแบบเบส์ทำได้สะดวกและง่ายขึ้น หัวข้อนี้จะกล่าวถึง package-brms (ย่อมาจาก bayesian multilevel models using stan) ซึ่งเป็น high-level API ตัวหนึ่งของภาษา Stan รายละเอียดมีดังนี้

### ขอบเขตของ model ใน package-brms

โมเดลทั่วไปที่สามารถวิเคราะห์ได้ด้วย package-brms มีรูปแบบดังนี้

$y_i \sim D(f(\eta_i),\theta)$

เมื่อ $y_i$ คือค่าสังเกตของตัวแปรตาม ที่มีการแจกแจง $D$ ในโปรแกรม R จะเรียก $D$ นี้ว่า `family` ในขณะที่ $f(.)$ คือ link function, $\theta$ คือพารมิเตอร์ของการแจกแจง $D$ ซึ่งสามารถมีได้หลายตัวขึ้นอยู่กับการแจกแจงที่กำหนด และ $eta_i$ คือผลรวมเชิงเส้นของตัวแปรอิสระซึ่งสามารถเขียนได้ในรูปทั่วไปดังนี้

$\bf{\eta}=\bf{X}\beta+\bf{Z}u$

$\beta$ คือสัมประสิทธิ์ความถดถอยในระดับ individual ส่วน $u$ คือสัมประสิทธิ์ความถดถอยในระดับกลุ่ม $X$ และ $Z$ คือ design matrix ของตัวแปรอิสระในระดับ individual และ กลุ่ม ตามลำดับ


### prior distribution

นอกจากจะมีประสิทธิภาพที่ดีในด้านของอัลกอริทึม MCMC แล้ว Stan ยังสามารถกำหนด prior distribution ได้มีประสิทธิภาพมากกว่าใน JAGS รวมถึง BUGS ด้วย รายละเอียดไปอ่านเอง [ไม่อ่านก็ตามใจ](https://mc-stan.org/docs/2_21/functions-reference/discrete-distributions.html#discrete-distributions)

**individual-level reg coef** ---> flat prior

**group-level reg coef** ---> $\bf{u} \sim N(\bf{0},\Sigma)$

เมื่อ $\Sigma$ คือเมทริกซ์ความแปรปรวนร่วม ซึ่งเป็นไปได้ทั้ง diagonal matrix และ symmetry matrix ขึ้นอยู่กับการกำหนด prior distribution ของเมทริกซ์ความแปรปรวนร่วมดังกล่าว นอกจากนี้ยังสามารถ model ให้ group-level reg coef นี้มีการแจกแจงที่เป็นอิสระไปตามกลุ่มได้อีกด้วย  ---> $\bf{u}_j \sim N(\bf{0},\Sigma_j)$ 

โดยปกติ prior distribution ของ covariance matrix จะกำหนดให้เป็นการแจกแจงแบบ Inverse-Wishart ซึ่งเป็น conjugacy prior กับ exponential family ต่าง ๆ และทำให้อัลกอริทึม Gibb-samplers มีประสิทธิภาพสูง อย่างไรก็ตามใน Stan ไม่จำเป็นต้องกำหนดการแจกแจงในลักษณะดังกล่าว ทำให้การกำหนด prior ของพารามิเตอร์นี้ทำได้ง่ายและมีความหมายที่เข้าใจได้ชัดเจนมากขึ้น ดังนี้

กำหนดให้ $\Sigma_k=D(\sigma_k)\Omega_kD(\sigma_k)$

เมื่อ $D(\sigma_k)$ คือ diagonal matrix ของส่วนเบี่ยงเบนมาตรฐานของ $u_k$ ส่วน $\Omega$ คือเมทริกซ์สหสัมพันธ์ของพารามิเตอร์ $\bf{u}$ ดังกล่าว Lewandowski และคณะ (2009) เสนอให้กำหนด prior ของเมทริกซ์สหสัมพันธ์นี้เป็น LKJ-Correlation prior ที่มีพารามิเตอร์ $\zeta>0$ กล่าวคือ $\Omega \sim LKJ(\zeta)$

- ถ้า $\zeta=1$ (ค่าเริ่มต้น) การแจกแจงจะมีลักษณะเป็น uniform บน correlation matrix

- ถ้า $\zeta>1$ การแจกแจงจะมีลักษณะลู่เข้าหา identity matrix ขึ้นอยู่กับค่าของ $zeta$ 

- ถ้า $0<\zeta<1$ การแจกแจงมีลักษณะเป็น U-shape กล่าวคือให้ค่าความน่าจะเป็นที่จะมีค่า correlation สูง

ส่วน $sigma_k$ สามารถกำหนด prior distribution แยกรายตัวหรือให้เหมือนกันทั้งหมดก็ได้ ค่าเริ่มต้นของ brms คือการแจกแจงทีแบบครึ่งเดียว (half-Student-t prior) ที่มีองศาความเป็นอิสระเท่ากับ 3

brms ยังสามารถ model ให้พารามิเตอร์ในระดับ individual กับ group มีความสัมพันธ์กันได้ด้วย โดยการแตกเมทริกซ์ $\Sigma_k$ เป็นดังนี้ $\Sigma_k=V_k \otimes  A_k$ เมื่อ $V_k$ คือเมทริกซ์ความแปรปรวนร่วมในระดับกลุ่ม (แทน $\Sigma_k$ ตัวเดิม) และ $A_k$ คือเมทริกซืความแปรปรวนร่วมของพารามิเตอร์ระหว่างระดับ individual กับ group


### การประมาณค่าพารามิเตอร์ในโมเดล

อย่างที่กล่าวไว้ก่อนหน้าแล้วว่า brms ที่ใช้ Stan เป็น engine นั้นมีอัลกอริทึมประมาณค่าพารามิเตอร์ที่มีประสิทธิภาพสูงกว่า JAGS และ BUGS ในแง่ของคุณภาพของตัวอย่างพารามิเตอร์ที่ได้จาก MCMC กล่าวคือตัวอย่างที่ได้จะลู่เข้าหาการแจกแจงความน่าจะเป็นภายหลังได้อย่างรวดเร็ว และมีความค่าอัตสหสัมพันธ์ต่ำ ทำให้ผู้วิเคราะห์ไม่จำเป็นต้องรันลูกโซ่ยาวมากเหมือนกับ Gibb-sampler ใน JAGS และ BUGS อย่างไรก็ตามหากเปรียบเทียบกันต่อรอบ Stan จะใช้เวลามากกว่า

ข้อดีอีกประการหนึ่งของการใช้ Stan ผ่าน brms คือจะให้ค่าสถิติสำหรับเปรียบเทียบโมเดลไว้หลายตัวได้แก่ WAIC และ LOO ซึ่งเป็นดัชนีทีปรับปรุงจาก DIC 

ผู้เรียนได้ติดตั้ง package-brms ลงในเครื่องแล้ว ตัวอย่างต่อไปนี้จะแสดงการรัน null model ด้วย brms 

```{r message=F, warnings=F}
library(brms)
fit.brm1<-brm(formula = mathach ~ 1 + (1|schoolid), data=dat1,
              family=gaussian(),
              warmup=1000,
              iter=3000,
              chains=3)
plot(fit.brm1)
summary(fit.brm1)
```

posterior predictive check

```{r}
pp_check(fit.brm1, resp = "mathach")
bayes_R2(fit.brm1)
loo(fit.brm1)
```


เราสามารถปรับเปลี่ยน prior ได้หลายวิธีการ วิธีการหนึ่งคือการเรียกค่าเริ่มต้นของ prior มาก่อน แล้วปรับเปลี่ยนทีละตัวตามต้องการดังนี้

```{r}
priors<-get_prior(mathach ~ 1 + (1|schoolid), data=dat1,
              family=gaussian())
priors
priors$prior[1]<-"normal(0,20)" #mu and sd
```

จากนั้นก็ run ใหม่โดยกำหนดอาร์กิวเมนท์ prior ดังนี้

```{r message=F, warnings=F}
fit.brm2<-brm(formula = mathach ~ 1 + (1|schoolid), data=dat1,
              family=gaussian(),
              prior=priors,
              warmup=1000,
              iter=3000,
              chains=3)
```

ผู้วิเคราะห์สามารถทดสอบสมมุติฐานของพารามิเตอร์ที่ต้องการในโมเดลได้ โดยใช้วิธีการเปรียบเทียบ test value กับ HDI โดยใช้ฟังก์ชัน `hypothesis()` ดังตัวอย่างต่อไปนี้

```{r}
hypothesis(fit.brm1, "Intercept>0", class="sd", group="schoolid", alpha=0.05)
```

### Extract output from brm

ผู้วิเคราะห์สามารถแปลงผลการวิเคราะห์ที่ได้ใช้เป็น mcmc objects แล้วไปวิเคราะห์แบบเดิมก็ได้ดังนี้

```{r}
gamma.mcmc<-as.mcmc(as.data.frame(fit.brm1, pars="b_Intercept"))
tau.mcmc<-as.mcmc(as.data.frame(fit.brm1, pars="sd")^2)
sigma2.mcmc<-as.mcmc(as.data.frame(fit.brm1, variable="sigma"))^2
icc<-tau.mcmc/(tau.mcmc+sigma2.mcmc)
mean(icc)
sd(icc)
plotPost(icc, compVal=0.05, cenTend="median", ROPE=c(0.04,0.06), credMass=0.95)
```


อีกลักษณะหนึ่งสามารถทำได้โดยใช้ package-tidybayes ช่วย สามารถอ่านเพิ่มเติมได้จาก  [ไม่อ่านก็ตามใจ](http://mjskay.github.io/tidybayes/articles/tidy-brms.html#introduction-1)


```{r}
library(tidybayes)
get_variables(fit.brm1)%>%head(15)

fit.brm1%>%spread_draws(r_schoolid[schoolid, Intercept]) #group-mean

fit.brm1%>%spread_draws(b_Intercept,sd_schoolid__Intercept) #grand-mean and sqrt(tau00)

# mean and median with quantile interval
fit.brm1%>%spread_draws(b_Intercept,sd_schoolid__Intercept)%>%
              mean_qi()
fit.brm1%>%spread_draws(b_Intercept,sd_schoolid__Intercept)%>%
              median_qi()

```

## random-coefficient model

```{r message=F, warnings=F}
priors<-get_prior(mathach~1+ses+(1+ses|schoolid), 
            data=dat, family=gaussian())
priors
priors$prior[1]<-"normal(0,20)" #mu and sd

fit.brm3<-brm(mathach~1+ses+(1+ses|schoolid), 
            data=dat, family="gaussian",
            prior=c(set_prior("horseshoe(1)", class="b"),
                    set_prior("student_t(1,0,5)", class="sd"),
                    set_prior("lkj(0.8)", class="cor")),
            warmup=1000, iter=6000, chains=3, thin=5,
            cores=3)
plot(fit.brm3)
summary(fit.brm3)
pp_check(fit.brm3, resp = "mathach")
bayes_R2(fit.brm3)
loo(fit.brm3)
```





<style>

@import url('https://fonts.googleapis.com/css2?family=Krub:wght@400;500;600&display=swap');

@import url('https://fonts.googleapis.com/css2?family=Sarabun&display=swap');


.math {font-size: 1.05em;}

body{ /* Normal  */
      font-family: 'Sarabun', sans-serif;
      line-height: 1.9px;
      color: #152D35;
      font-size: 16px;
  }

</style>

