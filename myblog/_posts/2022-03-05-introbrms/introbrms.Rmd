---
title: "brms package"
categories:
  - Bayesian Statistics
  - brms package
  - GLM
  - GLMs
  - Multilevel
description: |
  Bayesian modelling using brms package
author:
  - name: Siwachoat Srisuttiyakorn
    url: {}
date: 2022-03-05
output:
  distill::distill_article:
    self_contained: false
    toc: true
    toc_depth: 2
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

# package-brms

ผู้เรียนจะเห็นว่าการระบุโมเดลในภาษา JAGS ข้างต้นจำเป็นต้องอาศัยความเชี่ยวชาญพอสมควร นอกจากนี้ยังค่อนข้างใช้เวลาในการเขียนโมเดลถึงแม้จะเป็นโมเดลพื้นฐานอย่าง one-way ANOVA ในข้างต้น ปัจจุบันมี package หลายตัวที่ทำหน้าที่เป็นส่วนต่อประสานระหว่างผู้ใช้กับ engine ต่าง ๆ ซึ่งใช้ภาษาที่เรียบง่ายกว่า ทำให้การ modelling ด้วยวิธีการแบบเบส์ทำได้สะดวกและง่ายขึ้น หัวข้อนี้จะกล่าวถึง package-brms (ย่อมาจาก bayesian multilevel models using stan) ซึ่งเป็น high-level API ตัวหนึ่งของภาษา Stan รายละเอียดมีดังนี้

## ขอบเขตของ model ใน package-brms

โมเดลทั่วไปที่สามารถวิเคราะห์ได้ด้วย package-brms มีรูปแบบดังนี้

$y_i \sim D(f(\eta_i),\theta)$

เมื่อ $y_i$ คือค่าสังเกตของตัวแปรตาม ที่มีการแจกแจง $D$ ในโปรแกรม R จะเรียก $D$ นี้ว่า `family` ในขณะที่ $f(.)$ คือ link function, $\theta$ คือพารมิเตอร์ของการแจกแจง $D$ ซึ่งสามารถมีได้หลายตัวขึ้นอยู่กับการแจกแจงที่กำหนด และ $eta_i$ คือผลรวมเชิงเส้นของตัวแปรอิสระซึ่งสามารถเขียนได้ในรูปทั่วไปดังนี้

$\bf{\eta}=\bf{X}\beta+\bf{Z}u$

$\beta$ คือสัมประสิทธิ์ความถดถอยในระดับ individual ส่วน $u$ คือสัมประสิทธิ์ความถดถอยในระดับกลุ่ม $X$ และ $Z$ คือ design matrix ของตัวแปรอิสระในระดับ individual และ กลุ่ม ตามลำดับ


## prior distribution

นอกจากจะมีประสิทธิภาพที่ดีในด้านของอัลกอริทึม MCMC แล้ว Stan ยังสามารถกำหนด prior distribution ได้มีประสิทธิภาพมากกว่าใน JAGS รวมถึง BUGS ด้วย รายละเอียดไปอ่านเอง [ไม่อ่านก็ตามใจ](https://mc-stan.org/docs/2_21/functions-reference/discrete-distributions.html#discrete-distributions)

**individual-level reg coef** ---> flat prior

**group-level reg coef** ---> $\bf{u} \sim N(\bf{0},\Sigma)$

เมื่อ $\Sigma$ คือเมทริกซ์ความแปรปรวนร่วม ซึ่งเป็นไปได้ทั้ง diagonal matrix และ symmetry matrix ขึ้นอยู่กับการกำหนด prior distribution ของเมทริกซ์ความแปรปรวนร่วมดังกล่าว นอกจากนี้ยังสามารถ model ให้ group-level reg coef นี้มีการแจกแจงที่เป็นอิสระไปตามกลุ่มได้อีกด้วย  ---> $\bf{u}_j \sim N(\bf{0},\Sigma_j)$ 

โดยปกติ prior distribution ของ covariance matrix จะกำหนดให้เป็นการแจกแจงแบบ Inverse-Wishart ซึ่งเป็น conjugacy prior กับ exponential family ต่าง ๆ และทำให้อัลกอริทึม Gibb-samplers มีประสิทธิภาพสูง อย่างไรก็ตามใน Stan ไม่จำเป็นต้องกำหนดการแจกแจงในลักษณะดังกล่าว ทำให้การกำหนด prior ของพารามิเตอร์นี้ทำได้ง่ายและมีความหมายที่เข้าใจได้ชัดเจนมากขึ้น ดังนี้

กำหนดให้ $\Sigma_k=D(\sigma_k)\Omega_kD(\sigma_k)$

เมื่อ $D(\sigma_k)$ คือ diagonal matrix ของส่วนเบี่ยงเบนมาตรฐานของ $u_k$ ส่วน $\Omega$ คือเมทริกซ์สหสัมพันธ์ของพารามิเตอร์ $\bf{u}$ ดังกล่าว Lewandowski และคณะ (2009) เสนอให้กำหนด prior ของเมทริกซ์สหสัมพันธ์นี้เป็น LKJ-Correlation prior ที่มีพารามิเตอร์ $\zeta>0$ กล่าวคือ $\Omega \sim LKJ(\zeta)$

- ถ้า $\zeta=1$ (ค่าเริ่มต้น) การแจกแจงจะมีลักษณะเป็น uniform บน correlation matrix

- ถ้า $\zeta>1$ การแจกแจงจะมีลักษณะลู่เข้าหา identity matrix ขึ้นอยู่กับค่าของ $zeta$ 

- ถ้า $0<\zeta<1$ การแจกแจงมีลักษณะเป็น U-shape กล่าวคือให้ค่าความน่าจะเป็นที่จะมีค่า correlation สูง

ส่วน $\sigma_k$ สามารถกำหนด prior distribution แยกรายตัวหรือให้เหมือนกันทั้งหมดก็ได้ ค่าเริ่มต้นของ brms คือการแจกแจงทีแบบครึ่งเดียว (half-Student-t prior) ที่มีองศาความเป็นอิสระเท่ากับ 3

brms ยังสามารถ model ให้พารามิเตอร์ในระดับ individual กับ group มีความสัมพันธ์กันได้ด้วย โดยการแตกเมทริกซ์ $\Sigma_k$ เป็นดังนี้ $\Sigma_k=V_k \otimes  A_k$ เมื่อ $V_k$ คือเมทริกซ์ความแปรปรวนร่วมในระดับกลุ่ม (แทน $\Sigma_k$ ตัวเดิม) และ $A_k$ คือเมทริกซ์ความแปรปรวนร่วมของพารามิเตอร์ระหว่างระดับ individual กับ group


# Regression Analysis

อย่างที่กล่าวไว้ก่อนหน้าแล้วว่า brms ที่ใช้ Stan เป็น engine นั้นมีอัลกอริทึมประมาณค่าพารามิเตอร์ที่มีประสิทธิภาพสูงกว่า JAGS และ BUGS ในแง่ของคุณภาพของตัวอย่างพารามิเตอร์ที่ได้จาก MCMC กล่าวคือตัวอย่างที่ได้จะลู่เข้าหาการแจกแจงความน่าจะเป็นภายหลังได้อย่างรวดเร็ว และมีความค่าอัตสหสัมพันธ์ต่ำ ทำให้ผู้วิเคราะห์ไม่จำเป็นต้องรันลูกโซ่ยาวมากเหมือนกับ Gibb-sampler ใน JAGS และ BUGS อย่างไรก็ตามหากเปรียบเทียบกันต่อรอบ Stan จะใช้เวลามากกว่าในการจำลองตัวอย่าง

ผู้เรียนได้ติดตั้ง package-brms ลงในเครื่องแล้ว ตัวอย่างต่อไปนี้จะแสดงการรัน regression model ชุดข้อมูลที่ใช้เป็นตัวอย่างอยู่ในไฟล์ `regression_dat1.csv` ดังนี้

```{r echo=TRUE}
dat<-read.csv("/Users/siwachoat/Documents/myblog/myblog/_posts/2022-02-19-glm1/regression_dat1.csv")
head(dat)
```

การประมาณค่าพารามิเตอร์ด้วย package-brms จะสั่งงานผ่านฟังก์ชัน `brm()` ซึ่งมีอาร์กิวเมนท์สำคัญได้แก่ `formula` สำหรับระบุรูปแบบของโมเดล อย่างที่กล่าวในข้างต้นว่าขอบเขตของโมเดลเป็นไปได้ทั้ง โมเดลเชิงเส้น โมเดลเชิงเส้นแบบวางนัยทั่วไป และสามารถวิเคราะห์ได้ทั้งแบบโมเดลระดับเดียว และโมเดลพหุระดับ อาร์กิวเมนท์ `data` ใช้ระบุชุดข้อมูลสำหรับวิเคราะห์ `family` ใช้ระบุการแจกแจงของตัวแปรตามในโมเดลการวิเคราะห์ การแจกแจงดังกล่าวจะอยู่ภายใต้การแจกแจงในกลุ่มวงศ์ชี้กำลัง (exponential family) เช่น normal distribution, binomial, poisson เป็นต้น ส่วนที่เหลือเป็นอาร์กิวเมนท์ที่เกี่ยวข้องกับกระบวนการ MCMC ได้แก่ `warmup` หรือระยะ burn-in อาร์กิวเมนท์ `iter` สำหรับระบุจำนวนรอบที่ต้องการทวนซ้ำ (iteration) อาร์กิวเมนท์ `chains` ใช้ระบุจำนวนลูกโซ่ที่ต้องการสร้าง เป็นต้น รายละเอียดของฟังก์ชันสามารถเรียกดูได้โดยพิมพ์คำสั่ง `?brm()` 

ตัวอย่างด้านล่างแสดงการเขียนคำสั่งเพื่อประมาณการแจกแจง posterior ในโมเดล multiple regression โดยใช้ข้อมูลตัวอย่างข้างต้น

```{r echo=TRUE, fit.height=6, warning=F, message=F, results=F}
library(brms)
library(ggplot2)
fit.reg<-brm(Score~., data=dat[,-1],
             family=gaussian(),
             warmup=1000,
             iter=3000,
             chains=3,
             cores=10)
```


## การตรวจสอบการลู่เข้าของลูกโซ่

ขั้นตอนการดำเนินงานสำคัญของการใช้ MCMC ในการประมาณ posterior distribution ของพารามิเตอร์คือ การตรวจสอบคุณภาพของลูกโซ่ที่สร้างขึ้น หรือที่เรียกว่าการตรวจสอบการลู่เข้าของลูกโซ๋ ผู้วิเคราะห์สามารถใช้ฟังก์ชัน `plot()` และ `summary()` เพื่อเรียกดูผลลัพธ์เบื้องต้นได้โดยง่าย ดังตัวอย่างด้านล่าง

```{r echo=TRUE, fit.height=9}
plot(fit.reg, N=3,
     theme=theme(text=element_text(family="ChulaCharasNew")))
summary(fit.reg)
```
ผลการวิเคราะห์ทั้งจากแผนภาพความหนาแน่น แผนภาพร่องรอย และผลการวิเคราะห์เชิงตัวเลขสนับสนุนว่าตัวอย่างของพารามิเตอร์ที่สร้างขึ้นจากกระบวนการ MCMC นี้มีแนวโน้มลู่เข้าสู่การแจกแจงความน่าจะเป็นเดียวกัน บ่งชี้ว่าตัวอย่างพารามิเตอร์ดังกล่าวมีคุณภาพ

การสร้างแผนภาพสามารถทำได้หลายวิธี อันนี้ก็เป็นอีกวิธีหนึ่งที่ใช้ฟังก์ชัน `stanplot()` ที่มีมาให้ใน package

```{r echo=TRUE}
stanplot(fit.reg, type="trace")
stanplot(fit.reg, type="dens_overlay")
stanplot(fit.reg, type="acf_bar")
```


## การตรวจสอบความเหมาะสมของโมเดล


ผู้วิเคราะห์สามารถตรวจสอบความเหมาะสมของโมเดลได้ง่าย ๆ ดังนี้

```{r echo=TRUE}
#posterior predictive
pp_check(fit.reg, resp = "Score")
#bayesian R2
bayes_R2(fit.reg)
#loo index
loo(fit.reg)
waic(fit.reg)
```


## prior distributions

เราสามารถปรับเปลี่ยน prior ได้หลายวิธีการ วิธีการหนึ่งคือการเรียกค่าเริ่มต้นของ prior มาก่อน แล้วปรับเปลี่ยนทีละตัวตามต้องการดังนี้

```{r echo=TRUE}
priors<-get_prior(Score ~ ., data=dat[,-1],
              family=gaussian())
priors
```

จากผลลัพธ์ข้างต้นแสดงให้เห็น default prior ของ brms-packages จำแนกเป็น prior ของ slope parameters ใช้สัญลักษณ์ `b` กำหนดเป็น flat prior  ส่วน intercept และ sigma กำหนดเป็น student's t priors ในกรณีที่ต้องการเปลี่ยน prior ของพารามิเตอร์ภายในโมเดลสามารถทำได้โดยการ assign prior ใหม่ดังตัวอย่างต่อไปนี้

```{r echo=TRUE}
priors$prior[2:5]<-c("normal(0,100)","normal(2,5)","normal(5,5)","normal(0,100)") #mu and sd
priors
```

จากนั้นนำ prior ที่กำหนดใหม่นี้ไปกำหนดใน argument `prior` ของฟังก์ชัน `brm()` ดังนี้

```{r message=F, warnings=F, echo=T, results=F}
fit.reg2<-brm(formula = Score ~., data=dat[,-1],
              family=gaussian(),
              prior=priors,
              warmup=1000,
              iter=3000,
              chains=3)
```

```{r echo=TRUE}
fit.reg2
```

ผู้วิเคราะห์สามารถทดสอบสมมุติฐานของพารามิเตอร์ที่ต้องการในโมเดลได้ โดยใช้วิธีการเปรียบเทียบ test value กับ HDI โดยใช้ฟังก์ชัน `hypothesis()` ดังตัวอย่างต่อไปนี้

```{r echo=TRUE}
hypothesis(fit.reg, "Hour>0", class="b", alpha=0.05)
hypothesis(fit.reg, "Home.Statuspoor<0", class="b" ,alpha=0.05)
```

## Extract output from brm

ผู้วิเคราะห์สามารถแปลงผลการวิเคราะห์ที่ได้ใช้เป็น mcmc objects แล้วไปวิเคราะห์แบบเดิมก็ได้ดังนี้

```{r layout="l-body-outset",fig.height=6, fig.width=9, echo=T}
sample<-as.data.frame(fit.reg)
library(bayesboot)
par(mfrow=c(2,2))
plotPost(sample$b_Hour, compVal=0, cenTend="median", ROPE=c(0,0.2), credMass=0.95,
         xlab=expression(beta[Hour]))
plotPost(sample$b_Class.Behav, compVal=0, cenTend="median", ROPE=c(0,0.2), credMass=0.95)
plotPost(sample$b_Home.Statuspoor, compVal=0, cenTend="median", ROPE=c(-0.2,0), credMass=0.95)
plotPost(sample$b_Teach.Quagood, compVal=0, cenTend="median", ROPE=c(-0.2,0), credMass=0.95)
```

เราสามารถสร้าง output เพื่อเปรียบเทียบขนาดอิทธิพลของตัวแปรอิสระที่มีต่อตัวแปรตามได้ด้วยฟังก์ชัน `stanplot()` อย่างไรก็ตามสัมประสิทธิ์ความชันที่นำมาเปรียบเทียบกันต้องเป็นสัมประสิทธิ์ความถดถอยในสเกลคะแนนมาตรฐาน อย่างไรก็ตาม brms-package ไม่ได้ให้ output ส่วนนี้มาการแก้ปัญหาคือผู้วิเคราะห์จะต้องสร้าง output เอง เช่น

```{r echo=TRUE, results=F}
dat.standardized<-dat[,-1]
dat.standardized[,1:2]<-scale(dat[,2:3])
fit.reg_standard<-brm(Score~., 
                      data=dat.standardized,
                      family=gaussian(),
                      warmup=1000,
                      iter=3000,
                      chains=3,
                      cores=10)
```


```{r echo=TRUE}
stanplot(fit.reg_standard, 
         variable=c("b_Hour","b_Class.Behav","b_Home.Statuspoor","b_Teach.Quagood"),
         type="areas",
         prob = 0.95)
```


อีกลักษณะหนึ่งสามารถทำได้โดยใช้ package-tidybayes ช่วย สามารถอ่านเพิ่มเติมได้จาก  [ไม่อ่านก็ตามใจ](http://mjskay.github.io/tidybayes/articles/tidy-brms.html#introduction-1)



## Two-way ANOVA model

[ชุดข้อมูล](https://docs.google.com/spreadsheets/d/1LfWDuJw9rNJSPpktTwe9EbCn-xVCkVhv/edit?usp=sharing&ouid=118010069578157348024&rtpof=true&sd=true)

ชุดข้อมูลตัวอย่างประกอบด้วยข้อมูลของตัวแปรตามคือผลสัมฤทธิ์ทางการเรียนวิชาคณิตศาตร์ (Math) ตัวแปรอิสระได้แก่ วิธีการสอน (Method) และความสามารถทางเทคโนโลยี (Tech)



## ANCOVA model

[ชุดข้อมูล](https://drive.google.com/file/d/0B3lh4V2Mrl14M0JiX0tEdTloUXc/view?usp=sharing&resourcekey=0-jY5hCZtUMJmdCq9GsxnKNA)



## Logistic Regression


การวิเคราะห์โมเดลในกลุ่ม BGLMs สามารถระบุโมเดลและวิเคราะห์ในทำนองเดียวกับการวิเคราะห์ BGLM ความแตกต่างระหว่าง BGLM กับ BGLMs คือ ค่าสังเกตของ BGLMs มีการแจกแจงไม่ใช่การแจกแจงแบบปกติ และจำเป็นต้องใช้ link function เพื่อแปลงค่าของพารามิเตอร์ในการแจกแจงของค่าสังเกต ให้อยู่ในรูปแบบของโมเดลเชิงเส้นเพื่อให้พารามิเตอร์ที่ผ่านการแปลงแล้วมีความหมาย และสามารถใช้บรรยายความสัมพันธ์ระหว่างตัวแปรที่ต้องการได้ 

โมเดล glms สามารถนิยามในรูปแบบทั่วไปได้ดังนี้ กำหนดให้ $y_i$ เมื่อ $i=1,2,3,...,n$ เป็นค่าสังเกตของตัวแปรตามที่มีการแจกแจงอยู่ในวงศ์ชี้กำลัง (exponential family) โดยที่

$E[y_i]=\mu_i=g^{-1}(\eta_i)$, $\eta_i=\beta_0+\beta_1x_{1i}+...+\beta_kx_{ki}$

- การแจกแจงในวงศ์ชี้กำลังเป็นกลุ่มของการแจกแจงความน่าจะเป็นที่ฟังก์ชันความน่าจะเป็นอยู่ในรูปของ exponential function เช่น normal distribution, poisson และ binomial 

# Binomial model

จากนิยามข้างต้นจะเห็นว่า การกำหนด link function $g(.)$ ที่เหมาะสม จะช่วยแปลงพารามิเตอร์ในการแจกแจงของค่าสังเกต $y_i$ ให้อยู่ในรูปแบบของสมการเชิงเส้นตรงได้ เช่นใน binomial model ที่มีพารามิเตอร์กำกับการแจกแจงคือ ความน่าจะเป็นของการเกิดเหตุการณ์ที่สนใจ $\theta$ สามารถกำหนด link function ได้เป็น logit function $logit(\theta)=log(\theta/(1-\theta))$ หรือ probit function $\Phi^{-1}(\theta)$ ที่เป็น inverse ของ cumulative normal probability function เป็นต้น เรียกอัตราส่วน $\theta/(1-\theta)$ ว่า odd ของการเกิดเหตุการณ์ โดยถ้า

- odd > 1 แสดงว่า โอกาสที่จะเกิดเหตุการณ์ $y=1$ มีมากกว่าไม่เกิด

- odd = 1 แสดงว่า โอกาสของการเกิดเหตุการ์กับไม่เกิดมีเท่ากัน

- odd < 1 แสดงว่า โอกาสของการเกิดเหตุการณ์ $y=1$ มีน้อยกว่าไม่เกิด

ใน binomial model เนื่องจาก $y_i$ มีค่าที่เป็นไปได้ 2 ค่าได้แก่ 0, 1 ดังนั้นค่าเฉลี่ยของ $y$ จึงมีค่าเป็นสัดส่วนหรือความน่าจะเป็นของการเกิดค่าสังเกต $y=1$ กล่าวคือ $E[y_i]=\theta$ ดังนั้น

$g(E[y_i])=\eta_i \implies logit(\theta)=\eta_i=\beta_0+\beta_1x_{1i}+...+\beta_kx_{ki}$

จากความหมายของ logit function และสมการ logit ในข้างต้น จะเห็นว่า เราสามารถเขียน  odd ในรูปของสมการเชิงเส้นของตัวแปรอิสระที่เลือกมาใช้ในโมเดลทำนายได้ดังนี้

$odd = \frac{\theta}{1-\theta}=exp(\beta_0+\beta_1x_{1i}+...+\beta_kx_{ki})$

สมการข้างต้นสามารถใช้อธิบายอิทธิพลของตัวแปรอิสระที่มีต่อโอกาสของการเกิดเหตุการณ์ที่สนใจได้ เมื่อกำหนดให้ตัวแปรอิสระอื่น ๆ คงที่ ดังนี้ สมมุติว่าสนใจการเปลี่ยนแปลงใน $x_1$ โดยหากตัวแปรดังกล่าวเพิ่มขึ้นจากเดิมคือ $x_1$ ไปเป็น $x_{1}+1$ (เพิ่มขึ้น 1 หน่วย) แล้วค่า odd ของเหตุการณ์ที่สนใจจะเปลี่ยนแปลงไป วัดได้เป็นอัตราส่วนระหว่าง odd ของทั้งสอง conditions ดังนี้

$\frac{odd_{x_1+1}}{odd_{x_1}}=\frac{exp(\beta_0+\beta_1(x_{1i}+1)+...+\beta_kx_{ki})}{exp(\beta_0+\beta_1x_{1i}+...+\beta_kx_{ki})}=exp(\beta_1)$

เรียกว่า $exp(\beta_1)$ ดังกล่าวว่า อัตราส่วนของ odds (odds ratio: OR) ค่าสถิตินี้จะใช้เพื่ออธิบายความสัมพันธ์/อิทธิพลของตัวแปรอิสระที่มีต่อโอกาสของการเกิดเหตุการณ์ โดย เมื่อกำหนดให้ปัจจัยอื่น ๆ คงที่

- ถ้า OR > 1 หมายถึง X มีความสัมพันธ์ทางบวกกับโอกาสของการเกิดเหตุการณ์

- ถ้า OR = 1 หมายถึง X ไม่มีความสัมพันธ์กับโอกาสของการเกิดเหตุการณ์

- ถ้า OR < 1 หมายถึง X มีความสัมพันธ์ทางลบกับโอกาสของการเกิดเหตุการณ์

inverse ของ logit function เรียกว่า logistic function จากสมการ logit ข้างต้นจะได้ว่า

$\theta_i=logit^{-1}(\eta_i)=\frac{1}{1+exp(\beta_0+\beta_1x_{1i}+...+\beta_kx_{ki})}$

เรียกสมการข้างต้นว่า สมการถดถอย logistic ใช้คำนวณค่าความน่าจะเป็นของการเกิดเหตุการณ์ที่สนใจ

สมมุติว่า ผู้วิเคราะห์ต้องการวิเคราะห์ความสำเร็จในการเรียน online ของนักเรียน โดยใช้ตัวแปรได้แก่ จำนวนเวลาที่นักเรียนใช้ในการเข้ามาเรียน online ต่อครั้ง (Hours) ค่าเฉลี่ยของความถี่ในการเข้ามาเรียน online ต่อสัปดาห์ (Freq) และฐานนิยมของคุณภาพชิ้นงานที่นักเรียนทำส่งในระบบ online (Mode_Qua)

[ชุดข้อมูล](https://drive.google.com/file/d/1dwRReZ-bg6lzKR4RJ7fyT7dy7yXVrIUB/view?usp=sharing)

```{r echo=TRUE}
dat<-read.csv("/Users/siwachoat/Documents/myblog/myblog/_posts/2022-03-05-glm2/binomial.csv")
head(dat)
dim(dat)
```

การวิเคราะห์ logistic regression ด้วย brms-package สามารถเขียนคำสั่งได้ดังนี้



---

Distill is a publication format for scientific and technical writing, native to the web.

Learn more about using Distill at <https://rstudio.github.io/distill>.


