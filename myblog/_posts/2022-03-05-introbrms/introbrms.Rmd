---
title: "brms package"
categories:
  - Bayesian Statistics
  - brms package
  - GLM
  - GLMs
  - Multilevel
description: |
  Bayesian modelling using brms package
author:
  - name: Siwachoat Srisuttiyakorn
    url: {}
date: 2022-03-05
output:
  distill::distill_article:
    self_contained: false
    toc: true
    toc_depth: 2
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

## package-brms

ผู้เรียนจะเห็นว่าการระบุโมเดลในภาษา JAGS ข้างต้นจำเป็นต้องอาศัยความเชี่ยวชาญพอสมควร นอกจากนี้ยังค่อนข้างใช้เวลาในการเขียนโมเดลถึงแม้จะเป็นโมเดลพื้นฐานอย่าง one-way ANOVA ในข้างต้น ปัจจุบันมี package หลายตัวที่ทำหน้าที่เป็นส่วนต่อประสานระหว่างผู้ใช้กับ engine ต่าง ๆ ซึ่งใช้ภาษาที่เรียบง่ายกว่า ทำให้การ modelling ด้วยวิธีการแบบเบส์ทำได้สะดวกและง่ายขึ้น หัวข้อนี้จะกล่าวถึง package-brms (ย่อมาจาก bayesian multilevel models using stan) ซึ่งเป็น high-level API ตัวหนึ่งของภาษา Stan รายละเอียดมีดังนี้

### ขอบเขตของ model ใน package-brms

โมเดลทั่วไปที่สามารถวิเคราะห์ได้ด้วย package-brms มีรูปแบบดังนี้

$y_i \sim D(f(\eta_i),\theta)$

เมื่อ $y_i$ คือค่าสังเกตของตัวแปรตาม ที่มีการแจกแจง $D$ ในโปรแกรม R จะเรียก $D$ นี้ว่า `family` ในขณะที่ $f(.)$ คือ link function, $\theta$ คือพารมิเตอร์ของการแจกแจง $D$ ซึ่งสามารถมีได้หลายตัวขึ้นอยู่กับการแจกแจงที่กำหนด และ $eta_i$ คือผลรวมเชิงเส้นของตัวแปรอิสระซึ่งสามารถเขียนได้ในรูปทั่วไปดังนี้

$\bf{\eta}=\bf{X}\beta+\bf{Z}u$

$\beta$ คือสัมประสิทธิ์ความถดถอยในระดับ individual ส่วน $u$ คือสัมประสิทธิ์ความถดถอยในระดับกลุ่ม $X$ และ $Z$ คือ design matrix ของตัวแปรอิสระในระดับ individual และ กลุ่ม ตามลำดับ


### prior distribution

นอกจากจะมีประสิทธิภาพที่ดีในด้านของอัลกอริทึม MCMC แล้ว Stan ยังสามารถกำหนด prior distribution ได้มีประสิทธิภาพมากกว่าใน JAGS รวมถึง BUGS ด้วย รายละเอียดไปอ่านเอง [ไม่อ่านก็ตามใจ](https://mc-stan.org/docs/2_21/functions-reference/discrete-distributions.html#discrete-distributions)

**individual-level reg coef** ---> flat prior

**group-level reg coef** ---> $\bf{u} \sim N(\bf{0},\Sigma)$

เมื่อ $\Sigma$ คือเมทริกซ์ความแปรปรวนร่วม ซึ่งเป็นไปได้ทั้ง diagonal matrix และ symmetry matrix ขึ้นอยู่กับการกำหนด prior distribution ของเมทริกซ์ความแปรปรวนร่วมดังกล่าว นอกจากนี้ยังสามารถ model ให้ group-level reg coef นี้มีการแจกแจงที่เป็นอิสระไปตามกลุ่มได้อีกด้วย  ---> $\bf{u}_j \sim N(\bf{0},\Sigma_j)$ 

โดยปกติ prior distribution ของ covariance matrix จะกำหนดให้เป็นการแจกแจงแบบ Inverse-Wishart ซึ่งเป็น conjugacy prior กับ exponential family ต่าง ๆ และทำให้อัลกอริทึม Gibb-samplers มีประสิทธิภาพสูง อย่างไรก็ตามใน Stan ไม่จำเป็นต้องกำหนดการแจกแจงในลักษณะดังกล่าว ทำให้การกำหนด prior ของพารามิเตอร์นี้ทำได้ง่ายและมีความหมายที่เข้าใจได้ชัดเจนมากขึ้น ดังนี้

กำหนดให้ $\Sigma_k=D(\sigma_k)\Omega_kD(\sigma_k)$

เมื่อ $D(\sigma_k)$ คือ diagonal matrix ของส่วนเบี่ยงเบนมาตรฐานของ $u_k$ ส่วน $\Omega$ คือเมทริกซ์สหสัมพันธ์ของพารามิเตอร์ $\bf{u}$ ดังกล่าว Lewandowski และคณะ (2009) เสนอให้กำหนด prior ของเมทริกซ์สหสัมพันธ์นี้เป็น LKJ-Correlation prior ที่มีพารามิเตอร์ $\zeta>0$ กล่าวคือ $\Omega \sim LKJ(\zeta)$

- ถ้า $\zeta=1$ (ค่าเริ่มต้น) การแจกแจงจะมีลักษณะเป็น uniform บน correlation matrix

- ถ้า $\zeta>1$ การแจกแจงจะมีลักษณะลู่เข้าหา identity matrix ขึ้นอยู่กับค่าของ $zeta$ 

- ถ้า $0<\zeta<1$ การแจกแจงมีลักษณะเป็น U-shape กล่าวคือให้ค่าความน่าจะเป็นที่จะมีค่า correlation สูง

ส่วน $sigma_k$ สามารถกำหนด prior distribution แยกรายตัวหรือให้เหมือนกันทั้งหมดก็ได้ ค่าเริ่มต้นของ brms คือการแจกแจงทีแบบครึ่งเดียว (half-Student-t prior) ที่มีองศาความเป็นอิสระเท่ากับ 3

brms ยังสามารถ model ให้พารามิเตอร์ในระดับ individual กับ group มีความสัมพันธ์กันได้ด้วย โดยการแตกเมทริกซ์ $\Sigma_k$ เป็นดังนี้ $\Sigma_k=V_k \otimes  A_k$ เมื่อ $V_k$ คือเมทริกซ์ความแปรปรวนร่วมในระดับกลุ่ม (แทน $\Sigma_k$ ตัวเดิม) และ $A_k$ คือเมทริกซืความแปรปรวนร่วมของพารามิเตอร์ระหว่างระดับ individual กับ group


### การประมาณค่าพารามิเตอร์ในโมเดล

อย่างที่กล่าวไว้ก่อนหน้าแล้วว่า brms ที่ใช้ Stan เป็น engine นั้นมีอัลกอริทึมประมาณค่าพารามิเตอร์ที่มีประสิทธิภาพสูงกว่า JAGS และ BUGS ในแง่ของคุณภาพของตัวอย่างพารามิเตอร์ที่ได้จาก MCMC กล่าวคือตัวอย่างที่ได้จะลู่เข้าหาการแจกแจงความน่าจะเป็นภายหลังได้อย่างรวดเร็ว และมีความค่าอัตสหสัมพันธ์ต่ำ ทำให้ผู้วิเคราะห์ไม่จำเป็นต้องรันลูกโซ่ยาวมากเหมือนกับ Gibb-sampler ใน JAGS และ BUGS อย่างไรก็ตามหากเปรียบเทียบกันต่อรอบ Stan จะใช้เวลามากกว่า

ข้อดีอีกประการหนึ่งของการใช้ Stan ผ่าน brms คือจะให้ค่าสถิติสำหรับเปรียบเทียบโมเดลไว้หลายตัวได้แก่ WAIC และ LOO ซึ่งเป็นดัชนีทีปรับปรุงจาก DIC 

ผู้เรียนได้ติดตั้ง package-brms ลงในเครื่องแล้ว ตัวอย่างต่อไปนี้จะแสดงการรัน regression model

```{r echo=TRUE}
dat<-read.csv("/Users/siwachoat/Documents/myblog/myblog/_posts/2022-02-19-glm1/regression_dat1.csv")
head(dat)
```

```{r echo=TRUE, fit.height=6, warning=F, message=F}
library(brms)
library(ggplot2)
fit.reg<-brm(Score~., data=dat[,-1],
             family=gaussian(),
             warmup=1000,
             iter=3000,
             chains=3,
             cores=3)
```

```{r echo=TRUE, fit.height=9}
plot(fit.reg, N=3,
     theme=theme(text=element_text(family="ChulaCharasNew")))
summary(fit.reg)
```


ผู้วิเคราะห์สามารถตรวจสอบความเหมาะสมของโมเดลได้ง่าย ๆ ดังนี้

```{r}
#posterior predictive
pp_check(fit.reg, resp = "Score")
#bayesian R2
bayes_R2(fit.reg)
#loo index
loo(fit.reg)
waic(fit.reg)
```


เราสามารถปรับเปลี่ยน prior ได้หลายวิธีการ วิธีการหนึ่งคือการเรียกค่าเริ่มต้นของ prior มาก่อน แล้วปรับเปลี่ยนทีละตัวตามต้องการดังนี้

```{r}
priors<-get_prior(Score ~ ., data=dat,
              family=gaussian())
priors
priors$prior[1]<-"normal(0,20)" #mu and sd
```

จากนั้นก็ run ใหม่โดยกำหนดอาร์กิวเมนท์ prior ดังนี้

```{r message=F, warnings=F}
fit.reg2<-brm(formula = Score ~., data=dat[,-1],
              family=gaussian(),
              prior=priors,
              warmup=1000,
              iter=3000,
              chains=3)
```

ผู้วิเคราะห์สามารถทดสอบสมมุติฐานของพารามิเตอร์ที่ต้องการในโมเดลได้ โดยใช้วิธีการเปรียบเทียบ test value กับ HDI โดยใช้ฟังก์ชัน `hypothesis()` ดังตัวอย่างต่อไปนี้

```{r}
hypothesis(fit.reg, "Hour>0", class="b", alpha=0.05)
hypothesis(fit.reg, "Home.Statuspoor<0", class="b" ,alpha=0.05)
```

### Extract output from brm

ผู้วิเคราะห์สามารถแปลงผลการวิเคราะห์ที่ได้ใช้เป็น mcmc objects แล้วไปวิเคราะห์แบบเดิมก็ได้ดังนี้

```{r}
sample<-as.data.frame(fit.reg)
library(bayesboot)
par(mfrow=c(2,2))
plotPost(sample$b_Hour, compVal=0, cenTend="median", ROPE=c(0,0.2), credMass=0.95,
         xlab=expression(beta[Hour]))
plotPost(sample$b_Class.Behav, compVal=0, cenTend="median", ROPE=c(0,0.2), credMass=0.95)
plotPost(sample$b_Home.Statuspoor, compVal=0, cenTend="median", ROPE=c(-0.2,0), credMass=0.95)
plotPost(sample$b_Teach.Quagood, compVal=0, cenTend="median", ROPE=c(-0.2,0), credMass=0.95)
```


อีกลักษณะหนึ่งสามารถทำได้โดยใช้ package-tidybayes ช่วย สามารถอ่านเพิ่มเติมได้จาก  [ไม่อ่านก็ตามใจ](http://mjskay.github.io/tidybayes/articles/tidy-brms.html#introduction-1)



## Two-way ANOVA model

## ANCOVA model

## Logistic Regression


การวิเคราะห์โมเดลในกลุ่ม BGLMs สามารถระบุโมเดลและวิเคราะห์ในทำนองเดียวกับการวิเคราะห์ BGLM ความแตกต่างระหว่าง BGLM กับ BGLMs คือ ค่าสังเกตของ BGLMs มีการแจกแจงไม่ใช่การแจกแจงแบบปกติ และจำเป็นต้องใช้ link function เพื่อแปลงค่าของพารามิเตอร์ในการแจกแจงของค่าสังเกต ให้อยู่ในรูปแบบของโมเดลเชิงเส้นเพื่อให้พารามิเตอร์ที่ผ่านการแปลงแล้วมีความหมาย และสามารถใช้บรรยายความสัมพันธ์ระหว่างตัวแปรที่ต้องการได้ 

โมเดล glms สามารถนิยามในรูปแบบทั่วไปได้ดังนี้ กำหนดให้ $y_i$ เมื่อ $i=1,2,3,...,n$ เป็นค่าสังเกตของตัวแปรตามที่มีการแจกแจงอยู่ในวงศ์ชี้กำลัง (exponential family) โดยที่

$E[y_i]=\mu_i=g^{-1}(\eta_i)$, $\eta_i=\beta_0+\beta_1x_{1i}+...+\beta_kx_{ki}$

- การแจกแจงในวงศ์ชี้กำลังเป็นกลุ่มของการแจกแจงความน่าจะเป็นที่ฟังก์ชันความน่าจะเป็นอยู่ในรูปของ exponential function เช่น normal distribution, poisson และ binomial 

# Binomial model

จากนิยามข้างต้นจะเห็นว่า การกำหนด link function $g(.)$ ที่เหมาะสม จะช่วยแปลงพารามิเตอร์ในการแจกแจงของค่าสังเกต $y_i$ ให้อยู่ในรูปแบบของสมการเชิงเส้นตรงได้ เช่นใน binomial model ที่มีพารามิเตอร์กำกับการแจกแจงคือ ความน่าจะเป็นของการเกิดเหตุการณ์ที่สนใจ $\theta$ สามารถกำหนด link function ได้เป็น logit function $logit(\theta)=log(\theta/(1-\theta))$ หรือ probit function $\Phi^{-1}(\theta)$ ที่เป็น inverse ของ cumulative normal probability function เป็นต้น

ใน binomial model เนื่องจาก $y_i$ มีค่าที่เป็นไปได้ 2 ค่าได้แก่ 0, 1 ดังนั้นค่าเฉลี่ยของ $y$ จึงมีค่าเป็นสัดส่วนหรือความน่าจะเป็นของการเกิดค่าสังเกต $y=1$ กล่าวคือ $E[y_i]=\theta$ ดังนั้น

$g(E[y_i])=\eta_i \implies logit(\theta)=\eta_i=\beta_0+\beta_1x_{1i}+...+\beta_kx_{ki}$

สมมุติว่า ผู้วิเคราะห์ต้องการวิเคราะห์ความสำเร็จในการเรียน online ของนักเรียน โดยใช้ตัวแปรได้แก่ จำนวนเวลาที่นักเรียนใช้ในการเข้ามาเรียน online ต่อครั้ง (Hours) ค่าเฉลี่ยของความถี่ในการเข้ามาเรียน online ต่อสัปดาห์ (Freq) และฐานนิยมของคุณภาพชิ้นงานที่นักเรียนทำส่งในระบบ online (Mode_Qua)

```{r}
dat<-read.csv("/Users/siwachoat/Documents/myblog/myblog/_posts/2022-03-05-glm2/binomial.csv")
head(dat)
dim(dat)
```

กำหนดโมเดลของค่าสังเกตเป็น

$y_i \sim Binomial(\theta_i, n_i)$

และ $logit(\theta_i)=\beta_0+\beta_1hour+\beta_2freq+\beta_3mod.qua$



---

Distill is a publication format for scientific and technical writing, native to the web.

Learn more about using Distill at <https://rstudio.github.io/distill>.


