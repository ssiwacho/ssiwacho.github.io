# ตอนที่ 4.1 การนำเข้าและเขียนชุดข้อมูล (importing and writing data) {.unnumbered}

การนำเข้าข้อมูลถือได้ว่าเป็นขั้นตอนแรกของการดำเนินงานวิเคราะห์ข้อมูล ในบทเรียนนี้จะกล่าวถึงการนำเข้าข้อมูลลักษณะต่าง ๆ ในภาษา R และ Python รวมทั้งการเขียนชุดข้อมูลเป็นไฟล์ข้อมูลเพื่อนำไปใช้ตามวัตถุประสงค์ต่าง ๆ บทเรียนนี้จะกล่าวถึงการนำเข้าไฟล์ข้อมูลที่มักใช้ในการทำงานทางด้านสถิติและวิทยาการข้อมูล ได้แก่ ไฟล์ข้อมูลประเภท flat file และไฟล์ข้อมูลประเภท spreadsheet รายละเอียดมีดังนี้

## เรื่องที่ 4.1.1 การกำหนด working directory

สิ่งสำคัญอย่างแรกที่ผู้ใช้ภาษา R และ Python จำเป็นต้องทราบก่อนที่จะนำเข้าหรือเขียนชุดข้อมูลคือการเรียกดูและกำหนด working directory ของโปรแกรม working directory คือ folder ที่ R หรือ Python ใช้สำหรับเรียกไฟล์ข้อมูลหรือบันทึกไฟล์ข้อมูล รวมทั้งไฟล์อื่น ๆ ที่เกี่ยวข้อง

#### ภาษา R

ใน R ผู้วิเคราะห์สามารถเรียกดู working directory ของโปรแกรมได้โดยใช้ฟังก์ชัน `getwd()` ดังตัวอย่างต่อไปนี้

```{r eval=F}
getwd()
```

```{r echo=F}
setwd("/Users/siwachoat/Desktop")
getwd()
dir<-getwd()
```

ผลลัพธ์ในข้างต้นแสดงว่า working directory ที่กำหนดมีที่อยู่คือ "`r dir`" ในกรณีที่ต้องการเปลี่ยนที่อยู่ของ working directory สามารถทำได้ด้วยฟังก์ชัน `setwd()` โดยกำหนดที่อยู่ของ working directory ที่ต้องการเอาไว้ภายใต้เครื่องหมาย quotation ยกตัวอย่างเช่นต้องการเปลี่ยน working directory จากเดิม "`r dir`" เป็น "/Users/siwachoat/Documents" สามารถเขียนคำสั่งได้ดังนี้

```{r}
setwd("/Users/siwachoat/Documents")
getwd()
```

จากคำสั่งข้างต้นจะเห็นว่า working directory เปลี่ยนจาก "`r dir`" ไปเป็น "/Users/siwachoat/Documents" ตามที่ต้องการ

**หมายเหตุ :** เนื่องจากที่อยู่ของ working directory อาจเป็น subfolder ภายใต้ folder ใด ๆ บนเครื่องคอมพิวเตอร์ การกำหนดที่อยู่ของ working directory ที่ต้องการจึงจะกำหนดโดยเขียนเรียงเป็นลำดับชั้นจาก directory ที่อยู่บนสุดลงไปจาก subdirectory ที่อยู่ภายใต้ directory นั้น และจะมีการใช้สัญลักษณ์ `\` หรือ `//` อย่างใดอย่างหนึ่งเป็นตัวคั่นระหว่าง directory กับ subdirectory ดังกล่าว

#### ภาษา Python

สำหรับภาษา Python การเรียกดูและกำหนด working directory สามารถทำได้ด้วย library os โดยใช้ฟังก์ชัน `os.getcwd()` และ `os.chdir()` ตามลำดับ ตัวอย่างต่อไปนี้แสดงการเรียกดู working directory ในภาษา Python

```{python}
import os
os.getcwd()
```

```{python echo=TRUE}
import os
os.chdir("/Users/siwachoat/Desktop")
os.getcwd()
```

ในทำนองเดียวกับตัวอย่างในภาษา R ผลลัพธ์ข้างต้นแสดงให้เห็นว่า working directory ที่กำหนดไว้คือ "/Users/siwachoat/Desktop" ในกรณีที่ต้องการเปลี่ยน working directory ดังกล่าวสามารถได้โดยเขียนคำสั่งในทำนองเดียวกับโปรแกรม R ดังนี้

```{python}
os.chdir("/Users/siwachoat/Documents")
os.getcwd()
```

## เรื่องที่ 4.1.2 การนำเข้าและเขียนข้อมูลประเภท flat files

flat files เป็นไฟล์ข้อมูลที่อยู่ในรูปแบบข้อความ (plain text) และชุดข้อมูลไม่ได้มีโครงสร้างการจัดเก็บในรูปแบบตารางหรือ spreadsheet แต่ flat file จะมีการใช้ตัวอักษรพิเศษ เช่น comma (,), slash (/) หรือ underscore (\_) เป็นตัวคั่น (separator or delimiter) เพื่อจำแนกข้อมูลที่แตกต่างกันออกจากกัน รูป 4.1 แสดงลักษณะของชุดข้อมูลแบบ flat file ที่มีการใช้ตัวคั่นแบบ comma (,) และแบบเว้นวรรค (tab) จากรูปจะเห็นว่าตัวอย่างของไฟล์ข้อมูลทั้งสองมีโครงสร้างการจัดเก็บข้อมูลที่เหมือนกันกล่าวคือ ในแถวแรกของไฟล์ข้อมูลเป็นที่จัดเก็บชื่อของตัวแปรภายในชุดข้อมูล และตั้งแต่แถวที่สองเป็นต้นไปเป็นที่จัดเก็บข้อมูลของตัวแปรต่าง ๆ ของแต่ละหน่วยข้อมูล อย่างไรก็ตามในทางปฏิบัติแถวแรกของไฟล์ข้อมูลไม่จำเป็นจะต้องเป็นชื่อของตัวแปรเสมอไป

![รูป 4.1 ตัวอย่างโครงสร้างของ flat file แบบ CSV และ TSV](flatfile.png){fig-align="left" width="60%"}

ที่มา : สิวะโชติ ศรีสุทธิยากร (2564)

flat file ยังมีการเรียกชื่อที่เฉพาะตามลักษณะของตัวคั่นที่ใช้ในชุดข้อมูล จากรูปจะเห็นว่าชุดข้อมูลด้านบนมีการใช้ comma (,) เป็นตัวคั่น จะเรียกไฟล์ข้อมูลประเภทนี้ว่า comma separated values (CSV) หรืออาจเรียกว่า comma-delimited ก็ได้ ส่วนชุดข้อมูลด้านล่างของรูปมีการใช้ตัวคั่นเป็นการเว้นวรรค (tab) จะเรียกชุดข้อมูลประเภทนี้ว่า tab separated values (TSV) หรือ tab-delimited

### การนำเข้าและเขียนไฟล์แบบ CSV

หัวข้อนี้จะกล่าวถึงวิธีการนำเข้าและเขียนไฟล์ข้อมูลแบบ CSV โดยจำแนกเนื้อหาออกเป็นสองส่วนได้แก่ ส่วนของภาษา R และ ภาษา Python รายละเอียดมีดังนี้

#### ภาษา R

ภาษา R สามารถนำเข้าและเขียนไฟล์ CSV ได้หลายวิธี วิธีการแรกเป็นการนำเข้าด้วยฟังก์ชันจาก package-utils ที่เป็น package พื้นฐานของ R ได้แก่ฟังก์ชัน `read.csv()` ที่มีอาร์กิวเมนท์สำคัญได้แก่ `file` ใช้ระบุที่อยู่และชื่อของไฟล์ข้อมูลแบบ CSV ที่ต้องการนำเข้าอาร์กิวเมนท์นี้ผู้วิเคราะห์จำเป็นต้องกำหนดแบบตัวแปรตัวอักษร (กล่าวคือต้องระบุไว้ภายใต้เครื่องหมาย quotation) อาร์กิวเมนท์ `header` ใช้ระบุว่าไฟล์ข้อมูลที่นำเข้ามีแถวแรกของไฟล์เป็นชื่อของตัวแปรหรือไม่ การกำหนดอาร์กิวเมนท์นี้กำหนดเป็นค่าความจริงได้แก่ `TRUE` หรือ `FALSE` โดยหากกำหนดเป็น `TRUE` (ค่าเริ่มต้น) จะหมายถึงการระบุว่าใช้แถวแรกของไฟล์ข้อมูลเป็นชื่อของตัวแปรในแต่ละคอลัมน์ ในกรณีที่กำหนดเป็น `FALSE` ฟังก์ชัน CSV จะกำหนดชื่อของคอลัมน์ให้โดยอัตโนมัติ ตัวอย่างด้านล่างแสดงการนำเข้าชุดข้อมูล [`gapminder_mini.csv`](https://github.com/ssiwacho/dataset/blob/main/gapminder_mini.csv)

```{r eval=F}
# R syntax
dat <- read.csv("gapminder_mini.csv", header = TRUE)
str(dat)
```

```{r echo=F}
url<-"https://raw.githubusercontent.com/ssiwacho/dataset/main/gapminder_mini.csv"
dat <- read.csv(url)
str(dat)
```

อาร์กิวเมนท์อีกตัวที่สำคัญของฟังก์ชัน `read.csv()` คืออาร์กิวเมนท์ `na.strings` ใช้ในกรณีที่ชุดข้อมูลที่ต้องการนำเข้ามีค่าสูญหาย การระบุอาร์กิวเมนท์ดังกล่าวให้ระบุเป็นสัญลักษณ์ที่ใช้แทนค่าสูญหายของชุดข้อมูลที่ต้องการนำเข้า เช่น หากชุดข้อมูลที่นำเข้าใช้สัญลักษณ์ `-999` แทนค่าสูญหายให้กำหนด `na.strings = -999` เป็นต้น นอกจากนี้ฟังก์ชัน `read.csv()` ยังมีอาร์กิวเมนท์ `stringsAsFactors` ที่กำหนดค่าเป็น `TRUE` หรือ `FALSE` เพื่อแปลงคอลัมน์ตัวอักษรในชุดข้อมูลให้เป็นตัวแปรแบบ factor ซึ่งเป็นตัวแปรแบบจัดประเภทของ R ผู้อ่านสามารถศึกษารายละเอียดเพิ่มเติมได้จาก สิวะโชติ ศรีสุทธิยากร (2564) หน้า 40

ตัวอย่างข้างต้นมีการใช้ฟังก์ชัน `str()` เพื่อเรียกดูข้อมูลเบื้องต้นของชุดข้อมูล `gapminder_mini.csv` ที่นำเข้ามาด้วยฟังก์ชัน `read.csv()` ในข้างต้น ฟังก์ชันดังกล่าวจะรายงานมิติหรือขนาดของชุดข้อมูล ชื่อของตัวแปรในแต่ละคอลัมนท์ รวมทั้งคุณลักษณะของตัวแปรภายในแต่ละคอลัมน์ สำหรับผู้ที่เคยใช้ SPSS จะพอเทียบเคียงได้ว่าผลลัพธ์จากฟังก์ชัน `str()` นี้จะให้สารสนเทศในทำนองเดียวกับหน้าต่าง variable view ของโปรแกรม SPSS รายละเอียดของฟังก์ชันนี้จะกล่าวอีกครั้งหนึ่งในหัวข้อ 4.2

ภาษา R ยังมีความสามารถในการเขียนไฟล์ชุดข้อมูลเพื่อส่งออกไปบันทึกในคอมพิวเตอร์สำหรับนำไปใช้ในวัตถุประสงค์ต่าง ๆ การเขียนไฟล์แบบ CSV สามารถทำได้หลายวิธีการเช่นกัน วิธีการพื้นฐานคือการใช้ฟังก์ชัน `write.csv()` ที่มีอาร์กิวเมนท์สำคัญ 2 ตัวได้แก่ `x` คือชุดข้อมูลแบบ Dataframe ที่ต้องการเขียนออกไปเป็นไฟล์แบบ CSV และ `file` ใช้ระบุที่อยู่และชื่อของไฟล์ปลายทางที่จะให้ R เขียนออกไปบันทึกในคอมพิวเตอร์ ทั้งนี้รูปแบบของชื่อไฟล์ต้องเขียนในลักษณะตัวอักษรกล่าวคืออยู่ภายใต้เครื่องหมาย quotation และมีนามสกุลของไฟล์เป็นแบบ \`\*.csv\` ดังตัวอย่างด้านล่าง

```{r eval=F}
# R syntax
write.csv(dat, file="Desktop/mydata.csv")
```

คำสั่งด้านบนจะเขียนไฟล์ `my.data.csv` ไว้บน Desktop ของเครื่องคอมพิวเตอร์ ในกรณีที่ผู้วิเคราะห์กำหนดแค่ชื่อไฟล์ปลายทางแต่ไม่ได้กำหนดที่อยู่ของไฟล์ เช่น `write.csv(dat, file="mydata.csv")` ไฟล์ที่สร้างขึ้นจะบันทึกไว้ใน folder เป็นค่าเริ่มต้นหรือ folder ที่กำหนดเป็น working directory เอาไว้ การกำหนด working directory สามารถทำได้โดยใช้ฟังก์ชัน `setwd()` โดยภายในฟังก์ชันให้ใส่ที่อยู่ของ folder ที่ต้องการกำหนดให้เป็น working directory ในลักษณะตัวอักษร เช่น `setwd("/Desktop/myjob")` หมายถึงกำหนดให้ working directory เป็น folder myjob ที่อยู่บน Desktop ของเครื่องคอมพิวเตอร์ รายละเอียดอื่น ๆ เกี่ยวกับการกำหนด working directory ใน R สามารถศึกษาเพิ่มเติมได้จาก สิวะโชติ ศรีสุทธิยากร (2564)

รูปด้านล่างแสดงลักษณะของไฟล์ข้อมูล `mydata.csv` ที่เขียนออกจากโปรแกรม R ด้วยคำสั่งในข้างต้น จากรูปใช้โปรแกรม text editor เพื่อเปิดไฟล์ดังกล่าว

![ไฟล์ข้อมูล myCSV.csv](images/paste-8BAEF8C0.png){fig-align="left" width="300"}

โดยปกติแล้ว MS Excel หรือ Number หรือ googlesheet มีตัวอ่านไฟล์ข้อมูลประเภท flatfile อยู่แล้วผู้อ่านสามารถใช้โปรแกรมดังกล่าวเพื่อเปิดไฟล์ข้อมูลประเภท CSV หรือ flatfile ประเภทอื่น ๆ ได้โดยง่าย

#### ภาษา Python

สำหรับการนำเข้าและเขียนไฟล์ข้อมูลแบบ CSV ด้วยภาษา Python สามารถทำได้โดยใช้ฟังก์ชัน `pd.read_csv()` ของ pandas library ฟังก์ชันนี้มีพารามิเตอร์ได้แก่ `filepath` ใช้กำหนดที่อยู่และชื่อของไฟล์ที่ต้องการนำเข้า พารามิเตอร์ `sep` สำหรับระบุตัวอักษรที่ใช้เป็นตัวคั่นในชุดข้อมูล ซึ่งในกรณีนี้จะกำหนดให้ `sep=","` เพื่อนำเข้าชุดข้อมูลแบบ CSV พารามิเตอร์ `header` สำหรับระบุว่าแถวที่เท่าไหร่ในตารางข้อมูลจะใช้เป็นชื่อของตัวแปร (เริ่มจาก 0) พารามิเตอร์ `skiprows` ใช้กำหนดให้ Python อ่านไฟล์ข้อมูลโดยข้ามแถวไปจำนวนเท่ากับที่กำหนด พารามิเตอร์นี้มีประโยชน์มากสำหรับการนำเข้าไฟล์ข้อมูลจากองค์กร หรือ logfile ที่หัวของตารางมักมีคำอธิบายหรือ caption ต่าง ๆ ก่อนที่จะเป็นส่วนของตารางข้อมูล ฟังก์ชัน `pd.read_csv()` ยังมีพารามิเตอร์อีกหลายตัว (optional parameters) ที่สามารถกำหนดเพื่อปรับแต่งลักษณะของข้อมูลที่นำเข้ามาได้ รายละเอียดอื่น ๆ ผู้อ่านสามารถศึกษาเพิ่มเติมได้จาก <https://pandas.pydata.org/docs/reference/api/pandas.read_csv.html>

```{python}
# Python syntax
import pandas as pd
dat = pd.read_csv("/Users/siwachoat/Downloads/gapminder.csv", header=0)
dat
```

การเขียนไฟล์ CSV ด้วยภาษา Python สามารถทำได้หลายวิธี วิธีการหนึ่งคือการใช้ method `to_csv()` ซึ่งเป็น method หนึ่งภายใต้ pandas library พารามิเตอร์สำคัญของ method นี้ได้แก่ ตัวอย่างด้านล่างแสดงการเขียนไฟล์ข้อมูลใน Python เพื่อบันทึกลงใน folder ที่กำหนดไว้บนเครื่องคอมพิวเตอร์ สมมุติว่าผู้วิเคราะห์สร้างชุดข้อมูลใน Python เพื่อเก็บข้อมูลคะแนนสอบของนิสิตในรายวิชาแคลคูลัส (calculus) สถิติ (statistics) และคณิตศาสตร์ (math) การเขียนไฟล์ข้อมูลดังกล่าวเป็นไฟล์ CSV สามารถทำได้ดังนี้

```{python}
import pandas as pd
header = ["students","calculus","statistics","math"]
row_data = [[1,80,75,70],
            [2,40,55,60],
            [3,84,85,86],
            [4,51,38,43],
            [5,67,73,77]]
data = pd.DataFrame(row_data, columns=header)
data

data.to_csv("myCSV.csv", sep=",")
```

ผู้อ่านสามารถศึกษารายละเอียดของ `to_csv()` ได้จาก <https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.to_csv.html>

### **การนำเข้าและเขียนไฟล์แบบ TSV**

ดังที่กล่าวไปแล้วข้างต้น ไฟล์แบบ TSV เป็นไฟล์ข้อมูลแบบ flat file ที่มีการใช้ตัวคั่นข้อมูลเป็นเครื่องหมายเว้นวรรค (tab) การนำเข้าไฟล์ข้อมูล TSV การนำเข้าและเขียนไฟล์ลักษณะดังกล่าวของแต่ละภาษาจึงสามารถดำเนินการได้ในทำนองเดียวกับไฟล์แบบ CSV รายละเอียดมีดังนี้

#### ภาษา R

ในภาษา R สามารถทำได้โดยใช้ฟังก์ชัน `read.table()` โดยอาร์กิวเมนท์ของฟังก์ชันนี้มีส่วนของอาร์กิวเมนท์จำเป็นที่เหมือนกับของฟังก์ชัน `read.csv()` ได้แก่ `file` ที่ใช้ระบุที่อยู่และชื่อของไฟล์ข้อมูลที่ต้องการนำเข้า โดยจะต้องระบุในลักษณะของตัวแปรตัวอักษรใน R กล่าวคือต้องระบุภายใต้เครื่องหมาย quotation อาร์กิวเมนท์ `header` ที่กำหนดได้ 2 ค่าคือ `TRUE` และ `FALSE` โดยที่ค่าเริ่มต้นคือ `header=FALSE` ซึ่งหมายความว่าตารางข้อมูลที่จะนำเข้ามานั้นเป็นตารางที่ไม่มีหัวตาราง และอาร์กิวเมนท์ `sep` ใช้ระบุลักษณะของตัวคั่นข้อมูลที่ใช้ในไฟล์ข้อมูล อาร์กิวเมนท์นี้จึงทำให้ฟังก์ชัน `read.table()` สามารถนำเข้า flat file ได้หลายประเภทไม่ได้จำกัดแค่เฉพาะ CSV หรือ TSV เท่านั้น นอกจากนี้ยังมีอาร์กิวเมนท์ `skip` ที่ทำงานเหมือนกับพารามิเตอร์ `skiprows` ในฟังก์ชัน `pd.read_csv()` ของภาษา Python ฟังก์ชัน `read.table()` เป็นฟังก์ชันที่มีอาร์กิวเมนท์ที่สามารถกำหนดได้จำนวนมาก รายละเอียดอื่น ๆ เกี่ยวข้องผู้อ่านสามารถศึกษาได้จากคู่มือของฟังก์ชันโดยพิมพ์คำสั่ง `?read.table()`

จากที่กล่าวในข้างต้นจะเห็นว่า `read.table()` เป็นฟังก์ชันทั่วไปของ `read.csv()` ตัวอย่างต่อไปนี้แสดงให้เห็นว่าสามารถใช้ฟังก์ชัน `read.table()` เพื่อนำเข้าไฟล์แบบ CSV ได้

```{r}
dat <- read.table("/Users/siwachoat/Downloads/gapminder.csv", header=TRUE, sep=",")
head(dat)
```

ชุดข้อมูล [myTSV.txt](https://raw.githubusercontent.com/ssiwacho/dataset/main/myTSV.txt) เป็นชุดข้อมูลแบบ flat file ที่มีการใช้ตัวคั่นเป็นเครื่องหมายเว้นวรรค (tab) การนำชุดข้อมูลดังกล่าวเข้าสู่โปรแกรม R ด้วยฟังก์ชัน `read.table()` สามารถทำได้โดยกำหนดอาร์กิวเมนท์ `sep = " "` ดังตัวอย่างต่อไปนี้

```{r}
dat_TSV <- read.table("https://raw.githubusercontent.com/ssiwacho/dataset/main/myTSV.txt",
                      header = TRUE, sep = " ")
dat_TSV
```

ในทำนองเดียวกับการนำเข้าและเขียนไฟล์ CSV การเขียนไฟล์ TSV สามารถทำได้โดยใช้ฟังก์ชัน `write.table()` ที่มีอาร์กิวเมนท์สำคัญเหมือนกับฟังก์ชัน `write.csv()` ทุกประการ ความแตกต่างระหว่าง `write.table()` กับ `write.csv()` อันหนึ่งคือฟังก์ชัน `write.table()` มีอาร์กิวเมนท์ `sep` ที่ทำให้ผู้วิเคราะห์สามารถเลือกกำหนดได้ว่าจะเขียนไฟล์ข้อมูลของตนเองโดยใช้ตัวคั่นแบบใด ตัวอย่างต่อไปนี้แสดงการเขียนไฟล์ TSV ด้วยฟังก์ชัน `write.table()` จากชุดข้อมูลแบบ data.frame ที่สร้างเองบนโปรแกรม R

```{r}
#เพศของนักเรียน
gender <- c("M","M","F","F","F","M") 
#วิธีการสอนของครู
method <- c("LEC","LEC","LEC","PBL","PBL","PBL") 
# คะแนนสอบวิชา Eng
eng <- c(6, 5.5, 7, 7, 8, 8.5)

mydat<-data.frame(gender, method, eng)
mydat
```

ชุดคำสั่งข้างต้นเป็นการสร้างชุดข้อมูลแบบ data.frame ในโปรแกรม R ด้วยฟังก์ชัน `data.frame()` โดยเก็บชุดข้อมูลดังกล่าวเอาไว้ในตัวแปรชื่อ `mydat` การเขียนชุดข้อมูลนี้ออกไปบนเครื่องคอมพิวเตอร์เพื่อเก็บเป็นไฟล์ข้อมูลประเภท TSV สามารถดำเนินการได้ด้วยฟังก์ชัน `write.table()` ดังนี้

```{r}
write.table(mydat, file="mytsvfromR.txt", sep=" ")
```

รูปต่อไปนี้แสดงลักษณะของไฟล์ข้อมูล `mstsvformR.txt` ที่เขียนด้วยฟังก์ชัน `write.table()` ในข้างต้น จากรูปไฟล์ข้อมูลดังกล่าวเปิดด้วยโปรแกรม text editor

![ไฟล์ข้อมูล mytsvfromR.txt](images/paste-C00C266B.png){fig-align="left" width="250"}

#### ภาษา Python

สำหรับภาษา Python การนำเข้าและเขียนไฟล์ TSV รวมทั้ง flat file แบบอื่น ๆ สามารถทำได้ด้วยฟังก์ชัน `pd.read_csv()` โดยเปลี่ยนค่าของพารามิเตอร์ `sep` ให้ตรงกับตัวคั่นที่ใช้ในไฟล์ข้อมูล ยกตัวอย่างเช่น หากต้องการนำเข้าชุดข้อมูล [myTSV.txt](https://raw.githubusercontent.com/ssiwacho/dataset/main/myTSV.txt) สามารถดำเนินการได้ดังนี้

```{python}
dat_TSV = pd.read_csv("myTSV.txt",
                      header = 0, sep = " ")
dat_TSV
```

ในทำนองเดียวกันการเขียนไฟล์แบบ TSV ในภาษา Python สามารถทำได้ด้วยฟังก์ชัน `data.to_csv()` เหมือนกับที่ใช้เขียนไฟล์ CSV โดยเปลี่ยนตัวคั่นให้ตรงกับลักษณะไฟล์ที่ต้องการเขียนออกไปเก็บไว้บนคอมพิวเตอร์ ตัวอย่างต่อไปนี้แสดงการเขียนชุดข้อมูล `dat_TSV` ในตัวอย่างที่แล้วออกไปเป็นไฟล์ TSV บนเครื่องคอมพิวเตอร์

```{python}
dat_TSV.to_csv("Dataframe_to_TSV_python.txt", sep=" ")
```

## เรื่องที่ 4.1.3 การนำเข้าและเขียนข้อมูลประเภท spreadsheet

ไฟล์ข้อมูลประเภท spreadsheet เป็นไฟล์ที่มีการจัดเก็บข้อมูลในรูปแบบตารางซึ่งเป็นรูปแบบไฟล์ที่นิยมใช้ในโปรแกรมสำเร็จรูปสำหรับการคำนวณและจัดการข้อมูล เช่น Microsoft Excel, Number หรือ googlesheet หัวข้อนี้จะกล่าวถึงวิธีการนำเข้าและเขียนไฟล์ข้อมูลประเภทดังกล่าวรายละเอียดมีดังนี้

### การนำเข้าและเขียนไฟล์ข้อมูล .xlsx

ไฟล์ข้อมูล .xlsx เป็นไฟล์ข้อมูลของโปรแกรม Microsoft Excel (MS Excel) พื้นที่ภายในไฟล์ดังกล่าวเรียกว่า workbook โดยภายในแต่ละ workbook ประกอบด้วย worksheet ที่เป็นพื้นที่สำหรับจัดการข้อมูลและการคำนวณ worksheet ดังกล่าวมีลักษณะเป็นตาราง โดยภายในหนึ่ง workbook สามารถมีได้หลาย worksheet รูปต่อไปนี้แสดงตัวอย่าง workbook ของโปรแกรม MS Excel

#### ภาษา R

การนำเข้าไฟล์ข้อมูล .xlsx ในโปรแกรม R สามารถทำได้หลายวิธีการ วิธีการหนึ่งคือการใช้ฟังก์ชัน `read_excel()` ภายใต้ package-readxl ทั้งนี้ก่อนใช้งานฟังก์ชันดังกล่าวผู้วิเคราะห์ต้องดาวน์โหลดและติดตั้ง package ดังกล่าวโดยพิมพ์คำสั่งต่อไปนี้

```{r eval=F}
install.packages("readxl")
library(readxl)
```

```{r echo=F}
library(readxl)
```

ไฟล์ข้อมูล [`IQ.xlsx`](https://github.com/ssiwacho/dataset/blob/main/IQ.xlsx?raw=true) เป็นไฟล์ .xlsx ที่บันทึกข้อมูลคะแนนเชาว์ปัญญา (iq) ของนักเรียนจำแนกตามจังหวัด เพศ และอายุ เมื่อผู้วิเคราะห์ดาวน์โหลดไฟล์ข้อมูลดังกล่าวลงในคอมพิวเตอร์แล้ว สามารถนำเข้าไฟล์ข้อมูล `IQ.xlsx` ได้โดยพิมพ์คำสั่งดังนี้

```{r echo=F}
download.file(url = "https://github.com/ssiwacho/dataset/blob/main/IQ.xlsx?raw=true",
              destfile = "IQ.xlsx")
```

```{r}
iq <- read_excel("iq.xlsx")
iq
```

เนื่องจากภายในไฟล์ .xlsx อาจมี worksheet ได้มากกว่าหนึ่ง worksheet ในกรณีดังกล่าวการนำเข้าไฟล์ข้อมูลจึงต้องระบุเพิ่มเติมด้วยว่าผู้วิเคราะห์จะเลือกเอา worksheet ตัวไหนเข้าสู่ R พิจารณาไฟล์ข้อมูล [`Score.xlsx`](http://bit.ly/2EjFOnS) (สิวะโชติ ศรีสุทธิยากร, 2564) เมื่อดาวน์โหลดและเปิดไฟล์ข้อมูลนี้ในโปรแกรม MS Excel ผู้อ่านจะเห็นว่าไฟล์ข้อมูลดังกล่าวประกอบด้วย worksheet จำนวน 2 worksheet ได้แก่ "Score" และ "Score3" ในกรณีที่ผู้วิเคราะห์ใช้โปรแกรม R เป็นหลักสามารถเรียกดู worksheet ต่าง ๆ ในไฟล์ .xlsx ได้โดยใช้ฟังก์ชัน `excel_sheets()` ของ package readxl เช่นเดียวกัน ดังตัวอย่างต่อไปนี้

```{r}
excel_sheets("Score.xlsx")
```

จากไฟล์ข้อมูล `Score.xlsx` ข้างต้น หากผู้วิเคราะห์ต้องการนำเข้า worksheet "Score3" สามารถดำเนินการได้โดยใช้ฟังก์ชัน `read_excel()` เหมือนเดิม แต่จะต้องมีกำหนดอาร์กิวเมนท์ `sheet` เพื่อระบุว่าต้องการนำเข้า worksheet ใดของไฟล์ข้อมูล การระบุอาร์กิวเมนท์ `sheet` ดังกล่าวสามารถทำได้สองลักษณะ ลักษณะแรกคือการระบุเป็นชื่อของ worksheet โดยตรงในกรณีนี้คือ `sheet = "Score3"` และลักษณะที่สองระบุด้วยลำดับของ worksheet โดยในกรณีที่ต้องการ worksheet "Score3" ให้กำหนดเป็น `sheet = 2` ตัวอย่างต่อไปนี้แสดงการนำเข้าชุดข้อมูลใน worksheet "Score3" จากไฟล์ข้อมูล `Score.xlsx` ดังกล่าว

```{r}
score3 <- read_excel("Score.xlsx", sheet = "Score3")
head(score3)
```

**หมายเหตุ :** ตัวอย่างข้างต้นมีการใช้ฟังก์ชัน `head()` กับชุดข้อมูล `score3` ฟังก์ชันดังกล่าวมีหน้าที่กำหนดการแสดงผลของโปรแกรม R โดยจะแสดงชุดข้อมูล `score` เพียง 6 ค่าแรก ทั้งนี้เพื่อลดความวุ่นวายในหน้าต่างแสดงผล รายละเอียดของฟังก์ชัน `head()` นี้จะกล่าวถึงอีกครั้งหนึ่งในภายหลัง

จากผลลัพธ์ที่ได้ในตัวอย่างที่ผ่านมาผู้อ่านจะเห็นว่า การนำเข้าข้อมูลดังกล่าวยังไม่ถูกต้อง ทั้งนี้เป็นเพราะหากกลับไปดูที่ไฟล์ข้อมูลต้นฉบับผู้อ่านจะพบว่าชุดข้อมูลใน worksheet "Score3" ไม่ได้มีการกำหนดชื่อของคอลัมน์ไว้ เมื่อนำเข้าด้วยฟังก์ชัน `read_excel()` ดังในตัวอย่าง โปรแกรมจะนำข้อมูลในแถวแรกไปเป็นชื่อคอลัมน์โดยอัตโนมัติ ในกรณีเช่นนี้ผู้วิเคราะห์สามารถกำหนดอาร์กิวเมนท์ `col_names` เพิ่มเติม ค่าเริ่มต้นของฟังก์ชัน `read_excel()` กำหนดให้ `col_names = TRUE` ซึ่งหมายถึงฟังก์ชันจะกำหนดให้แถวแรกของชุดข้อมูลเป็นชื่อของตัวแปร ในทางกลับกันหากกำหนดให้ `col_names = FALSE` ฟังก์ชันจะ generate ชื่อของคอลัมน์ขึ้นมาต่างหาก ดังตัวอย่างต่อไปนี้

```{r}
score3 <- read_excel("Score.xlsx", sheet = "Score3", col_names = FALSE)
head(score3)
```

จากผลลัพธ์ข้างต้นจะเห็นว่า เมื่อกำหนดให้ `col_names = FALSE` ฟังก์ชัน `read_excel()` จะสร้างชื่อของแต่ละคอลัมน์ขึ้นมาให้เป็น `…1`, `…2`, ..., .`…5` ตามลำดับ ในกรณีที่ผู้วิเคราะห์ต้องการกำหนดชื่อของคอลัมน์เองสามารถกำหนดผ่านอาร์กิวเมนท์ `col_names` ดังกล่าวได้เลย โดยกำหนดในลักษณะเวกเตอร์ตัวอักษร (character vector) เช่นต้องการกำหนดให้คอลัมน์ทั้ง 5 ใน worksheet "Score3" เป็น `gender`, `attitude_pre`, `problem_solving`, `attitude_post`, `ach_score` สามารถเขียนคำสั่งได้ดังนี้

```{r}
score3 <- read_excel("Score.xlsx", sheet = "Score3", 
                     col_names = c("gender", "attitude_pre", 
                                   "problem_solving", "attitude_post", 
                                   "ach_score"))
score3
```

การเขียนไฟล์ข้อมูล .xlsx บน working directory ของ R สามารถทำได้หลายวิธีการ วิธีการหนึ่งคือการใช้ฟังก์ชัน `write.xlsx()` ของ package xlsx ในทำนองเดียวกับการใช้ฟังก์ชัน `read_excel()` ผู้วิเคราะห์จำเป็นต้องดาวน์โหลดและติดตั้ง package ดังกล่าวก่อนที่จะใช้งาน

```{r eval=F}
install.packages("xlsx")
library(xlsx)
```

```{r echo=F}
library(xlsx)
```

จากชุดข้อมูล `dat_TSV` ในหัวข้อ 4.1.2

```{r}
dat_TSV
```

สามารถเขียนชุดข้อมูลดังกล่าวเป็นไฟล์ .xlsx บน working directory ของ R ได้โดยพิมพ์คำสั่งต่อไปนี้

```{r}
write.xlsx(dat_TSV, file="dat_TSV.xlsx")
```

รูปต่อไปนี้แสดงไฟล์ `dat_TSV.xlsx` ที่เขียนด้วยฟังก์ชัน `write.xlsx()` ในข้างต้น

![](images/image-388606005.png){width="40%"}

#### ภาษา Python

ในทำนองเดียวกับ R ผู้วิเคราะห์สามารถเรียกดูชื่อของ worksheet ในไฟล์ .xlsx ได้ ซึ่งสามารถทำได้หลายวิธีการ วิธีการหนึ่งคือการใช้ฟังก์ชัน `ExcelFile()` ของ library pandas ดังนี้

```{python}
sheets = pd.ExcelFile("Score.xlsx")
sheets.sheet_names
```

ผลลัพธ์ข้างต้นแสดงให้เห็นว่าในไฟล์ `Score.xlsx` มี worksheet จำนวน 2 worksheet ได้แก่ `Scoore` และ `Score3` สมมุติว่าผู้วิเคราะห์ต้องการนำเข้าชุดข้อมูลใน worksheet `Score` สามารถเขียนคำสั่งเพิ่มได้ดังนี้

```{python}
score = sheets.parse(sheet_name = "Score")
score
```

ฟังก์ชัน `parse()` ที่ใช้นำเข้าข้อมูลข้างต้นมีพารามิเตอร์ที่สามารถใช้ควบคุมการทำงานอยู่หลายตัว จากตัวอย่างข้างต้นจะเห็นว่ามีพารามิเตอร์ `sheet_name` ที่ใช้สำหรับระบุ worksheet ที่ไฟล์ .xlsx ที่ต้องการนำเข้า นอกจากนี้ยังมีพารามิเตอร์ `header` ที่ใช้ระบุแถวของชื่อตัวแปรในแต่ละคอลัมน์ ค่าเริ่มต้นของพารามิเตอร์นี้คือ `header = 0` ซึ่งหมายความว่ากำหนดให้แถวแรกของชุดข้อมูลเป็นชื่อของตัวแปร นอกจากนี้ยังสามารถกำหนดชื่อของตัวแปรในแต่ละคอลัมน์ได้ผ่านพารามิเตอร์ `names` โดยกำหนดให้รูปแบบของ list ที่สมาชิกแต่ละตัวแปร string เป็นต้น

อีกวิธีการหนึ่งที่สามารถใช้เพื่อนำเข้าไฟล์ .xlsx ใน Python ได้คือการใช้ฟังก์ชัน `read_excel()` ใน library pandas ฟังก์ชันนี้มีพารามิเตอร์สำคัญคือ `io` ที่ใช้ระบุชื่อหรือที่อยู่ (url) ของไฟล์ .xlsx ที่ต้องการนำเข้าสู่ Python นอกจากนี้ยังมีพารามิเตอร์ `sheet_name`, `header`, `names` และพารามิเตอร์อื่น ๆ ที่เหมือนกับฟังก์ชัน `parse()`ในตัวอย่างข้างต้น รายละเอียดของพารามิเตอร์ต่าง ๆ ผู้อ่านสามารถศึกษาเพิ่มเติมได้จาก <https://pandas.pydata.org/docs/reference/api/pandas.read_excel.html>

ตัวอย่างต่อไปนี้แสดงการนำเข้าชุดข้อมูลจาก worksheet `Score3` ในไฟล์ `Score.xlsx` โดยใช้ฟังก์ชัน `read_excel()` ดังกล่าว เนื่องจากชุดข้อมูลใน worksheet นี้ไม่ได้มีการกำหนดชื่อของตัวแปรเอาไว้ในแถวแรกของชุดข้อมูล จึงมีการกำหนดพารามิเตอร์ `header = None` และกำหนดชื่อของตัวแปรในแต่ละคอลัมน์ของชุดข้อมูลผ่านพารามิเตอร์ `names` นอกจากนี้ เนื่องจากชุดข้อมูลใน worksheet `Score3` มีจำนวนค่อนข้างมาก จากตัวอย่างข้างต้นจึงมีการใช้ฟังก์ชัน `head()` เพื่อควบคุมจำนวนข้อมูลที่จะนำเสนอใน printout

```{python}
score3 = pd.read_excel("Score.xlsx",
                        sheet_name = "Score3",
                        header = None,
                        names = ['gender','att_pre','prob_sov', 'att_post','ach'])
score3.head(10)
```

การเขียนชุดข้อมูลใน Python ออกไปเป็นไฟล์ .xlsx สามารถทำได้โดยใช้ฟังก์ชัน `to_excel()` ซึ่งมีการใช้งานที่คล้ายกับกับฟังก์ชัน `to_csv()` อย่างไรก็ตามเนื่องจากไฟล์ .xlsx มีโครงสร้างการเก็บข้อมูลที่ซับซ้อนกว่าไฟล์ CSV หรือ flatfile อื่น ๆ ฟังก์ชันดังกล่าวจึงมีพารามิเตอร์เฉพาะสำหรับการเขียนไฟล์ .xlsx ด้วย ฟังก์ชัน `to_excel()` มีพารามิเตอร์ที่สำคัญได้แก่ (1) พารามิเตอร์ `excel_writer` ใช้ระบุที่อยู่และชื่อไฟล์ .xlsx ที่ต้องการเขียนออกไป (2) พารามิเตอร์ `sheet_name` ใช้กำหนดชื่อของ worksheet ภายในไฟล์ .xlsx ที่ต้องการเขียนออกไป (3) พารามิเตอร์ `na_rep` ใช้สำหรับระบุสัญลักษณะของข้อมูลสูญหาย (missing value representation) (4) พารามิเตอร์ `startrow` และ `startcol` ใช้สำหรับกำหนดขอบเขตของข้อมูลที่ต้องการเขียนออกไปในไฟล์ .xlsx นอกจากนี้ยังมีพารามิเตอร์อื่น ๆ อีกหลายตัว โดยผู้อ่านสามารถศึกษาได้จาก <https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.to_excel.html>

ตัวอย่างต่อไปนี้แสดงการใช้ฟังก์ชัน `to_excel()` เพื่อเขียนไฟล์ข้อมูลตัวอย่าง `exam_dat` ออกไปเป็นไฟล์ `exam_dat.xlsx`

```{python}
#เพศของนักเรียน
gender = ["M","M","F","F","F","M"]
#วิธีการสอนของครู
method = ["LEC","LEC","LEC","PBL","PBL","PBL"]
# คะแนนสอบวิชา Eng
eng = [6, 5.5, 7, 7, 8, 8.5]

dat = {'gender': gender,
      'method': method,
      'eng': eng}

exam_dat = pd.DataFrame(dat)
exam_dat
```

การเขียนชุดข้อมูล `exam_dat` ออกไปเป็นไฟล์ `exam_dat.xlsx` สามารถเขียนคำสั่งได้ดังนี้

```{python}
exam_dat.to_excel(excel_writer = 'exam_dat.xlsx' , sheet_name="exam_dat")
```

รูปต่อไปนี้แสดงไฟล์ `exam_dat.xlsx` ที่เขียนด้วยฟังก์ชัน `to_excel()` ในข้างต้น

![](images/image-978432785.png){width="40%"}

## เรื่องที่ 4.1.4 การนำเข้าและเขียนข้อมูลแบบ JSON

ชุดข้อมูลแบบ JSON (JavaScript Object Notation) เป็นชุดข้อมูลอีกประเภทหนึ่งที่ในปัจจุบันถูกใช้กันอย่างแพร่หลาย และมีความยืดหยุ่นในการทำงานมากกว่าชุดข้อมูลประเภท spreadsheet หรือ flat files โดยเฉพาะงานที่ต้องมีการส่งผ่าน แก้ไข หรือเพิ่มข้อมูลระหว่าง server ผ่าน Web APIs ซึ่งเป็นส่วนที่ใช้เชื่อมต่อการทำงานหรือประสานข้อมูลกันระหว่าง web server ต่าง ๆ ปัจจุบันมี Web APIs จำนวนมากที่เปิดให้ใช้งานเช่น Facebook, Line, Twitter หรือ IMDB เป็นต้น ผู้ที่ใช้ API ของ application ดังกล่าวสามารถเข้าถึงข้อมูล เช่น การโพสหรือการให้ความคิดเห็นต่าง ๆ ของผู้ใช้ ซึ่งปัจจุบันข้อมูลดังกล่าวถูกนำมาใช้เพื่อสร้างมูลค่าเพิ่มให้ข้อมูลอย่างแพร่หลาย เช่น การทำ social network, social listening หรือการทำ sentiment analysis เป็นต้น

เพื่อให้ผู้อ่านเข้าใจเกี่ยวกับ web API มากขึ้นลองพิจารณาตัวอย่างต่อไปนี้ สมมุติว่านักวิทยาการข้อมูลต้องการเข้าถึงข้อมูลภาพยนต์เรื่อง Captain Marvel จาก website IMDB (<https://www.imdb.com/title/tt4154664/>)

![Captain Marvel จาก IMDB](images/image-575661247.png)

ผู้อ่านจะเห็นว่าบนหน้า website ดังกล่าวมีข้อมูลเกี่ยวกับภาพยนต์จำนวนมาก อย่างไรก็ตามหากผู้วิเคราะห์ดำเนินการดาว์โหลดข้อมูลบน website ดังกล่าวโดยตรงพบว่าจะได้ข้อมูลเป็นไฟล์นามสกุล .html เมื่อเปิดดูพบว่าไฟล์ดังกล่าวมีส่วนของชุดคำสั่งที่ใช้กำหนดรูปแบบการแสดงผลบน web browser อยู่ด้วยซึ่งไม่เกี่ยวกับข้อมูลของภาพยนต์ หากผู้วิเคราะห์จะค้นหาข้อมูลที่ดังกล่าวด้วยสายตาก็จะเป็นการเสียเวลาอย่างมาก

รูปต่อไปนี้แสดงตัวอย่างไฟล์ `captain_marvel.html` ที่ดาวน์โหลดมาจาก website IMDB ข้างต้น

```{r eval=F}
url<-"https://www.imdb.com/title/tt4154664/"
download.file(url, "captain_marvel.html")
```

![ส่วนหนึ่งของไฟล์ captain_marvel.html](images/image-1000537317.png){fig-align="left" width="70%"}

จากสถานการณ์ข้างต้น มีวิธีการที่ง่ายและมีประสิทธิภาพสูงกว่าในการนำเข้าข้อมูลจาก website IMDB คือการใช้ web API เช่นในกรณีนี้อาจใช้ OMDb API ผู้อ่านจะเห็นว่าข้อมูลที่ดาวน์โหลดผ่าน API ดังกล่าวนั้นเป็นชุดข้อมูลแบบ JSON ที่มีโครงสร้างที่เป็นระเบียบ และง่ายกว่าข้อมูลภายในไฟล์ .html อย่างมาก ผู้อ่านลองพิจารณาไฟล์ข้อมูลด้านล่างจะเห็นว่าข้อมูลที่นำเข้าจาก API ดังกล่าวประกอบด้วย ชื่อเรื่อง ปีที่ฉาย ความยาวของภาพยนต์​ ประเภท ผู้กำกับ ผู้เขียนบท นักแสดง ไปจนถึงรางวัล และคะแนนที่ได้รับต่าง ๆ

```{r echo=F, eval=F}
library(jsonlite)
dat<-fromJSON("http://www.omdbapi.com/?i=tt4154664&apikey=d97bab1b")
toJSON(dat)
```

    {"Title":["Captain Marvel"],
    "Year":["2019"],
    "Rated":["PG-13"],
    "Released":["08 Mar 2019"],
    "Runtime":["123 min"],
    "Genre":["Action, Adventure, Sci-Fi"],
    "Director":["Anna Boden, Ryan Fleck"],
    "Writer":["Anna Boden, Ryan Fleck, Geneva Robertson-Dworet"],
    "Actors":["Brie Larson, Samuel L. Jackson, Ben Mendelsohn"],
    "Plot":["Carol Danvers becomes one of the universe's most powerful heroes when Earth is caught in the middle of a galactic war between two alien races."],
    "Language":["English"],
    "Country":["United States, Australia"],
    "Awards":["9 wins & 56 nominations"],
    "Poster":["https://m.media-amazon.com/images/M/MV5BMTE0YWFmOTMtYTU2ZS00ZTIxLWE3OTEtYTNiYzBkZjViZThiXkEyXkFqcGdeQXVyODMzMzQ4OTI@._V1_SX300.jpg"],
    "Ratings":[{"Source":"Internet Movie Database","Value":"6.8/10"},{"Source":"Rotten Tomatoes","Value":"79%"},{"Source":"Metacritic","Value":"64/100"}],
    "Metascore":["64"],
    "imdbRating":["6.8"],
    "imdbVotes":["559,100"],
    "imdbID":["tt4154664"],
    "Type":["movie"],
    "DVD":["28 May 2019"],
    "BoxOffice":["$426,829,839"],
    "Production":["N/A"],
    "Website":["N/A"],
    "Response":["True"]
    } 

จากตัวอย่างข้างต้นแสดงให้เห็นว่าเมื่อผู้วิเคราะห์ต้องไปทำงานที่เกี่ยวข้องกับข้อมูลบน website และมีการเรียกดูหรือดึงข้อมูลผ่าน web API ต่าง ๆ ผู้วิเคราะห์มักต้องทำงานร่วมกับชุดข้อมูลแบบ JSON เสมอ บทเรียนนี้จะกล่าวถึงการนำชุดข้อมูลแบบ JSON เข้าสู่ R และ Python รวมทั้งการแปลงชุดข้อมูลแบบ JSON เพื่อให้อยู่ในรูปตัวแปรมาตรฐานของภาษาทั้งสองและเหมาะที่จะนำไปดำเนินการต่อไปนี้

#### ภาษา R

มี package หลายตัวที่สามารถทำงานร่วมกับชุดข้อมูบแบบ JSON ได้ ในบทเรียนนี้จะกล่าวถึงการใช้ package-jsonlite โดยในทำนองเดียวกับการใช้งาน package อื่น ๆ ผู้วิเคราะห์จำเป็นต้องดาวน์โหลดและติดตั้ง package ดังกล่าวก่อนการใช้งานฟังก์ชันภายใน package โดยพิมพ์คำสั่งดังนี้

```{r eval=F}
install.packages("jsonlite")
library(jsonlite)
```

```{r echo=F}
library(jsonlite)
```

ฟังก์ชัน `fromJSON()` เป็นฟังก์ชันภายใต้ package-jsonlite ที่มีหน้าที่แปลงเวกเตอร์ตัวอักษร (character vector) ที่สร้างขึ้นตามโครงสร้างของ JSON ให้เป็นตัวแปรประเภทลิสท์ (list) ใน R ยกตัวอย่างเช่น ผู้วิเคราะห์มีชุดข้อมูลแบบ JSON ที่เป็น character vector ดังนี้

```{r}
student_json <- '
{"name": "บุญมี",
"gender": "ชาย",
"subject": "คณิตศาสตร์",
"score": 80
}'
```

ผู้วิเคราะห์สามารถแปลง `student_json` ให้เป็นตัวแปรแบบ list ใน R ได้ด้วยฟังก์ชัน `fromJSON()` ดังนี้

```{r}
student_list <- fromJSON(student_json)
student_list
```

ในกรณีที่ JSON ที่นำเข้าเป็นไฟล์ขนาดใหญ่ ผู้วิเคราะห์สามารถเรียกดูโครงสร้างการเก็บข้อมูลของ JSON ที่บันทึกในตัวแปร list ของ R โดยใช้ฟังก์ชัน `str()` ภายใต้ package-utils ดังตัวอย่างต่อไปนี้ (package-utils เป็น package เริ่มต้นที่ถูกติดตั้งมาพร้อมกับ R อยู่แล้วดังนั้นจึงไม่ต้องติดตั้งและดาวน์โหลดอีก)

```{r}
str(student_list)
```

ผลลัพธ์ข้างต้นแสดงให้เห็นว่าชุดข้อมูลประกอบด้วยข้อมูลของนักเรียน 4 ด้านได้แก่ ชื่อของนักเรียน เพศ รายวิชาที่ลงทะเบียนเรียน และคะแนนของรายวิชา ตามลำดับ

จากตัวอย่างข้อมูลภาพยนต์เรื่อง Captain Marvel ใน website IMDB ข้างต้น ผู้วิเคราะห์สามารถนำเข้าข้อมูลของภาพยนต์โดยใช้ OMDb API (<http://www.omdbapi.com/?i=tt3896198&apikey=d97bab1b>) เนื่องจาก API ดังกล่าวเป็น API ที่ไม่ต้องลงทะเบียนการใช้งานและผู้ใช้สามารถขอ api key ได้โดยที่ไม่ต้องลงทะเบียน ทำให้ผู้วิเคราะห์สามารถเข้าถึงชุดข้อมูลแบบ JSON ของภาพยนต์ผ่านลิงค์ในข้างต้นได้โดยตรง การนำเข้าไฟล์ข้อมูลดังกล่าวจึงสามารถทำได้โดยใช้ฟังก์ชัน `fromJSON()` ดังตัวอย่างต่อไปนี้

```{r}
library(jsonlite)
captain_mv<-fromJSON("http://www.omdbapi.com/?i=tt4154664&apikey=d97bab1b")
str(captain_mv)
```

จากการใช้คำสั่ง `str(captain_mv)` ข้างต้นจะเห็นว่าชุดข้อมูลแบบ JSON ที่นำเข้าด้วยฟังก์ชัน `fromJSON()` ถูกนำเข้าและแปลงให้อยู่ในรูปตัวแปรแบบ list โดยมีข้อมูลของตัวแปรทั้งหมด 25 ตัว

ในการทำงานจริงยังมี web API ที่จำเป็นต้องลงทะเบียนก่อนการใช้งานด้วย API ประเภทนี้ผู้วิเคราะห์จะไม่สามารถเข้าถึงและดาวน์โหลดข้อมูลได้โดยตรงเหมือนกับในตัวอย่าง website IMDB ในข้างต้น แต่จำเป็นต้องมีการใช้ access token หรือ api key เพื่อเป็นกุญแจหรือรหัสผ่านสำหรับดาวน์โหลดข้อมูลด้วย ตัวอย่างของ API ประเภทที่เช่น API ของ website [Open Government Data of Thailand](https://opendata.data.go.th)

![website Open Government Data of Thailand](images/image-321726953.png)

การใช้งาน API ของ Open Government Data of Thailand ผู้ใช้จำเป็นต้องลงทะเบียนเพื่อขอเข้าใช้งาน API ก่อน โดยเข้าไปที่เมนู "สำหรับนักพัฒนา" แล้วคลิกเลือก "สมัครเป็นผู้ใช้" จากนั้นทำตามขั้นตอนที่ website แนะนำ เมื่อดำเนินการเสร็จผู้ใช้จะได้รับ user token ที่จะใช้เป็นรหัสสำหรับการดาวน์โหลดข้อมูลผ่าน API ของ website

เมื่อได้รับ user token แล้วผู้วิเคราะห์สามารถเข้าสู่ website เพื่อดาวน์โหลดชุดข้อมูลที่ต้องการผ่าน API ได้ ยกตัวอย่างเช่น ผู้วิเคราะห์ต้องการนำเข้าชุดข้อมูลจำนวนนักเรียนพิการและด้อยโอกาส ปีการศึกษา 2565 เทอม 1 ของสำนักงานเขตพื้นที่การศึกษามัธยมศึกษา เขต 4 (<https://opendata.data.go.th/dataset/disable2565>) สามารถเขียนคำสั่งได้ดังนี้

```{r eval=F}
library(httr)
library(jsonlite)
headers ='api-key' = 'XXXXXXXXXXXXXXXXXXXXXXXXXX'

response <- VERB("POST", 
                 url = "https://opend.data.go.th/get-ckan/datastore_search?resource_id=cd232113-3350-43fb-a80d-34cd6263c780",   
                 add_headers(headers))
```

```{r echo=F}
library(httr)
library(jsonlite)
headers = c('api-key' = 'o2UXaDVRSxm4MIShatq3u4TD2i4C7JSW')

response <- VERB("GET", 
                 url = "https://opend.data.go.th/get-ckan/datastore_search?resource_id=cd232113-3350-43fb-a80d-34cd6263c780",   
                 add_headers(headers))
```

ตัวแปร `response` ในตัวอย่างคำสังข้างต้นเป็นตัวแปรแบบ list ที่ไม่ได้มีเฉพาะข้อมูลที่นำเข้า แต่ยังมีค่าพารามิเตอร์ต่าง ๆ ของ API ผู้วิเคราะห์สามารถเรียกดูส่วนที่เป็นข้อมูล JSON โดยใช้ฟังก์ชัน `content()` ดังนี้

```{r}
temp<-content(response)
str(temp,2)
```

เมื่อพิจารณาผลลัพธ์จากฟังก์ชัน `str(temp,2)` ข้างต้นจะเห็นว่าส่วนที่เก็บข้อมูลค่าสังเกตของชุดข้อมูล JSON ชุดนี้อยู่ภายใต้สมาชิกของ list ที่ชื่อ `result` และ sublist ที่ชื่อ `records` ทั้งนี้เมื่อเรียกดูโดยพิมพ์คำสั่ง `temp$result$records` จะพบว่าเป็นตัวแปรแบบ list ที่มีสมาชิกเป็น sublist จำนวน 100 ตัว (สามารถพิมพ์คำสั่ง `length(temp$result$records)` เพื่อเรียกดูจำนวนสมาชิกภายใน list ได้) และเมื่อพิจารณาสมาชิกแต่ละตัวภายใน list ดังกล่าวจะพบว่าเป็นข้อมูลของแต่ละ record ซึ่งเราสามารถใช้ฟังก์ชัน `bind_rows()` ของ package-dplyr เพื่อยุบรวมสมาชิกท้ัง 100 ตัวภายใน list ดังกล่าวให้อยู่ในรูปของตารางแบบ dataframe ดังตัวอย่างต่อไปนี้

```{r}
library(dplyr)
dat <- bind_rows(temp$result$records)
head(dat)
```

#### ภาษา Python

สำหรับภาษา Python การนำเข้าข้อมูลผ่าน web API ที่ไม่ต้องลงทะเบียนดังในตัวอย่าง website IMDB ข้างต้นสามารถดำเนินการได้ในทำนองเดียวกับภาษา R โดยมี library ที่เกี่ยวข้องสองตัวได้แก่ library requests ใช้สำหรับดาวน์โหลดชุดข้อมูลจาก web API และ library json ใช้สำหรับดำเนินการกับชุดข้อมูลแบบ JSON ดังตัวอย่างต่อไปนี้

```{python}
import requests
import json
url = "http://www.omdbapi.com/?i=tt4154664&apikey=d97bab1b"
response = requests.get(url)
dat = json.loads(response.text)
dat
dat
```

นอกจากฟังก์ชัน `fromJSON()` แล้ว package-jsonlite ยังมีฟังก์ชันที่จำเป็นต้องการทำงานร่วมกับชุดข้อมูล JSON อีกหลายตัว เช่น `toJSON()` ใช้สำหรับสร้างไฟล์ข้อมูลแบบ JSON จากชุดข้อมูลของ R ฟังก์ชัน `prettify()` และ `minify()` ที่ใช้ปรับเปลี่ยนรูปแบบการนำเสนอของไฟล์ข้อมูล JSON
