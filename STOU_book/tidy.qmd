# ตอนที่ 4.2 การจัดระเบียบข้อมูล (tidying data) {.unnumbered}

</br>

ชุดข้อมูล (data set) มีลักษณะเป็นตารางที่ประกอบด้วยมิติด้านคอลัมน์ (column) และแถว (row) ใช้เก็บข้อมูลของตัวแปรต่าง ๆ ข้อมูลที่ถูกจัดเก็บอยู่ในตารางดังกล่าวเป็นไปได้ทั้งข้อมูลเชิงปริมาณที่มีค่าเป็นตัวเลข ข้อมูลเชิงคุณลักษณะที่ไม่ใช่ตัวเลข การออกแบบตารางสำหรับจัดเก็บข้อมูลนั้นสามารถทำได้หลากหลายลักษณะ พิจารณาชุดข้อมูลในตาราง 1 และ 2 ด้านล่างจะเห็นว่าถึงแม้จะเป็นเป็นชุดข้อมูลที่จัดเก็บข้อมูลเดียวกัน แต่ก็สามารถที่จะมีรูปแบบการจัดเก็บที่แตกต่างกันได้

**ตาราง 4.1** : คะแนนสอบวิชาคณิตศาสตร์และภาษาอังกฤษของนักเรียน (รูปแบบที่ 1)

```{r echo=F, message=F}
library(kableExtra)
library(dplyr)
student<-c("บุญมา","บุญมี","บุญเติม","บุญหนัก")
score_math<-c(10,NA,15,4)
score_eng<-c(2,20,20,5)
dat<-data.frame(student, score_math, score_eng)
kable(dat, col.names = c("นักเรียน","คะแนนวิชาคณิตศาสตร์" ,"คะแนนวิชาวิทยาศาสตร์"))%>%
  kable_classic_2(full_width = F, latex_options="hold_position", position="left",
                  font_size=15)
```

**ตาราง 4.2** : คะแนนสอบวิชาคณิตศาสตร์และภาษาอังกฤษของนักเรียน (รูปแบบที่ 2)

```{r echo=F, message=F}
library(kableExtra)
library(dplyr)
library(tidyr)
student<-c("บุญมา","บุญมี","บุญเติม","บุญหนัก")
score_math<-c(10,NA,15,4)
score_eng<-c(2,20,20,5)
dat<-data.frame(student, score_math, score_eng)
dat<-dat%>%pivot_longer(cols=c("score_math","score_eng"),
                        names_to="subject",
                        values_to="score")
dat$subject<-factor(dat$subject, levels=c("score_math", "score_eng"),
                    labels=c("คณิตศาสตร์","ภาษาอังกฤษ"))
kable(dat, col.names = c("นักเรียน","รายวิชา" ,"คะแนน"))%>%
  kable_classic_2(full_width = F, html_font="Sarabun", position="left",
                  font_size=15)
```

</br>

อย่างไรก็ตามการจัดเก็บข้อมูลในชุดข้อมูลในรูปแบบที่เหมาะสมกับการดำเนินการวิเคราะห์ข้อมูล หรือการสร้างทัศนภาพข้อมูลจะช่วยให้การวิเคราะห์ข้อมูลตามวัตถุประสงค์ต่าง ๆ สามารถทำได้ง่ายและมีประสิทธิภาพ ในทางกลับกันการจัดเก็บข้อมูลในรูปแบบที่ไม่เหมาะสมจะเป็นอุปสรรคในการวิเคราะห์ข้อมูล นอกจากนี้ยังอาจเป็นปัจจัยที่ก่อให้เกิดความผิดพลาดในผลการวิเคราะห์อีกด้วย รูปแบบของชุดข้อมูลที่เหมาะสมและสนับสนุนให้การวิเคราะห์ข้อมูลสามารถดำเนินไปได้อย่างมีประสิทธิภาพเรียกว่า **ชุดข้อมูลจัดระเบียบ (tidy data)**

ชุดข้อมูลจัดระเบียบเป็นตารางข้อมูลที่มีลักษณะสำคัญของรูปแบบการจัดเก็บข้อมูล 3 ประการ (สิวะโชติ ศรีสุทธิยากร, 2564; Wickham, 2014) ดังนี้

1.  มิติด้านคอลัมน์ (column) ของชุดข้อมูล เป็นมิติของตัวแปร โดยที่แต่ละคอลมน์จะใช้เก็บข้อมูลตัวแปรได้เพียงคอลัมน์ละหนึ่งตัวแปรเท่านั้น
2.  มิติด้านแถว (row) ของชุดข้อมูล เป็นมิติของหน่วยข้อมูล โดยที่แต่ละแถวจะใช้เก็บข้อมูลของหน่วยข้อมูลได้เพียงแถวละหนึ่งหน่วยข้อมูลเท่านั้น
3.  ภายในแต่ละเซลล์ (cell) ของชุดข้อมูล จะใช้เก็บข้อมูลค่าสังเกตได้เพียงค่าเดียวเท่านั้น

รูป 4.1 แสดงตัวอย่างของชุดข้อมูลจัดระเบียบที่มีคุณลักษณะข้างต้น สังเกตว่าหัวตาราง (แถวแรกของตาราง) จะเป็นส่วนที่ใช้ระบุชื่อของตัวแปรในแต่ละคอลัมน์ อย่างไรก็ตามในสถานการณ์จริงชุดข้อมูลส่วนใหญ่มักมีลักษณะที่ละเมิดเงื่อนไขของชุดข้อมูลจัดระเบียบข้างต้นอย่างน้อยหนึ่งข้อ การจัดระเบียบชุดข้อมูลจึงเป็นขั้นตอนที่มีความสำคัญภายใต้การดำเนินงานทางด้านวิทยาการข้อมูล เนื้อหาในตอนที่ 4.1 นี้จึงจะกล่าวถึง การสำรวจลักษณะของชุดข้อมูล เพื่อวิเคราะห์สภาพและระบุปัญหาความไม่เป็นระเบียบของชุดข้อมูล (ถ้ามี) จากนั้นจะกล่าวถึงวิธีการที่เกี่ยวข้องสำหรับแก้ปัญหาดังกล่าว รายละเอียดมีดังนี้

![รูป 4.1 ตัวอย่างข้อมูลจัดระเบียบ](tidydata.png){fig-alt="ที่มา : ดัดแปลงจาก สิวะโชติ ศรีสุทธิยากร (2564)" fig-align="left" width="70%"}

ที่มา : ดัดแปลงจาก สิวะโชติ ศรีสุทธิยากร (2564)

</br>

## เรื่องที่ 4.2.1 การสำรวจลักษณะของชุดข้อมูล

ในหัวข้อนี้จะใช้ชุดข้อมูล `gapminder` (Bryan, 2017) ที่ประกอบด้วยข้อมูลเกี่ยวกับจำนวนประชากร (pop) ผลิตภัณฑ์มวลรวมในประเทศต่อหัว (gdpPercap) และอายุขัยเฉลี่ยของประชากร (lifeExp) ของประเทศต่าง ๆ เป็นตัวอย่างประกอบการอธิบาย เมื่อผู้วิเคราะห์นำข้อมูล `gapminder` เข้าสู่โปรแกรมแล้วเรียกดูชุดข้อมูลจะได้ผลลัพธ์ที่มีลักษณะดังนี้

```{r echo=F}
library(gapminder)
gapminder%>%data.frame()%>%head(10)
```

```{r echo=F}
gapminder%>%data.frame()%>%tail(10)
```

ผลลัพธ์ข้างต้นจะเห็นว่าชุดข้อมูล `gapminder` ประกอบด้วยตัวแปรทั้งหมด 6 ตัว ได้แก่ ประเทศ (country) ทวีป (continent) ปี (year) อายุขัยเฉลี่ยของประชากร (lifeExp) จำนวนประชากร (pop) และผลิตภัณฑ์มวลรวมต่อหัวภายในประเทศ (gdpPercap) ผู้อ่านจะสังเกตเห็นว่าการเรียนดูข้อมูลทั้งชุดขึ้นมาโดยตรงดังตัวอย่างข้างต้นเป็นวิธีการที่ไม่มีประสิทธิภาพในการสำรวจข้อมูล ทั้งนี้เป็นเพราะในสถานการณ์ที่ข้อมูลมีจำนวนมาก วิธีการดังกล่าวจะให้รายละเอียดของชุดข้อมูลที่มากเกินไปโดยไม่จำเป็น นอกจากนี้ยังมีโอกาสสูงที่จะเกิดปัญหาข้อมูลล้นหน้าจอแสดงผล จนผู้วิเคราะห์ไม่สามารถทราบสภาพของชุดข้อมูลดังกล่าวได้อย่างสะดวก

ในทางปฏิบัติการสำรวจชุดข้อมูลต่าง ๆ ผู้วิเคราะห์จะไม่ได้เรียกดูหรือสำรวจชุดข้อมูลทั้งหมดโดยตรง แต่จะใช้ module ของโปรแกรมวิเคราะห์ข้อมูลช่วยในการสำรวจ module ดังกล่าวจะทำหน้าที่สรุปสารสนเทศที่จำเป็นสำหรับการทำความเข้าใจสภาพของชุดข้อมูลดังกล่าว ได้แก่ การเรียกดูรายการและสถานะของตัวแปรในชุดข้อมูล และการเรียกดูส่วนหัวและส่วนท้ายของชุดข้อมูล รายละเอียดมีดังนี้

### **การเรียกดูรายการและสถานะของตัวแปร**

วิธีการเรียกดูผลลัพธ์ส่วนนี้จะแตกต่างกันไปขึ้นอยู่กับผู้วิเคราะห์ว่าใช้โปรแกรมใด เช่น ในกรณีที่ใช้ภาษา R อาจเลือกใช้ฟังก์ชัน `str()` หรือ `glimpse()` หรือในกรณีที่ใช้ภาษา Python อาจเลือก method `info()` ภายใต้ pandas library เป็นต้น ผลการวิเคราะห์ด้านล่างแสดงผลลัพธ์ในภาษา R และ Python ดังกล่าว

```{r}
# R syntax
library(dplyr)
glimpse(gapminder)
```

```{python eval=F}
# Python syntax
import pandas
gapminder.info()
```

```{python echo=F}
import pandas
r.gapminder.info()
```

เมื่อพิจารณาผลลัพธ์จากภาษา R ข้างต้นแสดงให้เห็นว่าในชุดข้อมูล `gapminder` ประกอบด้วยข้อมูลจำนวน 1,704 หน่วย และมีจำนวน 6 คอลัมน์ โดยมีการรายงานชื่อของตัวแปรในแต่ละคอลัมน์ พร้อมทั้งระบุสถานะของตัวแปรดังกล่าว เช่น ตัวแปร `country` มีสถานะเป็นตัวแปรประเภทปัจจัย (`fct`) หรือตัวแปร `year` มีสถานะเป็นตัวแปรตัวเลขจำนวนเต็ม (`int`) หรือตัวแปร `gdrPercap` มีสถานะเป็นตัวแปรประเภทจำนวนจริง (`dbl`) เป็นต้น ผลลัพธ์นี้ช่วยให้ผู้วิเคราะห์ทราบว่าการนำเข้าข้อมูลดังกล่าว นำเข้ามาอย่างถูกต้องหรือไม่ หากมีตัวแปรใดที่ถูกจัดเก็บอยู่ในสถานะที่ไม่เหมาะสม ผู้วิเคราะห์ก็สามารถดำเนินการแก้ไขปรับเปลี่ยนให้เหมาะสมได้ และเมื่อพิจารณาผลลัพธ์จากภาษา Python พบว่าให้สารสนเทศในลักษณะเดียวกับภาษา R

### **การเรียกดูส่วนหัวและส่วนท้ายของชุดข้อมูล**

วิธีการนี้เป็นวิธีการง่าย ๆ ที่ช่วยให้ผู้วิเคราะห์ทำความเข้าใจโครงสร้างของตารางข้อมูล ขอบเขตของตัวแปร รวมทั้งลักษณะของค่าสังเกตบางส่วนที่จัดเก็บอยู่ในชุดข้อมูล การดำเนินการส่วนนี้ด้วยภาษา R สามารถทำได้โดยใช้ฟังก์ชัน `head()` และ `tail()` ดังนี้

```{r}
# R syntax
head(gapminder)
```

```{r}
# R syntax
tail(gapminder)
```

ส่วนภาษา Python สามารถทำได้โดยใช้ method `head()` และ `tail()` ของ pandas libary ดังนี้

```{python eval=F}
# Python syntax
gapminder.head()
```

```{python echo=F}
import pandas
r.gapminder.head()
```

```{python eval=F}
# Python syntax
gapminder.tail()
```

```{python echo=F}
r.gapminder.tail()
```

ในทางปฏิบัติผลการวิเคราะห์ด้วยวิธีการข้างต้นเพียงพอสำหรับผู้วิเคราะห์ที่จะใช้พิจารณาว่าโครงสร้างการจัดเก็บข้อมูลในชุดข้อมูลที่นำเข้ามามีลักษณะเป็นชุดข้อมูลจัดระเบียบที่เหมาะสำหรับการนำไปวิเคราะห์ข้อมูลตามวัตถุประสงค์แล้วหรือไม่ หากยังไม่เหมาะสมผู้วิเคราะห์จำเป็นต้องแก้ปัญหาในเชิงของโครงสร้างชุดข้อมูลดังกล่าวก่อนที่จะดำเนินการในขั้นตอนต่อไป หัวข้อถัดไปจะกล่าวถึงเครื่องมือหรือวิธีการพื้นฐานที่จำเป็นสำหรับปรับเปลี่ยนลักษณะของชุดข้อมูลให้ตรงกับความต้องการ

## เรื่องที่ 4.2.2 การปรับเปลี่ยนลักษณะของชุดข้อมูล (reshaping data)

ชุดข้อมูลที่ยังไม่เป็นระเบียบมีหลากหลายลักษณะ และโดยมากมักพบเมื่อผู้วิเคราะห์ได้ข้อมูลมาจากแหล่งข้อมูลทุติยภูมิ เช่น ฐานข้อมูล หรือแหล่ง open data ต่าง ๆ หัวข้อนี้จะกล่าวถึงปัญหาข้อมูลไม่เป็นระเบียบที่มักพบและวิธีการแก้ปัญหาดังกล่าว รายละเอียดมีดังนี้

### การปรับเปลี่ยนรูปแบบชุดข้อมูลระหว่างชุดข้อมูลแบบกว้างกับชุดข้อมูลแบบยาว

ชุดข้อมูลอาจจำแนกได้เป็น 2 ลักษณะ ได้แก่ ชุดข้อมูลแบบกว้าง (wide format) และชุดข้อมูลแบบยาว (long format) รายละเอียดมีดังนี้

1.  **ชุดข้อมูลแบบกว้าง** เป็นชุดข้อมูลที่มีการกระจายค่าสังเกตของตัวแปรสำคัญขึ้นไปอยู่บนคอลัมน์ ดังตัวอย่างชุดข้อมูล `onet.xlsx` ในตาราง 3 โดยส่วนใหญ่ตารางลักษณะนี้เหมาะสำหรับการนำเสนอข้อมูล หรือนำไปใช้สำหรับสร้างทัศนภาพข้อมูลในบางกรณี แต่มักไม่เหมาะที่จะนำไปเข้าสู่โมเดลวิเคราะห์ข้อมูลต่าง ๆ
2.  **ชุดข้อมูลแบบยาว** เป็นชุดข้อมูลที่มีลักษณะเป็นไปตามเงื่อนไขของชุดข้อมูลจัดระเบียบ โดยมิติด้านคอลัมน์ใช้เก็บข้อมูลของตัวแปรแต่ละตัว ส่วนมิติด้านแถวใช้เก็บข้อมูลของหน่วยข้อมูล ชุดข้อมูล `gapminder` ข้างต้นเป็นตัวอย่างของชุดข้อมูลแบบยาว ชุดข้อมูลแบบยาวเป็นรูปแบบปกติที่มักพบในฐานข้อมูลแบบ SQL ทั่วไป

**ตาราง 4.3** : (ตัวอย่างชุดข้อมูลแบบกว้าง) จำนวนนักเรียนจำแนกตามรายวิชาและช่วงคะแนนผลการสอบ O-NET ระดับชั้น ม.6 ปีการศึกษา 2560

```{r echo=F}
library(readxl)
dat<-read_excel("/Users/siwachoat/Library/CloudStorage/OneDrive-ChulalongkornUniversity/Documents/บริการวิชาการ/chapterbook มสธ./chapter/chapter/datasets/คะแนน onet2.xlsx")
kable(dat, col.names=c("วิชา",
                       "< 10 คะแนน",
                       "10-20",
                       "20-30",
                       "30-40",
                       "40-50",
                       "50-60",
                       "60-70",
                       "70-80",
                       "80-90",
                       "90-100"))%>%
  kable_classic_2(full_width = T, html_font="Sarabun", position="left",
                  font_size=14)%>%
  add_header_above(c(" " =1, "ช่วงคะแนนผลสอบ O-NET" =10))
```

ในทางปฏิบัติผู้วิเคราะห์มีโอกาสพบชุดข้อมูลทั้งสองลักษณะ การปรับเปลี่ยนรูปแบบของชุดข้อมูลดังกล่าว จากชุดข้อมูลแบบกว้างให้เป็นแบบยาว และจากให้อยู่ในรูปแบบยาวให้เป็นรูปแบบกว้าง จึงเป็นทักษะพื้นฐานที่จำเป็นสำหรับนักวิทยาการข้อมูล ในทำนองเดียวกับการสำรวจโครงสร้างชุดข้อมูล วิธีการปรับเปลี่ยนรูปแบบตารางข้อมูลมีความแตกต่างกันขึ้นอยู่กับโปรแกรมวิเคราะห์ข้อมูลที่เลือกใช้

ในกรณีที่ใช้ภาษา R ผู้วิเคราะห์สามารถดำเนินการได้หลายแบบ วิธีการหนึ่งที่สามารถทำได้สะดวกคือการใช้เครื่องมือใน package-tidyr พิจารณาชุดข้อมูล `จำนวนผู้สำเร็จการศึกษา.xlsx` ที่จัดเก็บอยู่ในชุดข้อมูล `wide_data` ด้านล่าง จะเห็นว่าเป็นชุดข้อมูลรูปแบบกว้างที่แสดงจำนวนผู้สำเร็จการศึกษาในระดับ ปวช. และ ปวส. จำแนกตามสาขาวิชา

```{r echo=F}
# R syntax
wide_data<-read_excel("/Users/siwachoat/Library/CloudStorage/OneDrive-ChulalongkornUniversity/Documents/บริการวิชาการ/chapterbook มสธ./chapter/chapter/datasets/จำนวนผู้สำเร็จการศึกษา.xlsx")
wide_data
```

หากผู้วิเคราะห์ต้องการปรับรูปแบบของชุดข้อมูล `wide_data` ข้างต้นให้เป็นชุดข้อมูลแบบยาว สามารถทำได้โดยใช้ฟังก์ชัน `pivot_longer()` โดยกำหนดอารกิวเมนท์ `data` เพื่อระบุชุดข้อมูลที่ต้องการปรับให้เป็นรูปแบบยาว `cols` เพื่อกำหนดคอลัมน์ในชุดข้อมูลแบบกว้างที่จะยุบรวมไว้ภายในคอลัมน์เดียวกัน `names_to` ใช้กำหนดชื่อคอลัมน์ใหม่สำหรับบรรจุคอลัมน์ที่ยุบรวมมาจากชุดข้อมูลแบบกว้างเดิม และ `values_to` ใช้กำหนดชื่อคอลัมน์สำหรับจัดเก็บค่าสังเกตที่อยู่ภายใต้คอลัมน์ที่ยุบรวมมา ตัวอย่างด้านล่างแสดงการปรับรูปแบบของชุดข้อมูล `จำนวนผู้สำเร็จการศึกษา.xlsx` ที่จัดเก็บอยู่ในชุดข้อมูล `wide_data` ให้เป็นชุดข้อมูลแบบยาว

```{r echo=T}
# R syntax
long_data<-pivot_longer(data=wide_data, 
                        cols=2:4, 
                        names_to = "category", 
                        values_to = "number")
long_data%>%data.frame()
```

ในทางกลับกันหากมีชุดข้อมูลแบบยาว และผู้วิเคราะห์ต้องการปรับเปลี่ยนให้เป็นชุดข้อมูลแบบกว้างสามารถทำได้ด้วยฟังก์ชัน `pivot_wider()` ฟังก์ชันนี้มีอาร์กิวเมนท์จำเป็นที่จะต้องระบุ 3 ตัวได้แก่ `data` เพื่อระบุชุดข้อมูลที่ต้องการปรับให้เป็นรูปแบบกว้าง `names_from` เพื่อระบุว่าจะนำค่าสังเกตจากคอลัมน์ใดขยายไปเป็นหัวคอลัมน์ของตารางใหม่ และ `values_from` ใช้ระบุว่าจะเอาข้อมูล/ค่าสังเกตจากคอลัมน์ใดไปอยู่ภายใต้คอลัมน์ใหม่ที่ขยายจากการระบุใน `names_from` ตัวอย่างด้านล่างแสดงการเปลี่ยนชุดข้อมูล `long_data` ในข้างต้นให้กลับเป็นชุดข้อมูลแบบกว้างเหมือนเดิม

```{r echo=T}
# R syntax
pivot_wider(data = long_data,
            names_from = "category",
            values_from = "number")
```

ถ้าผู้วิเคราะห์ต้องการศึกษารายละเอียดเพิ่มเติมเกี่ยวกับฟังก์ชันต่าง ๆ ของโปรแกรม R สามารถเรียกดูคู่มือของฟังก์ชันดังกล่าวได้โดยใช้คำสั่ง `?XXX` หรือ `help(XXX)` เช่น หากต้องการรายละเอียดของฟังก์ชัน `pivot_longer()` ให้พิมพ์คำสั่ง `?pivot_longer()` หรือ `help(pivot_longer()` เป็นต้น

ในกรณีที่ใช้ภาษา Python การปรับเปลี่ยนชุดข้อมูลแบบกว้างให้เป็นแบบยาวสามารถทำได้โดยใช้ฟังก์ชัน `melt()` ภายใต้ pandas library ฟังก์ชัน `melt()` มีพารามิเตอร์ควบคุมการทำงานของฟังก์ชันที่สำคัญ 3 ตัวได้แก่ `frame` ใช้ระบุชุดข้อมูล (pandas.DataFrame) ที่ต้องการดำเนินงาน `id_vars` ใช้ระบุคอลัมน์หรือตัวแปรที่เป็น id ของหน่วยข้อมูล และ `value_vars` ทำงานเหมือนกับอาร์กิวเมนท์ `names_to` ของ `pivot_longer()` ในโปรแกรม R ตัวอย่างด้านล่างแสดงการปรับรูปแบบชุดข้อมูล `จำนวนผู้สำเร็จการศึกษา.xlsx` ที่เป็นชุดข้อมูลแบบกว้างให้เป็นชุดข้อมูลแบบยาวด้วยฟังก์ชันดังกล่าว โดยในตัวอย่างชุดข้อมูลดังกล่าวจัดเก็บอยู่ในตัวแปรชื่อ `wide_data`

```{python echo=F}
wide_data = r.wide_data
```

```{python echo=T}
# Python syntax
import pandas as pd
long_data = pd.melt(frame = wide_data, 
                    id_vars=['สาขาวิชา'],
                    value_vars=['รวม','ปวช.', 'ปวส.'])
long_data
```

ใน Python ผู้อ่านสามารถเรียกดูรายละเอียดของฟังก์ชันที่ต้องการใช้งานโดยพิมพ์คำส่ง `?XXX` หรือ `help(XXXX)` เหมือนกับภาษา R เช่นในกรณีนี้ต้องการรายละเอียดการใช้งานฟังก์ชัน `melt()`ให้พิมพ์คำสั่ง `help(pd.melt)`

ในทางกลับกันหากต้องการปรับเปลี่ยนรูปแบบของตารางแบบยาวให้เป็นแบบกว้างสามารถทำได้ด้วยฟังก์ชัน `pivot()` ดังตัวอย่างต่อไปนี้

```{python}
pd.pivot(data= long_data, 
                    index=['สาขาวิชา'],
                    columns=['variable'],
                    values=['value'])
```

อีกวิธีการหนึ่งในการปรับรูปแบบตารางระหว่างตารางรูปแบบกว้างกับยาวด้วยภาษา Python คือการใช้ library datar ที่เป็น API ของ package-dplyr และ tidyr ที่ใช้จัดกระทำและจัดระเบียบชุดข้อมูลใน R กล่าวคือ ผู้วิเคราะห์สามารถใช้ฟังก์ชัน `pivot_longer()` และ `pivot_wider()` รวมทั้งฟังก์ชันอื่น ๆ ที่เกี่ยวข้องใน Python ได้เหมือนกับที่ดำเนินการในภาษา R ก่อนการใช้งาน library ผู้วิเคราะห์จำเป็นต้องดาวน์โหลดและติดตั้ง library ลงในเครื่องก่อน โดยภายในหน้าต่าง terminal ให้พิมพ์คำสั่ง `pip install -U datar` รายละเอียดเพิ่มเติมสามารถศึกษาได้จาก <https://github.com/pwwang/datar>

### การแยกคอลัมน์

ในบางกรณีชุดข้อมูลที่นำใช้ในการวิเคราะห์อาจมีบางคอลัมน์ที่จัดเก็บค่าสังเกตของหลายตัวแปรอยู่ภายในเซลล์เดียวกัน ดังตัวอย่างในตาราง 4 (ดาวน์โหลดได้จาก [คะแนนเชาวน์ปัญญาของนักเรียน.xlsx (สิวะโชติ ศรีสุทธิยากร, 2564)](https://bit.ly/38T1ENa)) จากตารางจะเห็นว่าคอลัมน์ที่ 3 (`gender.age`) เป็นคอลัมน์ที่จัดเก็บค่าสังเกตของตัวแปรจำนวน 2 ตัวร่วมกัน ได้แก่ เพศ และ อายุ ของนักเรียน ซึ่งละเมิดเงื่อนไขของชุดข้อมูลจัดระเบียบ การแก้ปัญหาจึงจำเป็นต้องแยกค่าสังเกตในคอลัมน์ดังกล่าวออกจากกันให้เป็น 2 คอลัมน์ได้แก่ คอลัมน์ของเพศ และอายุ ตามลำดับ

**ตาราง 4.4** คะแนนเชาว์ปัญญาของนักเรียน

```{r echo=F}
iq <- read_excel("/Users/siwachoat/Library/CloudStorage/OneDrive-ChulalongkornUniversity/Documents/บริการวิชาการ/chapterbook มสธ./chapter/chapter/datasets/IQ.xlsx")
kbl(iq)%>%
   kable_classic_2(full_width = T, html_font="Sarabun", position="left",
                  font_size=14)
  
```

[ที่มา: สิวะโชติ ศรีสุทธิยากร (2564)]{.smallcaps}

การแยกคอลัมน์ในชุดข้อมูลดังกล่าวด้วยภาษา R สามารถทำได้หลายวิธีการ ใน package-tidyr มีฟังก์ชัน `seperate()` ที่สามารถใช้ดำเนินการดังกล่าวได้ ฟังก์ชัน `separate()` มีอาร์กิวเมนท์สำคัญจำนวน 4 ตัวได้แก่ `data` ใช้สำหรับระบุชุดข้อมูลที่ต้องการแยกคอลัมน์ `col` ใช้ระบุคอลัมน์ที่ต้องการแยกค่าสังเกตออกจากกัน `into` ใช้กำหนดชื่อของคอลัมน์ใหม่ที่ภายหลังจากแยกค่าสังเกตของคอลัมน์เดิมออกจากกัน และ `sep` ใช้ระบุลลักษณะของตัวคั่น (seperator) ที่ใช้สำหรับแยกข้อมูล การกำหนดตัวคั่นนี้สามารถทำได้ 3 ลักษณะ ได้แก่ การกำหนดด้วยตัวอักษร การกำหนดด้วยตำแหน่งของตัวคั่น และการกำหนดด้วยนิพจน์ปกติ (regular expression) รายละเอียดสามารถศึกษาได้จาก สิวะโชติ ศรีสุทธิยากร (2564)

ตัวอย่างด้านล่างแสดงการใช้ฟังก์ชัน `separate()` เพื่อแยกค่าสังเกตในคอลัมน์ `gender.age` ออกเป็นคอลัมน์ `gender` และ `age` ตามลำดับ จากตัวอย่างจะเห็นว่าในคอลัมน์ `gender.age` มีการใช้ตัวคั่นข้อมูลเป็น `/` จึงกำหนดอาร์กิวเมนท์ `sep="/"`

```{r}
# R syntax
iq_sep<-separate(data = iq,
         col = "gender.age",
         into = c("gender","age"),
         sep="/")
iq_sep
```

ในกรณีที่ใช้ภาษา Python สามารถดำเนินการได้โดยใช้ฟังก์ชัน `str.split()` ภายใต้ pandas library โดยฟังก์ชันดังกล่าวมีพารามิเตอร์ที่สำคัญ 1 ตัวได้แก่ `separator` ที่ใช้สำหรับระบุลักษณะของตัวคั่นข้อมูลในคอลัมน์ที่ต้องการแยก ตัวอย่างการใช้ฟังก์ชัน `str.split()` เพื่อแยกคอลัมน์ `gender.age` ในชุดข้อมูล `iq` เป็นดังนี้

```{python echo=F}
iq = r.iq
```

```{python}
# Python syntax
iq["gender"] = iq["gender.age"].str.split("/", expand=True)[0]
iq["age"] = iq["gender.age"].str.split("/", expand=True)[1]
iq
```

### การยุบรวมคอลัมน์

อีกกรณีคือเป็นไปได้ที่ข้อมูลของตัวแปรเดียวกันอาจถูกเก็บอยู่ในหลายคอลัมน์ เช่นข้อมูลคำนำหน้า ชื่อ และนามสกุล หรือ ข้อมูลเวลา (วัน เดือน ปี) ตาราง 5 แสดงข้อมูลจากชุดข้อมูล `login.xlsx` ที่มีปัญหาดังกล่าว จากตารางจะเห็นว่ามีการจัดเก็บคำนำหน้า และชื่อของผู้เข้าระบบอยู่คนละคอลัมน์กัน

**ตาราง 5** จำนวนครั้งของการเข้าระบบ

```{r echo=F}
login<-read_excel("/Users/siwachoat/Library/CloudStorage/OneDrive-ChulalongkornUniversity/Documents/บริการวิชาการ/chapterbook มสธ./chapter/chapter/datasets/login.xlsx")
kbl(login)%>%
   kable_classic_2(full_width = T, html_font="Sarabun", position="left",
                  font_size=14)
```

การยุบรวมคอลัมน์ทั้งสองเข้าด้วยกันในภาษา R สามารถทำได้ด้วยฟังก์ชัน `unite()` ของ package-tidyr ฟังก์ชันนี้มีอาร์กิวเมนท์ที่สำคัญได้แก่ `data` ใช้ระบุชุดข้อมูลที่ต้องการดำเนินงาน `col` ใช้ระบุชื่อของคอลัมน์ใหม่ภายหลังจากยุบรวมคอลัมน์เดิมเข้าด้วยกัน และ `sep` ใช้สำหรับระบุตัวคั่นสำหรับคั่นข้อมูลที่ยุบรวมกัน (ค่าเริ่มต้นของอาร์กิวเมนท์นี้กำหนดให้ใช้สัญลักษณ์ underscore `sep="_"`)

ตัวอย่างต่อไปนี้แสดงการใช้ฟังก์ชัน `unite()` ดังกล่าว สมมุติว่า `login.xlsx` ในข้างต้นถูกจัดเก็บในโปรแกรม R โดยเก็บไว้ในตัวแปร `login` ผู้วิเคราะห์สามารถยุบรวมคอลัมน์ `คำนำหน้า` และ `ชื่อ` เข้าด้วยกัน โดยใช้ฟังก์ชัน `unite()` ได้ดังนี้

```{r}
# R syntax
login_united<-unite(login, 
      col="name",
      "คำนำหน้า", "ชื่อ")
login_united
```

สำหรับภาษา Python การยุบรวมคอลัมน์ตั้งแต่ 2 คอลัมน์ขึ้นไปเข้าด้วยกันทำได้ง่ายมากโดยการใช้ตัวดำเนินการเชื่อม (concatenate operator) ดังตัวอย่างต่อไปนี้

```{python echo=F}
login = r.login
```

```{python}
# Python syntax
login["name"] = login["คำนำหน้า"] + login["ชื่อ"]
login
```

### การรวมชุดข้อมูลตามแถว (rows combined)

งานทางด้านสถิติและวิทยาการข้อมูลในปัจจุบันบ่อยครั้งข้อมูลสำคัญมักมาจากหลายแหล่งข้อมูล เช่น อาจได้มาจากการเก็บเกี่ยวข้อมูลจากเว็ปไซด์ส่วนนึง (web scraping) และส่วนที่เหลืออาจเป็นข้อมูลที่ได้จากฐานข้อมูลเปิดต่าง ๆ หากชุดข้อมูลดังกล่าวเป็นข้อมูลของหน่วยการวิเคราะห์เดียวกัน หรือสามารถจัดกระทำให้เป็นข้อมูลของหน่วยการวิเคราะห์เดียวกันได้แล้ว การจะนำข้อมูลดังกล่าวมาวิเคราะห์ร่วมกันจำเป็นที่จะต้องยุบรวมชุดข้อมูลดังกล่าวเข้าด้วยกันก่อน การยุบรวมชุดข้อมูลอาจจำแนกได้เป็น 2 ลักษณะ ได้แก่ การยุบรวมข้อมูลตามแถว (rows combined) และการยุบรวมข้อมูลตามคอลัมน์ (columns combined) หัวข้อนี้จะกล่าวถึงการยุบรวมข้อมูลตามแถว รายละเอียดมีดังนี้

รูป 4.2 แสดงลักษณะของการยุบรวมข้อมูลตามแถว จากรูปจะเห็นว่าเริ่มต้นมีชุดข้อมูลจากแหล่งข้อมูลที่แตกต่างกันจำนวน 3 แหล่ง ได้แก่ A, B และ C โดยที่ชุดข้อมูลจากแต่ละแหล่งดังกล่าวเก็บข้อมูลของตัวแปรเดียวกัน และมีจำนวนคอลัมน์เท่ากัน แต่จะสังเกตเห็นว่าแต่ละชุดข้อมูลมีหน่วยข้อมูลที่แตกต่างกัน การยุบรวมชุดข้อมูลทั้ง 3 ตามแถวจะให้ผลลัพธ์เป็นชุดข้อมูลที่ใหญ่ขึ้นจากเดิม โดยมีหน่วยข้อมูลทั้งหมดจากทั้ง 3 ชุดข้อมูลข้างต้นมาจัดเก็บอยู่ภายใต้ชุดข้อมูลใหม่ขนาด 9 x 3

![**รูป 4.2** ตัวอย่างแสดงลักษณะการยุบรวมชุดข้อมูลตามแถว (row combined)](rowbind.png){fig-align="left" width="70%"}

ที่มา : สิวะโชติ ศรีสุทธิยากร (2564)

การรวมชุดข้อมูลตามแถวด้วยภาษา R สามารถทำได้หลายวิธีการ ฟังก์ชัน `bind_rows()` ของ package-dplyr สามารถใช้เพื่อรวมชุดข้อมูลดังกล่าวได้ อาร์กิวเมนท์ของฟังก์ชัน `bind_rows()` ได้แก่ชุดข้อมูลแบบ Dataframe ที่ต้องการนำมารวมกันตามแถว เงื่อนไขของการใช้ฟังก์ชันนี้คือชุดข้อมูลที่จะนำมารวมกันจำเป็นต้องมีจำนวนคอลัมน์เท่ากัน แต่ละคอลัมน์จัดเก็บข้อมูลของตัวแปรเดียวกันและมีการจัดเรียงลำดับของตัวแปรที่เหมือนกัน

ตัวอย่างต่อไปนี้แสดงการยุบรวมข้อมูลตามแถวด้วยฟังก์ชัน `bind_rows()` สมมุติว่าผู้วิเคราะห์มีไฟล์ข้อมูลของกลุ่มเป้าหมายเดียวกันจำนวน 4 ไฟล์ ที่สามารถดาวน์โหลดไฟล์ดังกล่าวได้จาก <https://bit.ly/2AuQgqr> (สิวะโชติ ศรีสุทธิยากร, 2564) ไฟล์ข้อมูลทั้ง 4 ประกอบด้วย `file1.xlsx`, `file2.xlsx`, `file3.xlsx` และ `file4.xlsx` ตามลำดับ โดยที่แต่ละไฟล์จัดเก็บข้อมูลของนักเรียนไฟล์ละ 5 คน ตารางด้านล่างแสดงข้อมูลที่จัดเก็บอยู่ในไฟล์ `file1.xlsx`

```{r echo=F, warning=F, message=F}
file.name<-list.files(path = "/Users/siwachoat/Library/CloudStorage/OneDrive-ChulalongkornUniversity/Documents/บริการวิชาการ/chapterbook มสธ./chapter/chapter/datasets",
                      pattern = "*.xlsx")

files<-file.name[grepl("file", file.name)==TRUE]
setwd("/Users/siwachoat/Library/CloudStorage/OneDrive-ChulalongkornUniversity/Documents/บริการวิชาการ/chapterbook มสธ./chapter/chapter/datasets")
list<-lapply(files, read_excel, na="-")
dat1<-list[[1]]
dat2<-list[2]
dat3<-list[3]
dat4<-list[4]

dat1
```

เมื่อผู้อ่านได้ดำเนินการสำรวจไฟล์ข้อมูลทั้ง 4 แล้วจะพบว่าโครงการการจัดเก็บข้อมูลของทั้ง 4 ไฟล์มีลักษณะเหมือนกัน ชุดข้อมูลทั้ง 4 จึงสามารถยุบรวมกันตามแถวได้โดยใช้ฟังก์ชัน `rbind()` ในข้างต้น ตัวอย่างนี้ผู้เขียนได้นำเข้าข้อมูลจากทั้ง 4 ไฟล์และจัดเก็บอยู่ในชุดข้อมูลชื่อ `dat1`, `dat2`, `dat3` และ `dat4` ตามลำดับ การเขียนคำสั่งเพิ่มยุบรวมชุดข้อมูลดังกล่าวตามแถวเป็นดังนี้

```{r}
# R syntax
dat_rbind <-bind_rows(dat1, dat2, dat3, dat4)
dat_rbind
```

สำหรับภาษา Python การยุบรวมชุดข้อมูลตามแถวสามารถดำเนินการได้หลายวิธีการเช่นเดียวกับภาษา R ฟังก์ชันหนึ่งที่สามารถทำได้คือฟังก์ชัน `append()` ภายใต้ pandas library ตัวอย่างต่อไปนี้แสดงการยุบรวมชุดข้อมูลใน `file1.xlsx`, `file2.xlsx`, `file3.xlsx` และ `file4.xlsx` ตามแถว ทั้งนี้ในตัวอย่างดังกล่าวได้จัดเก็บข้อมูลทั้ง 4 ไว้ในตัวแปรได้แก่ `dat1`, `dat2`, ..., `dat4` เช่นเดียวกับตัวอย่างของภาษา R ผลลัพธ์ด้านล่างแสดงตัวอย่างของชุดข้อมูล `dat1` ที่เก็บอยู่ใน Python

```{python echo=F}
dat1 = r.dat1
dat2 = r.dat2
dat3 = r.dat3
dat4 = r.dat4
```

```{python}
# Python syntax
dat1
dat1.info()
```

การยุบรวมชุดข้อมูลทั้ง 4 ตามแถวด้วยฟังก์ชัน `append()` สามารถทำได้ดังนี้

```{python}
# Python syntax
import pandas as pd
dat_rbind = dat1.append(dat2)
dat_rbind
```

ในกรณีที่มีชุดข้อมูลมากกว่า 2 ชุด ที่ต้องการยุบรวมเข้าด้วยกันตามแถว สามารถใช้ฟังก์ชัน `append()` เรียงต่อกกันได้ดังตัวอย่างต่อไปนี้

```{python}
# Python syntax
dat_rbind = dat1.append(dat2).append(dat3).append(dat4)
dat_rbind
```

### การยุบรวมข้อมูลตามคอลัมน์ (columns combined)

การยุบรวมข้อมูลตามคอลัมน์มีการดำเนินการคล้ายกับการยุบรวมตามแถว แต่เปลี่ยนมิติของการจับคู่เป็นการจับคู่ข้อมูลระหว่างหน่วยข้อมูลเดียวกันที่อยู่ต่างชุดข้อมูลกัน รูป 4.3 แสดงลักษณะของการยุบรวมข้อมูลตามคอลัมน์ จากรูปจะเห็นว่า การยุบรวมข้อมูลลักษณะนี้เป็นการนำชุดข้อมูลหลายชุดของหน่วยข้อมูลเดียวกันหรือมีหน่วยข้อมูลเป็นส่วนย่อยของกันและกัน และมีตัวแปรที่แตกต่างกันมารวมเข้าเป็นชุดข้อมูลเดียวกัน

![รูป 4.3 ตัวอย่างแสดงลักษณะการยุบรวมชุดข้อมูลตามคอลัมน์ (column combined)](colbind.png){alt="รูป 4.3 ตัวอย่างแสดงลักษณะการยุบรวมชุดข้อมูลตามคอลัมน์ (column combined)" fig-align="left" width="70%"}

ที่มา : สิวะโชติ ศรีสุทธิยากร (2564)

การยุบรวมข้อมูลตามคอลัมน์ด้วยภาษา R สามารถดำเนินการได้หลายวิธีการมาก วิธีการแรกคือการใช้ฟังก์ชัน `bind_cols()` ของ package-dplyr ที่มีการทำงานเหมือนกับฟังก์ชัน `bind_rows()` แต่จะดำเนินการรวมข้อมูลตามคอลัมน์แทน เงื่อนไขของฟังก์ชันนี้ที่ไม่ค่อยสะดวกนักคือ ชุดข้อมูลที่จะยุบรวมกันตามคอลัมน์ต้องเป็นชุดข้อมูลของหน่วยข้อมูลเดียวกัน แต่มีตัวแปรที่แตกต่างกัน และการจัดเรียงหน่วยข้อมูลต้องเป็นไปในลำดับเดียวกัน ดังในรูป 4.3 ข้างต้น (ผู้อ่านสามารถศึกษารายละเอียดของฟังก์ชัน `bind_cols()` ได้โดยพิมพ์คำสั่ง `?bind_cols()`)

ในทางปฏิบัติเมื่อผู้วิเคราะห์ดำเนินการกับข้อมูลขนาดใหญ่หลายชุดที่มาจากฐานข้อมูลที่แตกต่างกัน ชุดข้อมูลดังกล่าวมักจะมีการจัดเรียงลำดับของหน่วยข้อมูลที่แตกต่างกัน นอกจากนี้ชุดข้อมูลทั้งหมดยังอาจมีบางหน่วยข้อมูลที่แตกต่างกันและไม่สามารถยุบรวมกันได้ สถานการณ์ที่ซับซ้อนลักษณะนี้การยุบรวมด้วยฟังก์ชัน `bind_cols()` จะเป็นวิธีการที่ค่อนข้างลำบาก การใช้กลุ่มฟังก์ชัน join ของ package-dplyr เป็นวิธีการที่เหมาะสมมากกว่า กลุ่มฟังก์ชัน join ดังกล่าวประกอบด้วยฟังก์ชัน 4 ตัวที่ทำงานแตกต่างกัน เพื่อรองรับความต้องการในการยุบรวมข้อมูลตามคอลัมน์ของผู้วิเคราะห์ที่แตกต่างกัน ได้แก่ `inner_join()`, `full_join()`, `left_join()` และ `right_join()` รูป 4.4 แสดงลักษณะการทำงานของกลุ่มฟังก์ชัน join ดังกล่าว จากรูปจะเห็นความแตกต่างของฟังก์ชันทั้ง 4 ตัวว่าอยู่ที่การเลือกจัดเก็บหรือไม่จัดเก็บหน่วยข้อมูลจากชุดข้อมูลที่จะยุบรวมกันอย่างไร กล่าวคือ `inner_join()` จะเลือกจัดเก็บเฉพาะหน่วยข้อมูลที่มีร่วมกันระหว่างชุดข้อมูลทั้งสองเท่านั้น ในขณะที่ `left_join()` จะเก็บหน่วยข้อมูลชุดทางซ้าย (เรียกว่าชุด x) ไว้ทั้งหมด แต่จะเลือกจัดเก็บข้อมูลชุดทางขวา (เรียกว่าชุด y) เฉพาะส่วนที่มีข้อมูลร่วมกันกับชุด x เท่านั้น ฟังก์ชัน `right_joint()` มีการดำเนินการเหมือนกับ `left_join()` แต่มีทิศทางการจัดเก็บข้อมูลที่ตรงข้ามกัน ส่วนฟังก์ชัน `full_join()` จะเก็บหน่วยข้อมูลทุกหน่วยไว้ไม่ว่าหน่วยข้อมูลนั้นจะมีอยู่ร่วมกันในทั้งสองชุดข้อมูลหรือไม่

![รูป 4.4 ตัวอย่างแสดงลักษณะการทำงานของฟังก์ชันในกลุ่ม join](join.png){fig-align="left" width="70%"}

ที่มา : สิวะโชติ ศรีสุทธิยากร (2564)

ฟังก์ชันในกลุ่ม join มีอาร์กิวเมนท์ที่สำคัญเหมือนกันได้แก่ `x` และ `y` คือชุดข้อมูลที่ต้องการยุบรวมกันตามคอลัมน์ และ `by` ใช้ระบุตัวแปร id ที่จะใช้จับคู่หน่วยข้อมูลระหว่างชุดข้อมูลทั้งสอง ทั้งนี้การระบุอาร์กิวเมนท์นี้จะต้องระบุเป็นเวกเตอร์ตัวอักษร (character vector)

ตัวอย่างต่อไปนี้แสดงการใช้ฟังก์ชัน join ทั้ง 4 ตัวเพื่อยุบรวมข้อมูลตามคอลัมน์ ชุดข้อมูลที่ใช้เป็นตัวอย่างเป็นชุดข้อมูลที่สร้างขึ้นด้วยการกำหนดค่าด้วยมือ ประกอบด้วยชุดข้อมูล `X` และ `Y` สังเกตว่าชุดข้อมูลทั้งหมดมีตัวแปร `id` ที่ใช้สำหรับอ้างอิงหน่วยข้อมูล นอกจากนี้ชุดข้อมูลทั้งสองมีหน่วยข้อมูลที่เหมือนกันเพียงบางส่วน และมีการจัดเก็บข้อมูลของตัวแปรที่แตกต่างกัน

```{r}
# R syntax
X<-data.frame(id=c(1,2,3,4),
              gender = c("m","f","f","m"),
              income = c(10,5,20,15))

Y<-data.frame(id=c(1,2,5,6,7),
              score = c(30,50,20,100, 75),
              location = c("N","NE","S","C","W"))
```

```{r}
# R syntax
X
Y
```

ผลลัพธ์ที่ได้จากการยุบรวมข้อมูลตามคอลัมน์ด้วยฟังก์ชัน join ทั้ง 4 ตัวเป็นดังนี้ ผู้อ่านลองพิจารณาความแตกต่างของผลลัพธ์ที่ได้จากฟังก์ชันทั้ง 4 ใน output ด้านล่าง

```{r}
# R syntax
inner_join(X, Y, by = "id")
left_join(X, Y, by = "id")
right_join(X, Y, by = "id")
full_join(X, Y, by = "id")
```

ในภาษา Python มีฟังก์ชันที่เทียบเคียงได้กับกลุ่มฟังก์ชัน join ของภาษา R เช่นเดียวกันได้แก่ ฟังก์ชัน `merge()` ภายใต้ pandas library ฟังก์ชันดังกล่าวมีพารามิเตอร์ที่สำคัญได้แก่ `left` และ `right` ใช้ระบุชุดข้อมูลทางซ้ายและทางขวาสำหรับการยุบรวม `on` ใช้ระบุ id สำหรับการจับคู่หน่วยข้อมูลเดียวกันระหว่างสองชุดข้อมูลที่ต้องการยุบรวมกัน และ `how` ใช้ระบุลักษณะของการยุบรวมระหว่างชุดข้อมูล โดยสามารถเลือกกำหนดได้ 4 แบบเช่นเดียวกับภาษา R ได้แก่ `inner`, `left`, `right` และ `outer` โดยที่ `outer` จะเทียบเท่ากับ `full_join()` ในภาษา R ข้างต้น

ตัวอย่างต่อไปนี้แสดงการใช้ฟังก์ชัน `pd.merge()` เพื่อยุบรวมชุดข้อมูล `X` และ `Y` ด้านล่าง ด้วยวิธีการทั้ง 4 แบบ

```{python}
# Python syntax
X = {'id': [1,2,3,4],
     'gender': ["m","f","f","m"],
     'income': [10,5,20,15]}

Y = {'id': [1,2,5,6,7],
    'score': [30,50,20,100, 75],
    'location': ["N","NE","S","C","W"]}
    
X = pd.DataFrame(X)
Y = pd.DataFrame(Y)
```

```{python}
# Python syntax
X
Y
```

```{python}
# Python syntax
pd.merge(X, Y, on="id", how="inner")
pd.merge(X, Y, on="id", how="left")
pd.merge(X, Y, on="id", how="right")
pd.merge(X, Y, on="id", how="outer")

```
