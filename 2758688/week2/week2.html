<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>ML: สัปดาห์ที่ 2:  Linear Regression</title>
    <meta charset="utf-8" />
    <meta name="author" content="อ.ดร.สิวะโชติ ศรีสุทธิยากร" />
    <script src="week2_files/header-attrs/header-attrs.js"></script>
    <script src="week2_files/kePrint/kePrint.js"></script>
    <link rel="stylesheet" href="xaringan-themer1.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# ML: สัปดาห์ที่ 2: </br> Linear Regression
### อ.ดร.สิวะโชติ ศรีสุทธิยากร

---


class: center, middle






&lt;img src="Asset 1.png", width=30%&gt;



---
class: middle, center, inverse


&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/aaOB-ErYq6Y" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen&gt;&lt;/iframe&gt;


---
class: middle

.left-column[

### Supervised Learning

&lt;section style="font-size:14px;"&gt;
เป็นการเรียนรู้รูปแบบความสัมพันธ์ระหว่างตัวแปรตามกับตัวแปรอิสระที่พบเจอในชุดข้อมูลฝึกหัด (training dataset) และสร้างโมเดลทางสถิติที่เหมาะสมเพื่อทำนาย (predicting) หรือคาดการณ์ผลลัพธ์ (output) ของตัวแปรตาม ด้วยข้อมูลของตัวแปรอิสระ
&lt;/section&gt;

&lt;img src="XY.png"&gt;

]

.right-column[

Supervised Learning จำแนกได้เป็นสองประเภทตามลักษณะของตัวแปรตาม

- **Regression** (สำหรับตัวแปรตามแบบต่อเนื่อง)

- **Classification** (สำหรับตัวแปรตามแบบจัดประเภท)

.pull-left[

&lt;small&gt;

การพัฒนา supervised learning model หรืออาจเรียกว่า predictive model มีขั้นตอนดังนี้

1. Problem Definition

2. Hypothesis Generation

3. Data Collection

4. Data Exploration and Preparation

5. Developing ML model

6. Model Implementation

&lt;/small&gt;
]


.pull-right[
&lt;/br&gt;

&lt;img src="modeling.png" width=100%&gt;
]

]

---
class: middle, center

&lt;img src="predict.png" width=70%&gt;




---
class: middle

.left-column[

### Types of Regression

&lt;small&gt;
regression เป็น area ที่ใหญ่ โดยสามารถจำแนกเป็นโมเดล regression ย่อย ๆ ได้หลากหลายโมเดล ทั้งนี้ขึ้นอยู่กับลักษณะค่าสังเกตของตัวแปรตาม และลักษณะความสัมพันธ์โดยธรรมชาติระหว่างตัวแปรตามกับตัวแปรอิสระ
&lt;/small&gt;
]


.right-column[
&lt;table class="table" style="font-size: 12px; margin-left: auto; margin-right: auto;"&gt;
 &lt;thead&gt;
  &lt;tr&gt;
   &lt;th style="text-align:left;"&gt; ประเภท &lt;/th&gt;
   &lt;th style="text-align:left;"&gt; ลักษณะการใช้งาน &lt;/th&gt;
  &lt;/tr&gt;
 &lt;/thead&gt;
&lt;tbody&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;font-weight: bold;border-right:1px solid;"&gt; Simple linear &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; Predicting a quantitative response variable from quantitative/qualitative explanatory variable. &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;font-weight: bold;border-right:1px solid;"&gt; Polynomial &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; Predicting a quantitative response variable from quantitative explanatory variable when the relationship is modeled as an nth order polynomial &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;font-weight: bold;border-right:1px solid;"&gt; Multiple Linear &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; Predicting a quantitative response variable from two or more quantitative/qualitative explanatory variables. &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;font-weight: bold;border-right:1px solid;"&gt; Multilevel &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; Predicting a response variable from data that have hierarchical structure. &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;font-weight: bold;border-right:1px solid;"&gt; Multivariate &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; Predicting more than one response variables from one and more explanatory variables. &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;font-weight: bold;border-right:1px solid;"&gt; Logistic &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; Predicting a categorical response variable from one or more explanatory variables. &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;font-weight: bold;border-right:1px solid;"&gt; Poisson &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; Predicting a response variable representing counts from one or more explanatory variables. &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;font-weight: bold;border-right:1px solid;"&gt; Cox proportaional hazards &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; Predicting time to event (death, failure,...) from one or more explanatory variables. &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;font-weight: bold;border-right:1px solid;"&gt; Time-series &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; Modeling time-series data with correlated errors. &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;font-weight: bold;border-right:1px solid;"&gt; Nonlinear &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; Predicting a quantitative response variable from one or more explanatory variables, where the form of the model is nonlinear. &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;font-weight: bold;border-right:1px solid;"&gt; Nonparametric &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; Predicting a quantitative response variable from one or more explanatory variables, where the form of the model is derived from the data and not specified a priori, &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;font-weight: bold;border-right:1px solid;"&gt; Robust &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; Predicting a quantitative response variable from one or more explanatory variables using an approach that's resistant to the effect of influential observtions. &lt;/td&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
]

---
class: middle


.left-column[

## Linear Regression


* Basic Concepts

* Training Models

* Evaluating Models
]

---
class: middle


.left-column[

## Linear Regression


* **Basic Concepts**

* Training Models

* Evaluating Models
]



.right-column[


**Linear regression**

&lt;small&gt;

 เป็นโมเดลการเรียนรู้ที่ classic และง่ายที่สุด วัตถุประสงค์ของการวิเคราะห์อาจจำแนกเป็นสองด้าน

* อธิบายความสัมพันธ์เชิงสาเหตุระหว่างตัวแปรอิสระ (independent variables) กับตัวแปรตาม (dependent variables) 

* ทำนายแนวโน้มการเกิดค่าสังเกตของตัวแปรตาม โดยใช้ linear combination

`$$\hat{y}=b_0+b_1x_1+b_2x_2+...+b_px_p \approx y$$`
เมื่อ `\(y\)` คือค่าสังเกตจริงของตัวแปรตาม, `\(x\)` คือค่าสังเกตจริงของตัวแปรอิสระ, `\(b_j\)` คือสัมประสิทธิ์การถดถอย (regression coefficients) และ `\(\hat{y}\)` คือค่าทำนายตัวแปรตาม `\(y\)` โดยที่ สัมประสิทธิ์ภายใน linear combination ประมาณได้จากข้อมูลค่าสังเกตค่าด้วยอัลกอริทึมการเรียนรู้ เช่น least squares method 
&lt;/small&gt;
]


--

.right-column[

**Simple Linear Regression**

.pull-left[
&lt;small&gt;
ฝ่าย HR ของมหาวิทยาลัยต้องการพัฒนาโมเดลทำนายเงินเดือนของอาจารย์ (Salary) ด้วยประสบการณ์ในการทำงานด้านวิชาการของอาจารย์ (YearsExperience) ทั้งนี้เพื่อใช้เป็นสารสนเทศประกอบการกำหนดข้อเสนอการจ้างงานสำหรับอาจารย์ใหม่ของมหาวิทยาลัย
&lt;/small&gt;
]

.pull-right[
&lt;img src="simreg.png", width=100%&gt;

]


]



---
class: middle


.left-column[

## Linear Regression


* **Basic Concepts**

* Training Models

* Evaluating Models
]


.right-column[

.pull-left[
&lt;/br&gt;

&lt;img src="week2_files/figure-html/unnamed-chunk-2-1.png" width="504" /&gt;&lt;img src="week2_files/figure-html/unnamed-chunk-2-2.png" width="504" /&gt;
]

.pull-right[

&lt;/br&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;/br&gt;


**no relationship between y and x**


&lt;/br&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;/br&gt;

**linear relationship between y and x**

- 1st linear combination: 

`$$\hat{y}=\bar{y}+0x$$`

- 2nd linear combination: 

`$$\hat{y}=19+1.5x$$`

]

]

---
class: middle


.left-column[

## Linear Regression


* **Basic Concepts**

* Training Models

* Evaluating Models
]


.right-column[


### Y = signal + noise

- **signal** = some math function ---&gt; eg. linear function: `\(f(x)=\beta_0+\beta_1x\)`

- **noise** = random error ---&gt; `\(\epsilon_i=y_i-\hat{y}_i\)` ---&gt; `\(\sigma^2\)`


.pull-left[
&lt;img src="week2_files/figure-html/unnamed-chunk-3-1.png" width="504" /&gt;
]

.pull-right[

&lt;small&gt;

* `\(f(x)\)` ที่กำหนดในแต่ละการวิเคราะห์เป็นสมมุติฐาน ซึ่งมีความเป็นไปได้สูงที่จะไม่ใช่โมเดลจริงของประชากร

* อัลกอริทึมการเรียนรู้จะประมาณค่าพารามิเตอร์ภายในฟังก์ชัน `\(f(x)\)` เพื่อปรับเหมาะให้ฟังก์ชันดังกล่าวสามารถเรียนรู้ความสัมพันธ์ระหว่างตัวแปรใน traning data ได้ดีที่สุด

* `\(b_1 \approx \beta_1\)` คือพารามิเตอร์ความชัน (slope) ---&gt; `\(\frac{\Delta\overline{y}}{\Delta{x}}\)`

* `\(b_0 \approx \beta_0\)` คือพารามิเตอร์จุดตัดแกน (intercept)

 
&lt;/small&gt;

]
]


---
class: middle


.left-column[

## Linear Regression


* Basic Concepts

* **Training Models**

* Evaluating Models

&lt;/br&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;/br&gt;

&lt;small&gt;
**Note:** ภาษา ML เรียก `\(SSE=\sum_{i=1}^n(y_i-\hat{y}_i)^2\)` ว่า ฟังก์ชันความสูญเสีย (Loss function)
&lt;/small&gt;
]

.right-column[

&lt;small&gt;

### Least Squares Algorithm

เป็นวิธีประมาณค่าโดยตรง วิธีนี้จะคำนวณหาค่าชุดของพารามิเตอร์ที่ดีที่สุดของโมเดลที่ทำให้โมเดลมีความสอดคล้องกับ training data มากที่สุด (ie. optimize intercept and slope parameter of the model) การคำนวณค่าประมาณพารามิเตอร์ดังกล่าวจะคำนวณด้วยสูตรปิด (closed form)

`$$\min_{\beta}SSE \rightarrow b=(X^TX)^{-1}(X^TY)$$`


### Gradient Descent Algorithm

เป็น iterative optimization approach กล่าวคือไม่ได้มีสูตรปิดตายตัวสำหรับหาค่าประมาณพารามิเตอร์ แต่จะใช้การทวนซ้ำเพื่อหาชุดของค่าพารามิเตอร์ที่เป็นคำตอบที่ดีที่สุด
1. กำหนด model และค่าเริ่มต้นของพารามิเตอร์ภายในโมเดล (initial value)

2. คำนวณค่า 1st order derivative ของ Loss function ของโมเดลด้วยค่าพารามิเตอร์ที่กำหนด (derivative=0 หรือไม่?)

3. ถ้า derivative `\(\neq0\)` แทนพารามิเตอร์ค่าใหม่ ดังนี้ `\(new = old-stepSize\)` `\((stepSize = derivative \times LearningRate)\)`

4. ทวนซ้ำขั้นตอนที่ 2 และ 3 จนกระทั่ง derivative `\(=0\)`

&lt;/small&gt;

]



---
name: yourturn
template: section

.left-column[
# .fancy[Your turn]
]
---
name: yourturn1
template: yourturn


.right-column[

### Training Simple Regression Model

&lt;small&gt;
ฝ่าย HR ของมหาวิทยาลัยต้องการพัฒนาโมเดลทำนายเงินเดือนของอาจารย์ (Salary) ด้วยประสบการณ์ในการทำงานด้านวิชาการของอาจารย์ (YearsExperience) ทั้งนี้เพื่อใช้เป็นสารสนเทศประกอบการกำหนดข้อเสนอการจ้างงานสำหรับอาจารย์ใหม่ของมหาวิทยาลัย



1. นำชุดข้อมูล [datasets_Salary_Data.csv](https://drive.google.com/file/d/11v2nEFVj2wfYfwruVgCUlu5eWiyJrYN6/view?usp=sharing) เข้าสู่ R

2. สำรวจข้อมูลเบื้องต้นด้วยฟังก์ชัน `summary()` และ `str()`

3. สร้าง scatter plot เพื่อสำรวจความสัมพันธ์ระหว่าง `Salary` กับ `YearsExperience` (นิสิตคิดว่าสามารถ fit linear model ให้กับข้อมูลชุดนี้ได้หรือไม่?)

4. แบ่งข้อมูลออกเป็น 2 ส่วนอย่างสุ่ม ได้แก่ trainning data และ testing data ด้วยอัตราส่วน 80:20

5. ประมาณค่าพารามิเตอร์ในโมเดลด้วย least squares algorithm โดยใช้ฟังก์ชัน `lm()`

6. ประเมินคุณภาพของโมเดล

&lt;/small&gt;
]

---
name: yourturn1
template: yourturn

### Importing and Exploring Data



```r
dat&lt;-read.csv("datasets_Salary_Data.csv")
summary(dat)
```



```
##  YearsExperience      Salary      
##  Min.   : 1.100   Min.   : 37731  
##  1st Qu.: 3.200   1st Qu.: 56721  
##  Median : 4.700   Median : 65237  
##  Mean   : 5.313   Mean   : 76003  
##  3rd Qu.: 7.700   3rd Qu.:100545  
##  Max.   :10.500   Max.   :122391
```


```r
str(dat)
```

```
## 'data.frame':	30 obs. of  2 variables:
##  $ YearsExperience: num  1.1 1.3 1.5 2 2.2 2.9 3 3.2 3.2 3.7 ...
##  $ Salary         : num  39343 46205 37731 43525 39891 ...
```



---
name: yourturn1
template: yourturn

### Exploring Data



```r
library(ggplot2)
library(dplyr)

dat%&gt;%ggplot(aes(x=YearsExperience,y=Salary))+
        geom_point(size=2)
```


&lt;img src="week2_files/figure-html/unnamed-chunk-8-1.png" width="648" /&gt;


---
name: yourturn1
template: yourturn

### Splitting Data


```r
set.seed(123)# specify the initial seed
dat$id&lt;-1:30 # create ID
train.id&lt;-sample(dat$id,0.8*30) #random sampling 80% of data
train.dat&lt;-dat[train.id,]
test.dat&lt;-dat[-train.id,]
```



```r
str(train.dat)
```

```
## 'data.frame':	24 obs. of  3 variables:
##  $ YearsExperience: num  4.5 5.9 4.1 1.5 3.7 5.3 7.1 3.9 2.2 6 ...
##  $ Salary         : num  61111 81363 57081 37731 57189 ...
##  $ id             : int  15 19 14 3 10 18 22 11 5 20 ...
```


```r
str(test.dat)
```

```
## 'data.frame':	6 obs. of  3 variables:
##  $ YearsExperience: num  1.3 2.9 4 4 4.9 10.3
##  $ Salary         : num  46205 56642 55794 56957 67938 ...
##  $ id             : int  2 6 12 13 16 29
```

---
name: yourturn1
template: yourturn

### Training Simple Regression Model

&lt;small&gt;
ฟังก์ชันพื้นฐานสำหรับประมาณค่าพารามิเตอร์ใน Linear regression model คือ `lm()` ที่มีรูปแบบการเขียนคำสั่งพื้นฐานดังนี้

&lt;/small&gt;

`fit&lt;-lm(formula, data)`

&lt;small&gt;
โดยที่ `formula` คืออาร์กิวเมนท์สำหรับระบุรูปแบบของ training model โดยเขียนในรูปแบบ `y~x1+x2+x3` และ `data` คือชุดข้อมูล (data.frame) ที่ต้องประกอบด้วยค่าสังเกตของตัวแปรตามและตัวแปรอิสระ
&lt;/small&gt;



&lt;center&gt;
&lt;img src="extract.png" width=75%&gt;
&lt;/center&gt;


---
name: yourturn1
template: yourturn

&lt;/br&gt;

&lt;small&gt;

```r
fit&lt;-lm(Salary~YearsExperience, data=train.dat)
summary(fit) #extract training model information
```

```
## 
## Call:
## lm(formula = Salary ~ YearsExperience, data = train.dat)
## 
## Residuals:
##     Min      1Q  Median      3Q     Max 
## -8231.8 -4239.8  -160.2  3747.9 11063.2 
## 
## Coefficients:
##                 Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept)      25437.1     2628.7   9.677 2.19e-09 ***
## YearsExperience   9573.3      427.3  22.405  &lt; 2e-16 ***
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
## Residual standard error: 5769 on 22 degrees of freedom
## Multiple R-squared:  0.958,	Adjusted R-squared:  0.9561 
## F-statistic:   502 on 1 and 22 DF,  p-value: &lt; 2.2e-16
```
&lt;/small&gt;

---
class: middle


.left-column[

## Linear Regression


* Basic Concepts

* Training Models

* **Evaluating Models**

&lt;p style="text-indent:3em;"&gt;- In-sample fit&lt;/p&gt;
&lt;p style="text-indent:3em;"&gt;- Out-sample fit&lt;/p&gt;

]


.right-column[

### In-sample fit (model validation)

&lt;small&gt;
Model validation is defined within regulatory guidance as “the set of processes and activities intended to verify that models are performing as expected, in line with their design objectives, and business uses.” It also identifies “potential limitations and assumptions, and assesses their possible impact.” (Khurana, 2019)
&lt;/small&gt;

.pull-left[

&lt;img src="assumption.png"&gt;
]

.pull-right[
&lt;/br&gt;

**Linear regression's assumptions**

&lt;small&gt;
1. Linearity (correct functional form)
2. Normality
3. Independence
4. Homoskedasticity
5. No outliers
6. No Multicollinearity (for MRA)
&lt;/small&gt;
]

&lt;small&gt;
- ในทางปฏิบัติผู้วิเคราะห์สามารถใช้การวิเคราะห์เศษเหลือ (residual analysis) เพื่อ validate training model ดังกล่าว
&lt;/small&gt;
]



    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script src="https://platform.twitter.com/widgets.js"></script>
<script>var slideshow = remark.create({
"ratio": "16:9",
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
