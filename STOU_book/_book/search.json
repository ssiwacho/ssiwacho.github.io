[
  {
    "objectID": "ch4.1.html",
    "href": "ch4.1.html",
    "title": "ตอนที่ 4.2 การจัดระเบียบข้อมูล (tidying data)",
    "section": "",
    "text": "ชุดข้อมูล (data set) มีลักษณะเป็นตารางที่ประกอบด้วยมิติด้านคอลัมน์ (column) และแถว (row) ใช้เก็บข้อมูลของตัวแปรต่าง ๆ ข้อมูลที่ถูกจัดเก็บอยู่ในตารางดังกล่าวเป็นไปได้ทั้งข้อมูลเชิงปริมาณที่มีค่าเป็นตัวเลข ข้อมูลเชิงคุณลักษณะที่ไม่ใช่ตัวเลข การออกแบบตารางสำหรับจัดเก็บข้อมูลนั้นสามารถทำได้หลากหลายลักษณะ พิจารณาชุดข้อมูลในตาราง 1 และ 2 ด้านล่างจะเห็นว่าถึงแม้จะเป็นเป็นชุดข้อมูลที่จัดเก็บข้อมูลเดียวกัน แต่ก็สามารถที่จะมีรูปแบบการจัดเก็บที่แตกต่างกันได้\nตาราง 4.1 : คะแนนสอบวิชาคณิตศาสตร์และภาษาอังกฤษของนักเรียน (รูปแบบที่ 1)\nตาราง 4.2 : คะแนนสอบวิชาคณิตศาสตร์และภาษาอังกฤษของนักเรียน (รูปแบบที่ 2)\nอย่างไรก็ตามการจัดเก็บข้อมูลในชุดข้อมูลในรูปแบบที่เหมาะสมกับการดำเนินการวิเคราะห์ข้อมูล หรือการสร้างทัศนภาพข้อมูลจะช่วยให้การวิเคราะห์ข้อมูลตามวัตถุประสงค์ต่าง ๆ สามารถทำได้ง่ายและมีประสิทธิภาพ ในทางกลับกันการจัดเก็บข้อมูลในรูปแบบที่ไม่เหมาะสมจะเป็นอุปสรรคในการวิเคราะห์ข้อมูล นอกจากนี้ยังอาจเป็นปัจจัยที่ก่อให้เกิดความผิดพลาดในผลการวิเคราะห์อีกด้วย รูปแบบของชุดข้อมูลที่เหมาะสมและสนับสนุนให้การวิเคราะห์ข้อมูลสามารถดำเนินไปได้อย่างมีประสิทธิภาพเรียกว่า ชุดข้อมูลจัดระเบียบ (tidy data)\nชุดข้อมูลจัดระเบียบเป็นตารางข้อมูลที่มีลักษณะสำคัญของรูปแบบการจัดเก็บข้อมูล 3 ประการ (สิวะโชติ ศรีสุทธิยากร, 2564; Wickham, 2014) ดังนี้\nรูป 4.1 แสดงตัวอย่างของชุดข้อมูลจัดระเบียบที่มีคุณลักษณะข้างต้น สังเกตว่าหัวตาราง (แถวแรกของตาราง) จะเป็นส่วนที่ใช้ระบุชื่อของตัวแปรในแต่ละคอลัมน์ อย่างไรก็ตามในสถานการณ์จริงชุดข้อมูลส่วนใหญ่มักมีลักษณะที่ละเมิดเงื่อนไขของชุดข้อมูลจัดระเบียบข้างต้นอย่างน้อยหนึ่งข้อ การจัดระเบียบชุดข้อมูลจึงเป็นขั้นตอนที่มีความสำคัญภายใต้การดำเนินงานทางด้านวิทยาการข้อมูล เนื้อหาในตอนที่ 4.1 นี้จึงจะกล่าวถึง การสำรวจลักษณะของชุดข้อมูล เพื่อวิเคราะห์สภาพและระบุปัญหาความไม่เป็นระเบียบของชุดข้อมูล (ถ้ามี) จากนั้นจะกล่าวถึงวิธีการที่เกี่ยวข้องสำหรับแก้ปัญหาดังกล่าว รายละเอียดมีดังนี้\nที่มา : ดัดแปลงจาก สิวะโชติ ศรีสุทธิยากร (2564)"
  },
  {
    "objectID": "ch4.1.html#เรองท-4.1.1-การสำรวจลกษณะของชดขอมล",
    "href": "ch4.1.html#เรองท-4.1.1-การสำรวจลกษณะของชดขอมล",
    "title": "ตอนที่ 4.2 การจัดระเบียบข้อมูล (tidying data)",
    "section": "เรื่องที่ 4.1.1 การสำรวจลักษณะของชุดข้อมูล",
    "text": "เรื่องที่ 4.1.1 การสำรวจลักษณะของชุดข้อมูล\nในหัวข้อนี้จะใช้ชุดข้อมูล gapminder (Bryan, 2017) ที่ประกอบด้วยข้อมูลเกี่ยวกับจำนวนประชากร (pop) ผลิตภัณฑ์มวลรวมในประเทศต่อหัว (gdpPercap) และอายุขัยเฉลี่ยของประชากร (lifeExp) ของประเทศต่าง ๆ เป็นตัวอย่างประกอบการอธิบาย เมื่อผู้วิเคราะห์นำข้อมูล gapminder เข้าสู่โปรแกรมแล้วเรียกดูชุดข้อมูลจะได้ผลลัพธ์ที่มีลักษณะดังนี้\n\n\n       country continent year lifeExp      pop gdpPercap\n1  Afghanistan      Asia 1952  28.801  8425333  779.4453\n2  Afghanistan      Asia 1957  30.332  9240934  820.8530\n3  Afghanistan      Asia 1962  31.997 10267083  853.1007\n4  Afghanistan      Asia 1967  34.020 11537966  836.1971\n5  Afghanistan      Asia 1972  36.088 13079460  739.9811\n6  Afghanistan      Asia 1977  38.438 14880372  786.1134\n7  Afghanistan      Asia 1982  39.854 12881816  978.0114\n8  Afghanistan      Asia 1987  40.822 13867957  852.3959\n9  Afghanistan      Asia 1992  41.674 16317921  649.3414\n10 Afghanistan      Asia 1997  41.763 22227415  635.3414\n\n\n\n\n      country continent year lifeExp      pop gdpPercap\n1695 Zimbabwe    Africa 1962  52.358  4277736  527.2722\n1696 Zimbabwe    Africa 1967  53.995  4995432  569.7951\n1697 Zimbabwe    Africa 1972  55.635  5861135  799.3622\n1698 Zimbabwe    Africa 1977  57.674  6642107  685.5877\n1699 Zimbabwe    Africa 1982  60.363  7636524  788.8550\n1700 Zimbabwe    Africa 1987  62.351  9216418  706.1573\n1701 Zimbabwe    Africa 1992  60.377 10704340  693.4208\n1702 Zimbabwe    Africa 1997  46.809 11404948  792.4500\n1703 Zimbabwe    Africa 2002  39.989 11926563  672.0386\n1704 Zimbabwe    Africa 2007  43.487 12311143  469.7093\n\n\nผลลัพธ์ข้างต้นจะเห็นว่าชุดข้อมูล gapminder ประกอบด้วยตัวแปรทั้งหมด 6 ตัว ได้แก่ ประเทศ (country) ทวีป (continent) ปี (year) อายุขัยเฉลี่ยของประชากร (lifeExp) จำนวนประชากร (pop) และผลิตภัณฑ์มวลรวมต่อหัวภายในประเทศ (gdpPercap) ผู้อ่านจะสังเกตเห็นว่าการเรียนดูข้อมูลทั้งชุดขึ้นมาโดยตรงดังตัวอย่างข้างต้นเป็นวิธีการที่ไม่มีประสิทธิภาพในการสำรวจข้อมูล ทั้งนี้เป็นเพราะในสถานการณ์ที่ข้อมูลมีจำนวนมาก วิธีการดังกล่าวจะให้รายละเอียดของชุดข้อมูลที่มากเกินไปโดยไม่จำเป็น นอกจากนี้ยังมีโอกาสสูงที่จะเกิดปัญหาข้อมูลล้นหน้าจอแสดงผล จนผู้วิเคราะห์ไม่สามารถทราบสภาพของชุดข้อมูลดังกล่าวได้อย่างสะดวก\nในทางปฏิบัติการสำรวจชุดข้อมูลต่าง ๆ ผู้วิเคราะห์จะไม่ได้เรียกดูหรือสำรวจชุดข้อมูลทั้งหมดโดยตรง แต่จะใช้ module ของโปรแกรมวิเคราะห์ข้อมูลช่วยในการสำรวจ module ดังกล่าวจะทำหน้าที่สรุปสารสนเทศที่จำเป็นสำหรับการทำความเข้าใจสภาพของชุดข้อมูลดังกล่าว ได้แก่ การเรียกดูรายการและสถานะของตัวแปรในชุดข้อมูล และการเรียกดูส่วนหัวและส่วนท้ายของชุดข้อมูล รายละเอียดมีดังนี้\n\nการเรียกดูรายการและสถานะของตัวแปร\nวิธีการเรียกดูผลลัพธ์ส่วนนี้จะแตกต่างกันไปขึ้นอยู่กับผู้วิเคราะห์ว่าใช้โปรแกรมใด เช่น ในกรณีที่ใช้ภาษา R อาจเลือกใช้ฟังก์ชัน str() หรือ glimpse() หรือในกรณีที่ใช้ภาษา Python อาจเลือก method info() ภายใต้ pandas library เป็นต้น ผลการวิเคราะห์ด้านล่างแสดงผลลัพธ์ในภาษา R และ Python ดังกล่าว\n\n# R syntax\nlibrary(dplyr)\nglimpse(gapminder)\n\nRows: 1,704\nColumns: 6\n$ country   <fct> \"Afghanistan\", \"Afghanistan\", \"Afghanistan\", \"Afghanistan\", …\n$ continent <fct> Asia, Asia, Asia, Asia, Asia, Asia, Asia, Asia, Asia, Asia, …\n$ year      <int> 1952, 1957, 1962, 1967, 1972, 1977, 1982, 1987, 1992, 1997, …\n$ lifeExp   <dbl> 28.801, 30.332, 31.997, 34.020, 36.088, 38.438, 39.854, 40.8…\n$ pop       <int> 8425333, 9240934, 10267083, 11537966, 13079460, 14880372, 12…\n$ gdpPercap <dbl> 779.4453, 820.8530, 853.1007, 836.1971, 739.9811, 786.1134, …\n\n\n\n# Python syntax\nimport pandas\ngapminder.info()\n\n\n\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 1704 entries, 0 to 1703\nData columns (total 6 columns):\n #   Column     Non-Null Count  Dtype   \n---  ------     --------------  -----   \n 0   country    1704 non-null   category\n 1   continent  1704 non-null   category\n 2   year       1704 non-null   int32   \n 3   lifeExp    1704 non-null   float64 \n 4   pop        1704 non-null   int32   \n 5   gdpPercap  1704 non-null   float64 \ndtypes: category(2), float64(2), int32(2)\nmemory usage: 51.4 KB\n\n\nเมื่อพิจารณาผลลัพธ์จากภาษา R ข้างต้นแสดงให้เห็นว่าในชุดข้อมูล gapminder ประกอบด้วยข้อมูลจำนวน 1,704 หน่วย และมีจำนวน 6 คอลัมน์ โดยมีการรายงานชื่อของตัวแปรในแต่ละคอลัมน์ พร้อมทั้งระบุสถานะของตัวแปรดังกล่าว เช่น ตัวแปร country มีสถานะเป็นตัวแปรประเภทปัจจัย (fct) หรือตัวแปร year มีสถานะเป็นตัวแปรตัวเลขจำนวนเต็ม (int) หรือตัวแปร gdrPercap มีสถานะเป็นตัวแปรประเภทจำนวนจริง (dbl) เป็นต้น ผลลัพธ์นี้ช่วยให้ผู้วิเคราะห์ทราบว่าการนำเข้าข้อมูลดังกล่าว นำเข้ามาอย่างถูกต้องหรือไม่ หากมีตัวแปรใดที่ถูกจัดเก็บอยู่ในสถานะที่ไม่เหมาะสม ผู้วิเคราะห์ก็สามารถดำเนินการแก้ไขปรับเปลี่ยนให้เหมาะสมได้ และเมื่อพิจารณาผลลัพธ์จากภาษา Python พบว่าให้สารสนเทศในลักษณะเดียวกับภาษา R\n\n\nการเรียกดูส่วนหัวและส่วนท้ายของชุดข้อมูล\nวิธีการนี้เป็นวิธีการง่าย ๆ ที่ช่วยให้ผู้วิเคราะห์ทำความเข้าใจโครงสร้างของตารางข้อมูล ขอบเขตของตัวแปร รวมทั้งลักษณะของค่าสังเกตบางส่วนที่จัดเก็บอยู่ในชุดข้อมูล การดำเนินการส่วนนี้ด้วยภาษา R สามารถทำได้โดยใช้ฟังก์ชัน head() และ tail() ดังนี้\n\n# R syntax\nhead(gapminder)\n\n# A tibble: 6 × 6\n  country     continent  year lifeExp      pop gdpPercap\n  <fct>       <fct>     <int>   <dbl>    <int>     <dbl>\n1 Afghanistan Asia       1952    28.8  8425333      779.\n2 Afghanistan Asia       1957    30.3  9240934      821.\n3 Afghanistan Asia       1962    32.0 10267083      853.\n4 Afghanistan Asia       1967    34.0 11537966      836.\n5 Afghanistan Asia       1972    36.1 13079460      740.\n6 Afghanistan Asia       1977    38.4 14880372      786.\n\n\n\n# R syntax\ntail(gapminder)\n\n# A tibble: 6 × 6\n  country  continent  year lifeExp      pop gdpPercap\n  <fct>    <fct>     <int>   <dbl>    <int>     <dbl>\n1 Zimbabwe Africa     1982    60.4  7636524      789.\n2 Zimbabwe Africa     1987    62.4  9216418      706.\n3 Zimbabwe Africa     1992    60.4 10704340      693.\n4 Zimbabwe Africa     1997    46.8 11404948      792.\n5 Zimbabwe Africa     2002    40.0 11926563      672.\n6 Zimbabwe Africa     2007    43.5 12311143      470.\n\n\nส่วนภาษา Python สามารถทำได้โดยใช้ method head() และ tail() ของ pandas libary ดังนี้\n\n# Python syntax\ngapminder.head()\n\n\n\n       country continent  year  lifeExp       pop   gdpPercap\n0  Afghanistan      Asia  1952   28.801   8425333  779.445314\n1  Afghanistan      Asia  1957   30.332   9240934  820.853030\n2  Afghanistan      Asia  1962   31.997  10267083  853.100710\n3  Afghanistan      Asia  1967   34.020  11537966  836.197138\n4  Afghanistan      Asia  1972   36.088  13079460  739.981106\n\n\n\n# Python syntax\ngapminder.tail()\n\n\n\n       country continent  year  lifeExp       pop   gdpPercap\n1699  Zimbabwe    Africa  1987   62.351   9216418  706.157306\n1700  Zimbabwe    Africa  1992   60.377  10704340  693.420786\n1701  Zimbabwe    Africa  1997   46.809  11404948  792.449960\n1702  Zimbabwe    Africa  2002   39.989  11926563  672.038623\n1703  Zimbabwe    Africa  2007   43.487  12311143  469.709298\n\n\nในทางปฏิบัติผลการวิเคราะห์ด้วยวิธีการข้างต้นเพียงพอสำหรับผู้วิเคราะห์ที่จะใช้พิจารณาว่าโครงสร้างการจัดเก็บข้อมูลในชุดข้อมูลที่นำเข้ามามีลักษณะเป็นชุดข้อมูลจัดระเบียบที่เหมาะสำหรับการนำไปวิเคราะห์ข้อมูลตามวัตถุประสงค์แล้วหรือไม่ หากยังไม่เหมาะสมผู้วิเคราะห์จำเป็นต้องแก้ปัญหาในเชิงของโครงสร้างชุดข้อมูลดังกล่าวก่อนที่จะดำเนินการในขั้นตอนต่อไป หัวข้อถัดไปจะกล่าวถึงเครื่องมือหรือวิธีการพื้นฐานที่จำเป็นสำหรับปรับเปลี่ยนลักษณะของชุดข้อมูลให้ตรงกับความต้องการ"
  },
  {
    "objectID": "ch4.1.html#เรองท-4.1.2-การสำรวจลกษณะของชดขอมล",
    "href": "ch4.1.html#เรองท-4.1.2-การสำรวจลกษณะของชดขอมล",
    "title": "ตอนที่ 4.1 การจัดระเบียบข้อมูล (tidying data)",
    "section": "เรื่องที่ 4.1.2 การสำรวจลักษณะของชุดข้อมูล",
    "text": "เรื่องที่ 4.1.2 การสำรวจลักษณะของชุดข้อมูล"
  },
  {
    "objectID": "ch4.1.html#เรองท-4.1.2-การปรบเปลยนลกษณะของชดขอมล-reshaping-dataset",
    "href": "ch4.1.html#เรองท-4.1.2-การปรบเปลยนลกษณะของชดขอมล-reshaping-dataset",
    "title": "ตอนที่ 4.1 การจัดระเบียบข้อมูล (tidying data)",
    "section": "เรื่องที่ 4.1.2 การปรับเปลี่ยนลักษณะของชุดข้อมูล (reshaping dataset)",
    "text": "เรื่องที่ 4.1.2 การปรับเปลี่ยนลักษณะของชุดข้อมูล (reshaping dataset)\nชุดข้อมูลที่ยังไม่เป็นระเบียบมีหลากหลายลักษณะ และโดยมากมักพบเมื่อผู้วิเคราะห์ได้ข้อมูลมาจากแหล่งข้อมูลทุติยภูมิ เช่น ฐานข้อมูล หรือแหล่ง open data ต่าง ๆ ยกตัวอย่างเช่นข้อมูลจำนวนนักเรียนจำแนกตามรายวิชาและช่วงคะแนนผลการสอบ O-NET ระดับชั้น ม.6 ปีการศึกษา 2560 ในตาราง 3 จากตารางจะเห็นว่าถึงแม้ตารางข้อมูลดังกล่าวจะเหมาะในการนำเสนอข้อมูลให้บุคคลทั่วไปทำความเข้าใจได้ง่าย แต่ในเชิงการนำข้อมูลดังกล่าวมาวิเคราะห์ทางสถิติหรือสร้างทัศนภาพข้อมูลแล้วทำได้ยาก การปรับเปลี่ยนรูปแบบให้ตารางข้อมูลดังกล่าวอยู่ในรูปแบบชุดข้อมูลจัดระเบียบจะช่วยให้การดำเนินงานวิเคราะห์ข้อมูลทำได้อย่างมีประสิทธิภาพมากกว่า\nตาราง 3 : จำนวนนักเรียนจำแนกตามรายวิชาและช่วงคะแนนผลการสอบ O-NET ระดับชั้น ม.6 ปีการศึกษา 2560\n\n\n\n\n \n\n\nช่วงคะแนนผลสอบ O-NET\n\n  \n    วิชา \n    < 10 คะแนน \n    10-20 \n    20-30 \n    30-40 \n    40-50 \n    50-60 \n    60-70 \n    70-80 \n    80-90 \n    90-100 \n  \n \n\n  \n    ภาษาไทย \n    205 \n    10918 \n    39277 \n    59459 \n    80767 \n    84977 \n    61052 \n    28544 \n    6623 \n    221 \n  \n  \n    สังคมศึกษา \n    93 \n    11450 \n    119492 \n    155338 \n    64380 \n    17638 \n    3721 \n    447 \n    8 \n    0 \n  \n  \n    ภาษาอังกฤษ \n    2664 \n    120768 \n    146339 \n    48926 \n    21706 \n    12859 \n    8510 \n    5868 \n    3791 \n    1156 \n  \n  \n    คณิตศาสตร์ \n    52250 \n    163221 \n    81737 \n    29113 \n    14854 \n    9772 \n    7302 \n    5524 \n    4516 \n    4564 \n  \n  \n    วิทยาศาสตร์ \n    950 \n    61511 \n    183241 \n    75152 \n    25353 \n    12909 \n    7437 \n    3944 \n    1578 \n    157"
  },
  {
    "objectID": "ch4.1.html#เรองท-4.1.2-การปรบเปลยนลกษณะของชดขอมล-reshaping-data",
    "href": "ch4.1.html#เรองท-4.1.2-การปรบเปลยนลกษณะของชดขอมล-reshaping-data",
    "title": "ตอนที่ 4.2 การจัดระเบียบข้อมูล (tidying data)",
    "section": "เรื่องที่ 4.1.2 การปรับเปลี่ยนลักษณะของชุดข้อมูล (reshaping data)",
    "text": "เรื่องที่ 4.1.2 การปรับเปลี่ยนลักษณะของชุดข้อมูล (reshaping data)\nชุดข้อมูลที่ยังไม่เป็นระเบียบมีหลากหลายลักษณะ และโดยมากมักพบเมื่อผู้วิเคราะห์ได้ข้อมูลมาจากแหล่งข้อมูลทุติยภูมิ เช่น ฐานข้อมูล หรือแหล่ง open data ต่าง ๆ หัวข้อนี้จะกล่าวถึงปัญหาข้อมูลไม่เป็นระเบียบที่มักพบและวิธีการแก้ปัญหาดังกล่าว รายละเอียดมีดังนี้\n\nการปรับเปลี่ยนรูปแบบชุดข้อมูลระหว่างชุดข้อมูลแบบกว้างกับชุดข้อมูลแบบยาว\nชุดข้อมูลอาจจำแนกได้เป็น 2 ลักษณะ ได้แก่ ชุดข้อมูลแบบกว้าง (wide format) และชุดข้อมูลแบบยาว (long format) รายละเอียดมีดังนี้\n\nชุดข้อมูลแบบกว้าง เป็นชุดข้อมูลที่มีการกระจายค่าสังเกตของตัวแปรสำคัญขึ้นไปอยู่บนคอลัมน์ ดังตัวอย่างชุดข้อมูล onet.xlsx ในตาราง 3 โดยส่วนใหญ่ตารางลักษณะนี้เหมาะสำหรับการนำเสนอข้อมูล หรือนำไปใช้สำหรับสร้างทัศนภาพข้อมูลในบางกรณี แต่มักไม่เหมาะที่จะนำไปเข้าสู่โมเดลวิเคราะห์ข้อมูลต่าง ๆ\nชุดข้อมูลแบบยาว เป็นชุดข้อมูลที่มีลักษณะเป็นไปตามเงื่อนไขของชุดข้อมูลจัดระเบียบ โดยมิติด้านคอลัมน์ใช้เก็บข้อมูลของตัวแปรแต่ละตัว ส่วนมิติด้านแถวใช้เก็บข้อมูลของหน่วยข้อมูล ชุดข้อมูล gapminder ข้างต้นเป็นตัวอย่างของชุดข้อมูลแบบยาว ชุดข้อมูลแบบยาวเป็นรูปแบบปกติที่มักพบในฐานข้อมูลแบบ SQL ทั่วไป\n\nตาราง 4.3 : (ตัวอย่างชุดข้อมูลแบบกว้าง) จำนวนนักเรียนจำแนกตามรายวิชาและช่วงคะแนนผลการสอบ O-NET ระดับชั้น ม.6 ปีการศึกษา 2560\n\n\n\n\n \n\n\nช่วงคะแนนผลสอบ O-NET\n\n  \n    วิชา \n    < 10 คะแนน \n    10-20 \n    20-30 \n    30-40 \n    40-50 \n    50-60 \n    60-70 \n    70-80 \n    80-90 \n    90-100 \n  \n \n\n  \n    ภาษาไทย \n    205 \n    10918 \n    39277 \n    59459 \n    80767 \n    84977 \n    61052 \n    28544 \n    6623 \n    221 \n  \n  \n    สังคมศึกษา \n    93 \n    11450 \n    119492 \n    155338 \n    64380 \n    17638 \n    3721 \n    447 \n    8 \n    0 \n  \n  \n    ภาษาอังกฤษ \n    2664 \n    120768 \n    146339 \n    48926 \n    21706 \n    12859 \n    8510 \n    5868 \n    3791 \n    1156 \n  \n  \n    คณิตศาสตร์ \n    52250 \n    163221 \n    81737 \n    29113 \n    14854 \n    9772 \n    7302 \n    5524 \n    4516 \n    4564 \n  \n  \n    วิทยาศาสตร์ \n    950 \n    61511 \n    183241 \n    75152 \n    25353 \n    12909 \n    7437 \n    3944 \n    1578 \n    157 \n  \n\n\n\n\n\nในทางปฏิบัติผู้วิเคราะห์มีโอกาสพบชุดข้อมูลทั้งสองลักษณะ การปรับเปลี่ยนรูปแบบของชุดข้อมูลดังกล่าว จากชุดข้อมูลแบบกว้างให้เป็นแบบยาว และจากให้อยู่ในรูปแบบยาวให้เป็นรูปแบบกว้าง จึงเป็นทักษะพื้นฐานที่จำเป็นสำหรับนักวิทยาการข้อมูล ในทำนองเดียวกับการสำรวจโครงสร้างชุดข้อมูล วิธีการปรับเปลี่ยนรูปแบบตารางข้อมูลมีความแตกต่างกันขึ้นอยู่กับโปรแกรมวิเคราะห์ข้อมูลที่เลือกใช้\nในกรณีที่ใช้ภาษา R ผู้วิเคราะห์สามารถดำเนินการได้หลายแบบ วิธีการหนึ่งที่สามารถทำได้สะดวกคือการใช้เครื่องมือใน package-tidyr พิจารณาชุดข้อมูล จำนวนผู้สำเร็จการศึกษา.xlsx ที่จัดเก็บอยู่ในชุดข้อมูล wide_data ด้านล่าง จะเห็นว่าเป็นชุดข้อมูลรูปแบบกว้างที่แสดงจำนวนผู้สำเร็จการศึกษาในระดับ ปวช. และ ปวส. จำแนกตามสาขาวิชา\n\n\n# A tibble: 9 × 4\n  `สาขาวิชา`               รวม  ปวช.  ปวส.\n  <chr>                 <dbl> <dbl> <dbl>\n1 อุตสาหกรรม            123268 65724 57544\n2 พาณิชยกรรม /บริหารธุรกิจ 106556 55257 51299\n3 อุตสาหกรรมการท่องเที่ยว   10779  6696  4083\n4 คหกรรม                 7171  4101  3070\n5 เกษตรกรรม              6026  2926  3100\n6 ศิลปกรรม                5175  4163  1012\n7 เทคโนโลยีสารสนเทศฯ      3702  1758  1944\n8 ประมง                   576    91   485\n9 อุตสาหกรรมสิ่งทอ            87    39    48\n\n\nหากผู้วิเคราะห์ต้องการปรับรูปแบบของชุดข้อมูล wide_data ข้างต้นให้เป็นชุดข้อมูลแบบยาว สามารถทำได้โดยใช้ฟังก์ชัน pivot_longer() โดยกำหนดอารกิวเมนท์ data เพื่อระบุชุดข้อมูลที่ต้องการปรับให้เป็นรูปแบบยาว cols เพื่อกำหนดคอลัมน์ในชุดข้อมูลแบบกว้างที่จะยุบรวมไว้ภายในคอลัมน์เดียวกัน names_to ใช้กำหนดชื่อคอลัมน์ใหม่สำหรับบรรจุคอลัมน์ที่ยุบรวมมาจากชุดข้อมูลแบบกว้างเดิม และ values_to ใช้กำหนดชื่อคอลัมน์สำหรับจัดเก็บค่าสังเกตที่อยู่ภายใต้คอลัมน์ที่ยุบรวมมา ตัวอย่างด้านล่างแสดงการปรับรูปแบบของชุดข้อมูล จำนวนผู้สำเร็จการศึกษา.xlsx ที่จัดเก็บอยู่ในชุดข้อมูล wide_data ให้เป็นชุดข้อมูลแบบยาว\n\n# R syntax\nlong_data<-pivot_longer(data=wide_data, \n                        cols=2:4, \n                        names_to = \"category\", \n                        values_to = \"number\")\nlong_data%>%data.frame()\n\n               สาขาว.ชา category number\n1             อุตสาหกรรม      รวม 123268\n2             อุตสาหกรรม     ปวช.  65724\n3             อุตสาหกรรม     ปวส.  57544\n4  พาณิชยกรรม /บริหารธุรกิจ      รวม 106556\n5  พาณิชยกรรม /บริหารธุรกิจ     ปวช.  55257\n6  พาณิชยกรรม /บริหารธุรกิจ     ปวส.  51299\n7   อุตสาหกรรมการท่องเที่ยว      รวม  10779\n8   อุตสาหกรรมการท่องเที่ยว     ปวช.   6696\n9   อุตสาหกรรมการท่องเที่ยว     ปวส.   4083\n10               คหกรรม      รวม   7171\n11               คหกรรม     ปวช.   4101\n12               คหกรรม     ปวส.   3070\n13            เกษตรกรรม      รวม   6026\n14            เกษตรกรรม     ปวช.   2926\n15            เกษตรกรรม     ปวส.   3100\n16              ศิลปกรรม      รวม   5175\n17              ศิลปกรรม     ปวช.   4163\n18              ศิลปกรรม     ปวส.   1012\n19    เทคโนโลยีสารสนเทศฯ      รวม   3702\n20    เทคโนโลยีสารสนเทศฯ     ปวช.   1758\n21    เทคโนโลยีสารสนเทศฯ     ปวส.   1944\n22                ประมง      รวม    576\n23                ประมง     ปวช.     91\n24                ประมง     ปวส.    485\n25        อุตสาหกรรมสิ่งทอ      รวม     87\n26        อุตสาหกรรมสิ่งทอ     ปวช.     39\n27        อุตสาหกรรมสิ่งทอ     ปวส.     48\n\n\nในทางกลับกันหากมีชุดข้อมูลแบบยาว และผู้วิเคราะห์ต้องการปรับเปลี่ยนให้เป็นชุดข้อมูลแบบกว้างสามารถทำได้ด้วยฟังก์ชัน pivot_wider() ฟังก์ชันนี้มีอาร์กิวเมนท์จำเป็นที่จะต้องระบุ 3 ตัวได้แก่ data เพื่อระบุชุดข้อมูลที่ต้องการปรับให้เป็นรูปแบบกว้าง names_from เพื่อระบุว่าจะนำค่าสังเกตจากคอลัมน์ใดขยายไปเป็นหัวคอลัมน์ของตารางใหม่ และ values_from ใช้ระบุว่าจะเอาข้อมูล/ค่าสังเกตจากคอลัมน์ใดไปอยู่ภายใต้คอลัมน์ใหม่ที่ขยายจากการระบุใน names_from ตัวอย่างด้านล่างแสดงการเปลี่ยนชุดข้อมูล long_data ในข้างต้นให้กลับเป็นชุดข้อมูลแบบกว้างเหมือนเดิม\n\n# R syntax\npivot_wider(data = long_data,\n            names_from = \"category\",\n            values_from = \"number\")\n\n# A tibble: 9 × 4\n  `สาขาวิชา`               รวม  ปวช.  ปวส.\n  <chr>                 <dbl> <dbl> <dbl>\n1 อุตสาหกรรม            123268 65724 57544\n2 พาณิชยกรรม /บริหารธุรกิจ 106556 55257 51299\n3 อุตสาหกรรมการท่องเที่ยว   10779  6696  4083\n4 คหกรรม                 7171  4101  3070\n5 เกษตรกรรม              6026  2926  3100\n6 ศิลปกรรม                5175  4163  1012\n7 เทคโนโลยีสารสนเทศฯ      3702  1758  1944\n8 ประมง                   576    91   485\n9 อุตสาหกรรมสิ่งทอ            87    39    48\n\n\nถ้าผู้วิเคราะห์ต้องการศึกษารายละเอียดเพิ่มเติมเกี่ยวกับฟังก์ชันต่าง ๆ ของโปรแกรม R สามารถเรียกดูคู่มือของฟังก์ชันดังกล่าวได้โดยใช้คำสั่ง ?XXX หรือ help(XXX) เช่น หากต้องการรายละเอียดของฟังก์ชัน pivot_longer() ให้พิมพ์คำสั่ง ?pivot_longer() หรือ help(pivot_longer() เป็นต้น\nในกรณีที่ใช้ภาษา Python การปรับเปลี่ยนชุดข้อมูลแบบกว้างให้เป็นแบบยาวสามารถทำได้โดยใช้ฟังก์ชัน melt() ภายใต้ pandas library ฟังก์ชัน melt() มีพารามิเตอร์ควบคุมการทำงานของฟังก์ชันที่สำคัญ 3 ตัวได้แก่ frame ใช้ระบุชุดข้อมูล (pandas.DataFrame) ที่ต้องการดำเนินงาน id_vars ใช้ระบุคอลัมน์หรือตัวแปรที่เป็น id ของหน่วยข้อมูล และ value_vars ทำงานเหมือนกับอาร์กิวเมนท์ names_to ของ pivot_longer() ในโปรแกรม R ตัวอย่างด้านล่างแสดงการปรับรูปแบบชุดข้อมูล จำนวนผู้สำเร็จการศึกษา.xlsx ที่เป็นชุดข้อมูลแบบกว้างให้เป็นชุดข้อมูลแบบยาวด้วยฟังก์ชันดังกล่าว โดยในตัวอย่างชุดข้อมูลดังกล่าวจัดเก็บอยู่ในตัวแปรชื่อ wide_data\n\n\n\n\n# Python syntax\nimport pandas as pd\nlong_data = pd.melt(frame = wide_data, \n                    id_vars=['สาขาวิชา'],\n                    value_vars=['รวม','ปวช.', 'ปวส.'])\nlong_data\n\n                    สาขาวิชา variable     value\n0                 อุตสาหกรรม      รวม  123268.0\n1   พาณิชยกรรม /บริหารธุรกิจ      รวม  106556.0\n2    อุตสาหกรรมการท่องเที่ยว      รวม   10779.0\n3                     คหกรรม      รวม    7171.0\n4                  เกษตรกรรม      รวม    6026.0\n5                   ศิลปกรรม      รวม    5175.0\n6         เทคโนโลยีสารสนเทศฯ      รวม    3702.0\n7                      ประมง      รวม     576.0\n8           อุตสาหกรรมสิ่งทอ      รวม      87.0\n9                 อุตสาหกรรม     ปวช.   65724.0\n10  พาณิชยกรรม /บริหารธุรกิจ     ปวช.   55257.0\n11   อุตสาหกรรมการท่องเที่ยว     ปวช.    6696.0\n12                    คหกรรม     ปวช.    4101.0\n13                 เกษตรกรรม     ปวช.    2926.0\n14                  ศิลปกรรม     ปวช.    4163.0\n15        เทคโนโลยีสารสนเทศฯ     ปวช.    1758.0\n16                     ประมง     ปวช.      91.0\n17          อุตสาหกรรมสิ่งทอ     ปวช.      39.0\n18                อุตสาหกรรม     ปวส.   57544.0\n19  พาณิชยกรรม /บริหารธุรกิจ     ปวส.   51299.0\n20   อุตสาหกรรมการท่องเที่ยว     ปวส.    4083.0\n21                    คหกรรม     ปวส.    3070.0\n22                 เกษตรกรรม     ปวส.    3100.0\n23                  ศิลปกรรม     ปวส.    1012.0\n24        เทคโนโลยีสารสนเทศฯ     ปวส.    1944.0\n25                     ประมง     ปวส.     485.0\n26          อุตสาหกรรมสิ่งทอ     ปวส.      48.0\n\n\nใน Python ผู้อ่านสามารถเรียกดูรายละเอียดของฟังก์ชันที่ต้องการใช้งานโดยพิมพ์คำส่ง ?XXX หรือ help(XXXX) เหมือนกับภาษา R เช่นในกรณีนี้ต้องการรายละเอียดการใช้งานฟังก์ชัน melt()ให้พิมพ์คำสั่ง help(pd.melt)\nในทางกลับกันหากต้องการปรับเปลี่ยนรูปแบบของตารางแบบยาวให้เป็นแบบกว้างสามารถทำได้ด้วยฟังก์ชัน pivot() ดังตัวอย่างต่อไปนี้\n\npd.pivot(data= long_data, \n                    index=['สาขาวิชา'],\n                    columns=['variable'],\n                    values=['value'])\n\n                            value                   \nvariable                     ปวช.     ปวส.       รวม\nสาขาวิชา                                            \nคหกรรม                     4101.0   3070.0    7171.0\nประมง                        91.0    485.0     576.0\nพาณิชยกรรม /บริหารธุรกิจ  55257.0  51299.0  106556.0\nศิลปกรรม                   4163.0   1012.0    5175.0\nอุตสาหกรรม                65724.0  57544.0  123268.0\nอุตสาหกรรมการท่องเที่ยว    6696.0   4083.0   10779.0\nอุตสาหกรรมสิ่งทอ             39.0     48.0      87.0\nเกษตรกรรม                  2926.0   3100.0    6026.0\nเทคโนโลยีสารสนเทศฯ         1758.0   1944.0    3702.0\n\n\nอีกวิธีการหนึ่งในการปรับรูปแบบตารางระหว่างตารางรูปแบบกว้างกับยาวด้วยภาษา Python คือการใช้ library datar ที่เป็น API ของ package-dplyr และ tidyr ที่ใช้จัดกระทำและจัดระเบียบชุดข้อมูลใน R กล่าวคือ ผู้วิเคราะห์สามารถใช้ฟังก์ชัน pivot_longer() และ pivot_wider() รวมทั้งฟังก์ชันอื่น ๆ ที่เกี่ยวข้องใน Python ได้เหมือนกับที่ดำเนินการในภาษา R ก่อนการใช้งาน library ผู้วิเคราะห์จำเป็นต้องดาวน์โหลดและติดตั้ง library ลงในเครื่องก่อน โดยภายในหน้าต่าง terminal ให้พิมพ์คำสั่ง pip install -U datar รายละเอียดเพิ่มเติมสามารถศึกษาได้จาก https://github.com/pwwang/datar\n\n\nการแยกคอลัมน์\nในบางกรณีชุดข้อมูลที่นำใช้ในการวิเคราะห์อาจมีบางคอลัมน์ที่จัดเก็บค่าสังเกตของหลายตัวแปรอยู่ภายในเซลล์เดียวกัน ดังตัวอย่างในตาราง 4 (ดาวน์โหลดได้จาก คะแนนเชาวน์ปัญญาของนักเรียน.xlsx (สิวะโชติ ศรีสุทธิยากร, 2564)) จากตารางจะเห็นว่าคอลัมน์ที่ 3 (gender.age) เป็นคอลัมน์ที่จัดเก็บค่าสังเกตของตัวแปรจำนวน 2 ตัวร่วมกัน ได้แก่ เพศ และ อายุ ของนักเรียน ซึ่งละเมิดเงื่อนไขของชุดข้อมูลจัดระเบียบ การแก้ปัญหาจึงจำเป็นต้องแยกค่าสังเกตในคอลัมน์ดังกล่าวออกจากกันให้เป็น 2 คอลัมน์ได้แก่ คอลัมน์ของเพศ และอายุ ตามลำดับ\nตาราง 4.4 คะแนนเชาว์ปัญญาของนักเรียน\n\n\n\n\n \n  \n    id \n    จังหวัด \n    gender.age \n    IQ \n  \n \n\n  \n    1 \n    กรุงเทพฯ \n    ชาย/14 \n    80 \n  \n  \n    2 \n    กรุงเทพฯ \n    ชาย/24 \n    101 \n  \n  \n    3 \n    กรุงเทพฯ \n    ชาย/25 \n    105 \n  \n  \n    4 \n    กรุงเทพฯ \n    หญิง/54 \n    99 \n  \n  \n    5 \n    กรุงเทพฯ \n    ชาย/18 \n    100 \n  \n  \n    6 \n    กรุงเทพฯ \n    หญิง/65 \n    105 \n  \n  \n    7 \n    เชียงใหม่ \n    ชาย/14 \n    90 \n  \n  \n    8 \n    เชียงใหม่ \n    หญิง/15 \n    110 \n  \n  \n    9 \n    เชียงใหม่ \n    ชาย/37 \n    103 \n  \n  \n    10 \n    เชียงใหม่ \n    หญิง/28 \n    108 \n  \n  \n    11 \n    เชียงใหม่ \n    ชาย/44 \n    98 \n  \n  \n    12 \n    เชียงใหม่ \n    หญิง/34 \n    106 \n  \n\n\n\n\n\nที่มา: สิวะโชติ ศรีสุทธิยากร (2564)\nการแยกคอลัมน์ในชุดข้อมูลดังกล่าวด้วยภาษา R สามารถทำได้หลายวิธีการ ใน package-tidyr มีฟังก์ชัน seperate() ที่สามารถใช้ดำเนินการดังกล่าวได้ ฟังก์ชัน separate() มีอาร์กิวเมนท์สำคัญจำนวน 4 ตัวได้แก่ data ใช้สำหรับระบุชุดข้อมูลที่ต้องการแยกคอลัมน์ col ใช้ระบุคอลัมน์ที่ต้องการแยกค่าสังเกตออกจากกัน into ใช้กำหนดชื่อของคอลัมน์ใหม่ที่ภายหลังจากแยกค่าสังเกตของคอลัมน์เดิมออกจากกัน และ sep ใช้ระบุลลักษณะของตัวคั่น (seperator) ที่ใช้สำหรับแยกข้อมูล การกำหนดตัวคั่นนี้สามารถทำได้ 3 ลักษณะ ได้แก่ การกำหนดด้วยตัวอักษร การกำหนดด้วยตำแหน่งของตัวคั่น และการกำหนดด้วยนิพจน์ปกติ (regular expression) รายละเอียดสามารถศึกษาได้จาก สิวะโชติ ศรีสุทธิยากร (2564)\nตัวอย่างด้านล่างแสดงการใช้ฟังก์ชัน separate() เพื่อแยกค่าสังเกตในคอลัมน์ gender.age ออกเป็นคอลัมน์ gender และ age ตามลำดับ จากตัวอย่างจะเห็นว่าในคอลัมน์ gender.age มีการใช้ตัวคั่นข้อมูลเป็น / จึงกำหนดอาร์กิวเมนท์ sep=\"/\"\n\niq_sep<-separate(data = iq,\n         col = \"gender.age\",\n         into = c(\"gender\",\"age\"),\n         sep=\"/\")\niq_sep\n\n# A tibble: 12 × 5\n      id `จังหวัด` gender age      IQ\n   <dbl> <chr>   <chr>  <chr> <dbl>\n 1     1 กรุงเทพฯ ชาย    14       80\n 2     2 กรุงเทพฯ ชาย    24      101\n 3     3 กรุงเทพฯ ชาย    25      105\n 4     4 กรุงเทพฯ หญิง    54       99\n 5     5 กรุงเทพฯ ชาย    18      100\n 6     6 กรุงเทพฯ หญิง    65      105\n 7     7 เชียงใหม่ ชาย    14       90\n 8     8 เชียงใหม่ หญิง    15      110\n 9     9 เชียงใหม่ ชาย    37      103\n10    10 เชียงใหม่ หญิง    28      108\n11    11 เชียงใหม่ ชาย    44       98\n12    12 เชียงใหม่ หญิง    34      106\n\n\nในกรณีที่ใช้ภาษา Python สามารถดำเนินการได้โดยใช้ฟังก์ชัน str.split() ภายใต้ pandas library โดยฟังก์ชันดังกล่าวมีพารามิเตอร์ที่สำคัญ 1 ตัวได้แก่ separator ที่ใช้สำหรับระบุลักษณะของตัวคั่นข้อมูลในคอลัมน์ที่ต้องการแยก ตัวอย่างการใช้ฟังก์ชัน str.split() เพื่อแยกคอลัมน์ gender.age ในชุดข้อมูล iq เป็นดังนี้\n\n\n\n\niq[\"gender\"] = iq[\"gender.age\"].str.split(\"/\", expand=True)[0]\niq[\"age\"] = iq[\"gender.age\"].str.split(\"/\", expand=True)[1]\niq\n\n      id    จังหวัด gender.age     IQ gender age\n0    1.0   กรุงเทพฯ     ชาย/14   80.0    ชาย  14\n1    2.0   กรุงเทพฯ     ชาย/24  101.0    ชาย  24\n2    3.0   กรุงเทพฯ     ชาย/25  105.0    ชาย  25\n3    4.0   กรุงเทพฯ    หญิง/54   99.0   หญิง  54\n4    5.0   กรุงเทพฯ     ชาย/18  100.0    ชาย  18\n5    6.0   กรุงเทพฯ    หญิง/65  105.0   หญิง  65\n6    7.0  เชียงใหม่     ชาย/14   90.0    ชาย  14\n7    8.0  เชียงใหม่    หญิง/15  110.0   หญิง  15\n8    9.0  เชียงใหม่     ชาย/37  103.0    ชาย  37\n9   10.0  เชียงใหม่    หญิง/28  108.0   หญิง  28\n10  11.0  เชียงใหม่     ชาย/44   98.0    ชาย  44\n11  12.0  เชียงใหม่    หญิง/34  106.0   หญิง  34\n\n\n\n\nการยุบรวมคอลัมน์\nอีกกรณีคือเป็นไปได้ที่ข้อมูลของตัวแปรเดียวกันอาจถูกเก็บอยู่ในหลายคอลัมน์ เช่นข้อมูลคำนำหน้า ชื่อ และนามสกุล หรือ ข้อมูลเวลา (วัน เดือน ปี) ตาราง 5 แสดงข้อมูลจากชุดข้อมูล login.xlsx ที่มีปัญหาดังกล่าว จากตารางจะเห็นว่ามีการจัดเก็บคำนำหน้า และชื่อของผู้เข้าระบบอยู่คนละคอลัมน์กัน\nตาราง 5 จำนวนครั้งของการเข้าระบบ\n\n\n\n\n \n  \n    คำนำหน้า \n    ชื่อ \n    จำนวนครั้งที่เข้าระบบ \n  \n \n\n  \n    นาย \n    บุญถึง \n    14 \n  \n  \n    นางสาว \n    บุญเติม \n    20 \n  \n  \n    นาย \n    บุญมาก \n    17 \n  \n  \n    นางสาว \n    บุญมี \n    18 \n  \n  \n    นาย \n    บุญหนัก \n    6 \n  \n  \n    นาง \n    บุญอยู่ \n    18 \n  \n  \n    นางสาว \n    บุญมา \n    18 \n  \n  \n    นาย \n    บุญทับ \n    14 \n  \n  \n    นาง \n    บุญชอบ \n    18 \n  \n\n\n\n\n\nการยุบรวมคอลัมน์ทั้งสองเข้าด้วยกันในภาษา R สามารถทำได้ด้วยฟังก์ชัน unite() ของ package-tidyr ฟังก์ชันนี้มีอาร์กิวเมนท์ที่สำคัญได้แก่ data ใช้ระบุชุดข้อมูลที่ต้องการดำเนินงาน col ใช้ระบุชื่อของคอลัมน์ใหม่ภายหลังจากยุบรวมคอลัมน์เดิมเข้าด้วยกัน และ sep ใช้สำหรับระบุตัวคั่นสำหรับคั่นข้อมูลที่ยุบรวมกัน (ค่าเริ่มต้นของอาร์กิวเมนท์นี้กำหนดให้ใช้สัญลักษณ์ underscore sep=\"_\")\nตัวอย่างต่อไปนี้แสดงการใช้ฟังก์ชัน unite() ดังกล่าว สมมุติว่า login.xlsx ในข้างต้นถูกจัดเก็บในโปรแกรม R โดยเก็บไว้ในตัวแปร login ผู้วิเคราะห์สามารถยุบรวมคอลัมน์ คำนำหน้า และ ชื่อ เข้าด้วยกัน โดยใช้ฟังก์ชัน unite() ได้ดังนี้\n\nlogin_united<-unite(login, \n      col=\"name\",\n      \"คำนำหน้า\", \"ชื่อ\")\nlogin_united\n\n# A tibble: 9 × 2\n  name         `จำนวนครั้งที่เข้าระบบ`\n  <chr>                     <dbl>\n1 นาย_บุญถึง                     14\n2 นางสาว_บุญเติม                 20\n3 นาย_บุญมาก                    17\n4 นางสาว_บุญมี                   18\n5 นาย_บุญหนัก                     6\n6 นาง_บุญอยู่                     18\n7 นางสาว_บุญมา                  18\n8 นาย_บุญทับ                     14\n9 นาง_บุญชอบ                    18\n\n\nสำหรับภาษา Python การยุบรวมคอลัมน์ตั้งแต่ 2 คอลัมน์ขึ้นไปเข้าด้วยกันทำได้ง่ายมากโดยการใช้ตัวดำเนินการเชื่อม (concatenate operator) ดังตัวอย่างต่อไปนี้\n\n\n\n\nlogin[\"name\"] = login[\"คำนำหน้า\"] + login[\"ชื่อ\"]\nlogin\n\n  คำนำหน้า     ชื่อ  จำนวนครั้งที่เข้าระบบ           name\n0      นาย   บุญถึง                   14.0      นายบุญถึง\n1   นางสาว  บุญเติม                   20.0  นางสาวบุญเติม\n2      นาย   บุญมาก                   17.0      นายบุญมาก\n3   นางสาว    บุญมี                   18.0    นางสาวบุญมี\n4      นาย  บุญหนัก                    6.0     นายบุญหนัก\n5      นาง  บุญอยู่                   18.0     นางบุญอยู่\n6   นางสาว    บุญมา                   18.0    นางสาวบุญมา\n7      นาย   บุญทับ                   14.0      นายบุญทับ\n8      นาง   บุญชอบ                   18.0      นางบุญชอบ\n\n\n\n\nการรวมชุดข้อมูลตามแถว (rows combined)\nงานทางด้านสถิติและวิทยาการข้อมูลในปัจจุบันบ่อยครั้งข้อมูลสำคัญมักมาจากหลายแหล่งข้อมูล เช่น อาจได้มาจากการเก็บเกี่ยวข้อมูลจากเว็ปไซด์ส่วนนึง (web scraping) และส่วนที่เหลืออาจเป็นข้อมูลที่ได้จากฐานข้อมูลเปิดต่าง ๆ หากชุดข้อมูลดังกล่าวเป็นข้อมูลของหน่วยการวิเคราะห์เดียวกัน หรือสามารถจัดกระทำให้เป็นข้อมูลของหน่วยการวิเคราะห์เดียวกันได้แล้ว การจะนำข้อมูลดังกล่าวมาวิเคราะห์ร่วมกันจำเป็นที่จะต้องยุบรวมชุดข้อมูลดังกล่าวเข้าด้วยกันก่อน การยุบรวมชุดข้อมูลอาจจำแนกได้เป็น 2 ลักษณะ ได้แก่ การยุบรวมข้อมูลตามแถว (rows combined) และการยุบรวมข้อมูลตามคอลัมน์ (columns combined) หัวข้อนี้จะกล่าวถึงการยุบรวมข้อมูลตามแถว รายละเอียดมีดังนี้\nรูป 4.2 แสดงลักษณะของการยุบรวมข้อมูลตามแถว จากรูปจะเห็นว่าเริ่มต้นมีชุดข้อมูลจากแหล่งข้อมูลที่แตกต่างกันจำนวน 3 แหล่ง ได้แก่ A, B และ C โดยที่ชุดข้อมูลจากแต่ละแหล่งดังกล่าวเก็บข้อมูลของตัวแปรเดียวกัน และมีจำนวนคอลัมน์เท่ากัน แต่จะสังเกตเห็นว่าแต่ละชุดข้อมูลมีหน่วยข้อมูลที่แตกต่างกัน การยุบรวมชุดข้อมูลทั้ง 3 ตามแถวจะให้ผลลัพธ์เป็นชุดข้อมูลที่ใหญ่ขึ้นจากเดิม โดยมีหน่วยข้อมูลทั้งหมดจากทั้ง 3 ชุดข้อมูลข้างต้นมาจัดเก็บอยู่ภายใต้ชุดข้อมูลใหม่ขนาด 9 x 3\n\n\n\nรูป 4.2 ตัวอย่างแสดงลักษณะการยุบรวมชุดข้อมูลตามแถว (row combined)\n\n\nที่มา : สิวะโชติ ศรีสุทธิยากร (2564)\nการรวมชุดข้อมูลตามแถวด้วยภาษา R สามารถทำได้หลายวิธีการ ฟังก์ชัน bind_rows() ของ package-dplyr สามารถใช้เพื่อรวมชุดข้อมูลดังกล่าวได้ อาร์กิวเมนท์ของฟังก์ชัน bind_rows() ได้แก่ชุดข้อมูลแบบ Dataframe ที่ต้องการนำมารวมกันตามแถว เงื่อนไขของการใช้ฟังก์ชันนี้คือชุดข้อมูลที่จะนำมารวมกันจำเป็นต้องมีจำนวนคอลัมน์เท่ากัน แต่ละคอลัมน์จัดเก็บข้อมูลของตัวแปรเดียวกันและมีการจัดเรียงลำดับของตัวแปรที่เหมือนกัน\nตัวอย่างต่อไปนี้แสดงการยุบรวมข้อมูลตามแถวด้วยฟังก์ชัน bind_rows() สมมุติว่าผู้วิเคราะห์มีไฟล์ข้อมูลของกลุ่มเป้าหมายเดียวกันจำนวน 4 ไฟล์ ที่สามารถดาวน์โหลดไฟล์ดังกล่าวได้จาก https://bit.ly/2AuQgqr (สิวะโชติ ศรีสุทธิยากร, 2564) ไฟล์ข้อมูลทั้ง 4 ประกอบด้วย file1.xlsx, file2.xlsx, file3.xlsx และ file4.xlsx ตามลำดับ โดยที่แต่ละไฟล์จัดเก็บข้อมูลของนักเรียนไฟล์ละ 5 คน ตารางด้านล่างแสดงข้อมูลที่จัดเก็บอยู่ในไฟล์ file1.xlsx\n\n\n# A tibble: 5 × 5\n  student.name Lecture.pre PBL.pre Lecture.post PBL.post\n  <chr>              <dbl>   <dbl>        <dbl>    <dbl>\n1 บุญมี                   20      NA           45       NA\n2 บุญมาก                 16      NA           34       NA\n3 บุญเกิน                 NA      18           NA       67\n4 บุญถึง                  NA      25           NA       93\n5 บุญธรรม                13      NA           50       NA\n\n\nเมื่อผู้อ่านได้ดำเนินการสำรวจไฟล์ข้อมูลทั้ง 4 แล้วจะพบว่าโครงการการจัดเก็บข้อมูลของทั้ง 4 ไฟล์มีลักษณะเหมือนกัน ชุดข้อมูลทั้ง 4 จึงสามารถยุบรวมกันตามแถวได้โดยใช้ฟังก์ชัน rbind() ในข้างต้น ตัวอย่างนี้ผู้เขียนได้นำเข้าข้อมูลจากทั้ง 4 ไฟล์และจัดเก็บอยู่ในชุดข้อมูลชื่อ dat1, dat2, dat3 และ dat4 ตามลำดับ การเขียนคำสั่งเพิ่มยุบรวมชุดข้อมูลดังกล่าวตามแถวเป็นดังนี้\n\ndat_rbind <-bind_rows(dat1, dat2, dat3, dat4)\ndat_rbind\n\n# A tibble: 20 × 5\n   student.name Lecture.pre PBL.pre Lecture.post PBL.post\n   <chr>              <dbl>   <dbl>        <dbl>    <dbl>\n 1 บุญมี                   20      NA           45       NA\n 2 บุญมาก                 16      NA           34       NA\n 3 บุญเกิน                 NA      18           NA       67\n 4 บุญถึง                  NA      25           NA       93\n 5 บุญธรรม                13      NA           50       NA\n 6 บุญใหญ่                 NA      17           NA       71\n 7 บุญหนัก                 14      NA           48       NA\n 8 บุญมา                  NA      20           NA       83\n 9 บุญเยอะ                NA      28           NA       75\n10 บุญแฝง                 NA      21           NA       73\n11 บุญดี                   22      NA           32       NA\n12 บุญแรง                 NA      17           NA       68\n13 บุญดัง                  14      NA           70       NA\n14 บุญจริง                 15      NA           64       NA\n15 บุญเติม                 19      NA           55       NA\n16 บุญรอด                 NA      15           NA       82\n17 บุญชอบ                 18      NA           59       NA\n18 บุญผ่อง                 NA      12           NA       68\n19 บุญสืบ                   8      NA           62       NA\n20 บุญเหลือ                NA      25           NA       87\n\n\nสำหรับภาษา Python การยุบรวมชุดข้อมูลตามแถวสามารถดำเนินการได้หลายวิธีการเช่นเดียวกับภาษา R ฟังก์ชันหนึ่งที่สามารถทำได้คือฟังก์ชัน append() ภายใต้ pandas library ตัวอย่างต่อไปนี้แสดงการยุบรวมชุดข้อมูลใน file1.xlsx, file2.xlsx, file3.xlsx และ file4.xlsx ตามแถว ทั้งนี้ในตัวอย่างดังกล่าวได้จัดเก็บข้อมูลทั้ง 4 ไว้ในตัวแปรได้แก่ dat1, dat2, …, dat4 เช่นเดียวกับตัวอย่างของภาษา R ผลลัพธ์ด้านล่างแสดงตัวอย่างของชุดข้อมูล dat1 ที่เก็บอยู่ใน Python\n\n\n\n\ndat1\n\n  student.name  Lecture.pre  PBL.pre  Lecture.post  PBL.post\n0        บุญมี         20.0      NaN          45.0       NaN\n1       บุญมาก         16.0      NaN          34.0       NaN\n2      บุญเกิน          NaN     18.0           NaN      67.0\n3       บุญถึง          NaN     25.0           NaN      93.0\n4      บุญธรรม         13.0      NaN          50.0       NaN\n\ndat1.info()\n\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 5 entries, 0 to 4\nData columns (total 5 columns):\n #   Column        Non-Null Count  Dtype  \n---  ------        --------------  -----  \n 0   student.name  5 non-null      object \n 1   Lecture.pre   3 non-null      float64\n 2   PBL.pre       2 non-null      float64\n 3   Lecture.post  3 non-null      float64\n 4   PBL.post      2 non-null      float64\ndtypes: float64(4), object(1)\nmemory usage: 328.0+ bytes\n\n\nการยุบรวมชุดข้อมูลทั้ง 4 ตามแถวด้วยฟังก์ชัน append() สามารถทำได้ดังนี้\n\nimport pandas as pd\ndat_rbind = dat1.append(dat2)\ndat_rbind\n\n  student.name  Lecture.pre  PBL.pre  Lecture.post  PBL.post\n0        บุญมี         20.0      NaN          45.0       NaN\n1       บุญมาก         16.0      NaN          34.0       NaN\n2      บุญเกิน          NaN     18.0           NaN      67.0\n3       บุญถึง          NaN     25.0           NaN      93.0\n4      บุญธรรม         13.0      NaN          50.0       NaN\n0      บุญใหญ่          NaN     17.0           NaN      71.0\n1      บุญหนัก         14.0      NaN          48.0       NaN\n2        บุญมา          NaN     20.0           NaN      83.0\n3      บุญเยอะ          NaN     28.0           NaN      75.0\n4       บุญแฝง          NaN     21.0           NaN      73.0\n\n\nในกรณีที่มีชุดข้อมูลมากกว่า 2 ชุด ที่ต้องการยุบรวมเข้าด้วยกันตามแถว สามารถใช้ฟังก์ชัน append() เรียงต่อกกันได้ดังตัวอย่างต่อไปนี้\n\ndat_rbind = dat1.append(dat2).append(dat3).append(dat4)\ndat_rbind\n\n  student.name  Lecture.pre  PBL.pre  Lecture.post  PBL.post\n0        บุญมี         20.0      NaN          45.0       NaN\n1       บุญมาก         16.0      NaN          34.0       NaN\n2      บุญเกิน          NaN     18.0           NaN      67.0\n3       บุญถึง          NaN     25.0           NaN      93.0\n4      บุญธรรม         13.0      NaN          50.0       NaN\n0      บุญใหญ่          NaN     17.0           NaN      71.0\n1      บุญหนัก         14.0      NaN          48.0       NaN\n2        บุญมา          NaN     20.0           NaN      83.0\n3      บุญเยอะ          NaN     28.0           NaN      75.0\n4       บุญแฝง          NaN     21.0           NaN      73.0\n0        บุญดี         22.0      NaN          32.0       NaN\n1       บุญแรง          NaN     17.0           NaN      68.0\n2       บุญดัง         14.0      NaN          70.0       NaN\n3      บุญจริง         15.0      NaN          64.0       NaN\n4      บุญเติม         19.0      NaN          55.0       NaN\n0       บุญรอด          NaN     15.0           NaN      82.0\n1       บุญชอบ         18.0      NaN          59.0       NaN\n2      บุญผ่อง          NaN     12.0           NaN      68.0\n3       บุญสืบ          8.0      NaN          62.0       NaN\n4     บุญเหลือ          NaN     25.0           NaN      87.0\n\n\n\n\nการยุบรวมข้อมูลตามคอลัมน์ (columns combined)\nการยุบรวมข้อมูลตามคอลัมน์มีการดำเนินการคล้ายกับการยุบรวมตามแถว แต่เปลี่ยนมิติของการจับคู่เป็นการจับคู่ข้อมูลระหว่างหน่วยข้อมูลเดียวกันที่อยู่ต่างชุดข้อมูลกัน รูป 4.3 แสดงลักษณะของการยุบรวมข้อมูลตามคอลัมน์ จากรูปจะเห็นว่า การยุบรวมข้อมูลลักษณะนี้เป็นการนำชุดข้อมูลหลายชุดของหน่วยข้อมูลเดียวกันหรือมีหน่วยข้อมูลเป็นส่วนย่อยของกันและกัน และมีตัวแปรที่แตกต่างกันมารวมเข้าเป็นชุดข้อมูลเดียวกัน\n\n\n\nรูป 4.3 ตัวอย่างแสดงลักษณะการยุบรวมชุดข้อมูลตามคอลัมน์ (column combined)\n\n\nที่มา : สิวะโชติ ศรีสุทธิยากร (2564)\nการยุบรวมข้อมูลตามคอลัมน์ด้วยภาษา R สามารถดำเนินการได้หลายวิธีการมาก วิธีการแรกคือการใช้ฟังก์ชัน bind_cols() ของ package-dplyr ที่มีการทำงานเหมือนกับฟังก์ชัน bind_rows() แต่จะดำเนินการรวมข้อมูลตามคอลัมน์แทน เงื่อนไขของฟังก์ชันนี้ที่ไม่ค่อยสะดวกนักคือ ชุดข้อมูลที่จะยุบรวมกันตามคอลัมน์ต้องเป็นชุดข้อมูลของหน่วยข้อมูลเดียวกัน แต่มีตัวแปรที่แตกต่างกัน และการจัดเรียงหน่วยข้อมูลต้องเป็นไปในลำดับเดียวกัน ดังในรูป 4.3 ข้างต้น (ผู้อ่านสามารถศึกษารายละเอียดของฟังก์ชัน bind_cols() ได้โดยพิมพ์คำสั่ง ?bind_cols())\nในทางปฏิบัติเมื่อผู้วิเคราะห์ดำเนินการกับข้อมูลขนาดใหญ่หลายชุดที่มาจากฐานข้อมูลที่แตกต่างกัน ชุดข้อมูลดังกล่าวมักจะมีการจัดเรียงลำดับของหน่วยข้อมูลที่แตกต่างกัน นอกจากนี้ชุดข้อมูลทั้งหมดยังอาจมีบางหน่วยข้อมูลที่แตกต่างกันและไม่สามารถยุบรวมกันได้ สถานการณ์ที่ซับซ้อนลักษณะนี้การยุบรวมด้วยฟังก์ชัน bind_cols() จะเป็นวิธีการที่ค่อนข้างลำบาก การใช้กลุ่มฟังก์ชัน join ของ package-dplyr เป็นวิธีการที่เหมาะสมมากกว่า กลุ่มฟังก์ชัน join ดังกล่าวประกอบด้วยฟังก์ชัน 4 ตัวที่ทำงานแตกต่างกัน เพื่อรองรับความต้องการในการยุบรวมข้อมูลตามคอลัมน์ของผู้วิเคราะห์ที่แตกต่างกัน ได้แก่ inner_join(), full_join(), left_join() และ right_join() รูป 4.4 แสดงลักษณะการทำงานของกลุ่มฟังก์ชัน join ดังกล่าว จากรูปจะเห็นความแตกต่างของฟังก์ชันทั้ง 4 ตัวว่าอยู่ที่การเลือกจัดเก็บหรือไม่จัดเก็บหน่วยข้อมูลจากชุดข้อมูลที่จะยุบรวมกันอย่างไร กล่าวคือ inner_join() จะเลือกจัดเก็บเฉพาะหน่วยข้อมูลที่มีร่วมกันระหว่างชุดข้อมูลทั้งสองเท่านั้น ในขณะที่ left_join() จะเก็บหน่วยข้อมูลชุดทางซ้าย (เรียกว่าชุด x) ไว้ทั้งหมด แต่จะเลือกจัดเก็บข้อมูลชุดทางขวา (เรียกว่าชุด y) เฉพาะส่วนที่มีข้อมูลร่วมกันกับชุด x เท่านั้น ฟังก์ชัน right_joint() มีการดำเนินการเหมือนกับ left_join() แต่มีทิศทางการจัดเก็บข้อมูลที่ตรงข้ามกัน ส่วนฟังก์ชัน full_join() จะเก็บหน่วยข้อมูลทุกหน่วยไว้ไม่ว่าหน่วยข้อมูลนั้นจะมีอยู่ร่วมกันในทั้งสองชุดข้อมูลหรือไม่\n ที่มา : สิวะโชติ ศรีสุทธิยากร (2564)\nฟังก์ชันในกลุ่ม join มีอาร์กิวเมนท์ที่สำคัญเหมือนกันได้แก่ x และ y คือชุดข้อมูลที่ต้องการยุบรวมกันตามคอลัมน์ และ by ใช้ระบุตัวแปร id ที่จะใช้จับคู่หน่วยข้อมูลระหว่างชุดข้อมูลทั้งสอง ทั้งนี้การระบุอาร์กิวเมนท์นี้จะต้องระบุเป็นเวกเตอร์ตัวอักษร (character vector)\nตัวอย่างต่อไปนี้แสดงการใช้ฟังก์ชัน join ทั้ง 4 ตัวเพื่อยุบรวมข้อมูลตามคอลัมน์ ชุดข้อมูลที่ใช้เป็นตัวอย่างเป็นชุดข้อมูลที่สร้างขึ้นด้วยการกำหนดค่าด้วยมือ ประกอบด้วยชุดข้อมูล X และ Y สังเกตว่าชุดข้อมูลทั้งหมดมีตัวแปร id ที่ใช้สำหรับอ้างอิงหน่วยข้อมูล นอกจากนี้ชุดข้อมูลทั้งสองมีหน่วยข้อมูลที่เหมือนกันเพียงบางส่วน และมีการจัดเก็บข้อมูลของตัวแปรที่แตกต่างกัน\n\nX<-data.frame(id=c(1,2,3,4),\n              gender = c(\"m\",\"f\",\"f\",\"m\"),\n              income = c(10,5,20,15))\n\nY<-data.frame(id=c(1,2,5,6,7),\n              score = c(30,50,20,100, 75),\n              location = c(\"N\",\"NE\",\"S\",\"C\",\"W\"))\n\n\nX\n\n  id gender income\n1  1      m     10\n2  2      f      5\n3  3      f     20\n4  4      m     15\n\nY\n\n  id score location\n1  1    30        N\n2  2    50       NE\n3  5    20        S\n4  6   100        C\n5  7    75        W\n\n\nผลลัพธ์ที่ได้จากการยุบรวมข้อมูลตามคอลัมน์ด้วยฟังก์ชัน join ทั้ง 4 ตัวเป็นดังนี้ ผู้อ่านลองพิจารณาความแตกต่างของผลลัพธ์ที่ได้จากฟังก์ชันทั้ง 4 ใน output ด้านล่าง\n\ninner_join(X, Y, by = \"id\")\n\n  id gender income score location\n1  1      m     10    30        N\n2  2      f      5    50       NE\n\nleft_join(X, Y, by = \"id\")\n\n  id gender income score location\n1  1      m     10    30        N\n2  2      f      5    50       NE\n3  3      f     20    NA     <NA>\n4  4      m     15    NA     <NA>\n\nright_join(X, Y, by = \"id\")\n\n  id gender income score location\n1  1      m     10    30        N\n2  2      f      5    50       NE\n3  5   <NA>     NA    20        S\n4  6   <NA>     NA   100        C\n5  7   <NA>     NA    75        W\n\nfull_join(X, Y, by = \"id\")\n\n  id gender income score location\n1  1      m     10    30        N\n2  2      f      5    50       NE\n3  3      f     20    NA     <NA>\n4  4      m     15    NA     <NA>\n5  5   <NA>     NA    20        S\n6  6   <NA>     NA   100        C\n7  7   <NA>     NA    75        W\n\n\nในภาษา Python มีฟังก์ชันที่เทียบเคียงได้กับกลุ่มฟังก์ชัน join ของภาษา R เช่นเดียวกันได้แก่ ฟังก์ชัน merge() ภายใต้ pandas library ฟังก์ชันดังกล่าวมีพารามิเตอร์ที่สำคัญได้แก่ left และ right ใช้ระบุชุดข้อมูลทางซ้ายและทางขวาสำหรับการยุบรวม on ใช้ระบุ id สำหรับการจับคู่หน่วยข้อมูลเดียวกันระหว่างสองชุดข้อมูลที่ต้องการยุบรวมกัน และ how ใช้ระบุลักษณะของการยุบรวมระหว่างชุดข้อมูล โดยสามารถเลือกกำหนดได้ 4 แบบเช่นเดียวกับภาษา R ได้แก่ inner, left, right และ outer โดยที่ outer จะเทียบเท่ากับ full_join() ในภาษา R ข้างต้น\nตัวอย่างต่อไปนี้แสดงการใช้ฟังก์ชัน pd.merge() เพื่อยุบรวมชุดข้อมูล X และ Y ด้านล่าง ด้วยวิธีการทั้ง 4 แบบ\n\nX = {'id': [1,2,3,4],\n     'gender': [\"m\",\"f\",\"f\",\"m\"],\n     'income': [10,5,20,15]}\n\nY = {'id': [1,2,5,6,7],\n    'score': [30,50,20,100, 75],\n    'location': [\"N\",\"NE\",\"S\",\"C\",\"W\"]}\n    \nX = pd.DataFrame(X)\nY = pd.DataFrame(Y)\n\n\nX\n\n   id gender  income\n0   1      m      10\n1   2      f       5\n2   3      f      20\n3   4      m      15\n\nY\n\n   id  score location\n0   1     30        N\n1   2     50       NE\n2   5     20        S\n3   6    100        C\n4   7     75        W\n\n\n\npd.merge(X, Y, on=\"id\", how=\"inner\")\n\n   id gender  income  score location\n0   1      m      10     30        N\n1   2      f       5     50       NE\n\npd.merge(X, Y, on=\"id\", how=\"left\")\n\n   id gender  income  score location\n0   1      m      10   30.0        N\n1   2      f       5   50.0       NE\n2   3      f      20    NaN      NaN\n3   4      m      15    NaN      NaN\n\npd.merge(X, Y, on=\"id\", how=\"right\")\n\n   id gender  income  score location\n0   1      m    10.0     30        N\n1   2      f     5.0     50       NE\n2   5    NaN     NaN     20        S\n3   6    NaN     NaN    100        C\n4   7    NaN     NaN     75        W\n\npd.merge(X, Y, on=\"id\", how=\"outer\")\n\n   id gender  income  score location\n0   1      m    10.0   30.0        N\n1   2      f     5.0   50.0       NE\n2   3      f    20.0    NaN      NaN\n3   4      m    15.0    NaN      NaN\n4   5    NaN     NaN   20.0        S\n5   6    NaN     NaN  100.0        C\n6   7    NaN     NaN   75.0        W"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "หน่วยที่ 4 การเตรียมข้อมูล",
    "section": "",
    "text": "แผนการสอนประจำหน่วย\n\nชุดวิชา\nหลักวิทยาการข้อมูลและการแสดงผลด้วยแผนภาพ\n\n\nหน่วยที่ 4\nการเตรียมข้อมูล\n\n\nตอนที่\n4.1 การนำเข้าและเขียนชุดข้อมูล\n4.2 การจัดระเบียบข้อมูล\n4.2 การจัดกระทำข้อมูล\n4.3 การวิเคราะห์เพื่อสำรวจข้อมูลและการแก้ปัญหา\n\n\nแนวคิด\nขั้นตอนการดำเนินงานทางด้านวิทยาการข้อมูลอาจจำแนกออกเป็น 5 ขั้นตอนใหญ่ได้แก่ การระบุปัญหา/วัตถุประสงค์ของงาน การเก็บรวบรวมข้อมูล การเตรียมข้อมูล การวิเคราะห์ข้อมูล/การพัฒนาโมเดล และการนำผลการวิเคราะห์/โมเดลไปใช้งาน\nส่วนประกอบสำคัญที่สุดในการดำเนินงานทางด้านสถิติและวิทยาการข้อมูลคือข้อมูล ถึงแม้ว่าปัจจุบันข้อมูลจะเป็นทรัพยากรที่มีอยู่จำนวนมาก และสามารถเข้าถึงได้โดยง่าย แต่ในสถานการณ์ของการทำงานจริง ข้อมูลส่วนใหญ่มักยังไม่อยู่ในสภาพที่พร้อมสำหรับการนำไปดำเนินการวิเคราะห์ตามวัตถุประสงค์ต่าง ๆ การเตรียมข้อมูลจึงเป็นขั้นตอนสำคัญที่นักสถิติและนักวิทยาการข้อมูลต้องดำเนินการ เพื่อจัดระเบียบหรือจัดกระทำข้อมูล ในเชิงปฏิบัติการเตรียมข้อมูลเป็นขั้นตอนที่ใช้ทรัพยากรและเวลาค่อนข้างมาก กล่าวกันว่าขั้นตอนนี้ใช้เวลาในการดำเนินงานคิดเป็นกว่าร้อยละ 80 ของการดำเนินงานทั้งหมดของโครงการวิทยาการข้อมูล (Dasu, & Johnson, 2003) นอกจากนี้การเตรียมข้อมูลนี้ยังมีลักษณะการดำเนินงานเป็นแบบทวนซ้ำไปมาหลายครั้ง และไม่ได้มีรูปแบบการดำเนินงานที่ตายตัวเหมือนกันในแต่ละโครงการ ความรู้และทักษะนี้จึงมีความจำเป็นอย่างยิ่งสำหรับนักสถิติและนักวิทยาการข้อมูล\nเพื่อให้ผู้อ่านมีความรู้และทักษะที่เพียงพอสำหรับการเตรียมข้อมูล เนื้อหาภายในหน่วยการเรียนนี้จึงประกอบด้วย มโนทัศน์และวิธีการที่จำเป็นสำหรับการเตรียมข้อมูลดังกล่าว ประกอบด้วย การจัดระเบียบชุดข้อมูล การจัดกระทำข้อมูล การวิเคราะห์เพื่อสำรวจข้อมูล และการแก้ปัญหาที่เกิดขึ้นในข้อมูลได้แก่ ปัญหาค่าสูญหาย และปัญหาค่าผิดปกติ โดยผู้เขียนได้แทรกตัวอย่างและชุดคำสั่งของภาษา R และภาษา Python สำหรับใช้การดำเนินการต่าง ๆ ในข้างต้น ซึ่งผู้อ่านสามารถนำชุดคำสั่งที่ให้ในบทเรียนไปประยุกต์ใช้ได้ในการทำงาน\n\n\nวัตถุประสงค์\nเมื่อศึกษาหน่วยที่ 4 จบแล้วผู้อ่านสามารถ\n\nนำเข้าและเขียนชุดข้อมูลได้\nอธิบายมโนทัศน์ของชุดข้อมูลจัดระเบียบ\nสำรวจสภาพและระบุปัญหาที่เกิดขึ้นในชุดข้อมูล โดยใช้สถิติพื้นฐานและทัศนภาพข้อมูล\nจัดระเบียบชุดข้อมูลให้อยู่ในรูปแบบตารางข้อมูลที่เหมาะสมสำหรับการวิเคราะห์ข้อมูล\nจัดกระทำข้อมูลเพื่อให้ได้ชุดข้อมูลที่เหมาะสมและตรงกับความต้องการในการวิเคราะห์ข้อมูล\nอธิบายมโนทัศน์ของค่าสูญหายได้ สามารถวิเคราะห์และทดแทนค่าสูญหายได้อย่างเหมาะสม\nอธิบายมโนทัศน์ของค่าผิดปกติได้ สามารถวิเคราะห์และแก้ปัญหาค่าผิดปกติได้อย่างเหมาะสม"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Dasu T, Johnson T (2003). Exploratory Data Mining and Data Cleaning. John Wiley & Sons.\nสิวะโชติ ศรีสุทธิยากร. (2564). R สำหรับสถิติและวิทยาการข้อมูลทางการศึกษา :การจัดระเบียบและจัดกระทำข้อมูล. 1st ed. Boca Raton, Florida: คณะครุศาสตร์จุฬาลงกรณ์มหาวิทยาลัย. http://yihui.org/knitr/.\nBryan J (2017). gapminder: Data from Gapminder. R package version 0.3.0, https://CRAN.R-project.org/package=gapminder"
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "1  Summary",
    "section": "",
    "text": "1 + 1\n\n[1] 2"
  },
  {
    "objectID": "tidy.html",
    "href": "tidy.html",
    "title": "ตอนที่ 4.2 การจัดระเบียบข้อมูล (tidying data)",
    "section": "",
    "text": "ชุดข้อมูล (data set) มีลักษณะเป็นตารางที่ประกอบด้วยมิติด้านคอลัมน์ (column) และแถว (row) ใช้เก็บข้อมูลของตัวแปรต่าง ๆ ข้อมูลที่ถูกจัดเก็บอยู่ในตารางดังกล่าวเป็นไปได้ทั้งข้อมูลเชิงปริมาณที่มีค่าเป็นตัวเลข ข้อมูลเชิงคุณลักษณะที่ไม่ใช่ตัวเลข การออกแบบตารางสำหรับจัดเก็บข้อมูลนั้นสามารถทำได้หลากหลายลักษณะ พิจารณาชุดข้อมูลในตาราง 1 และ 2 ด้านล่างจะเห็นว่าถึงแม้จะเป็นเป็นชุดข้อมูลที่จัดเก็บข้อมูลเดียวกัน แต่ก็สามารถที่จะมีรูปแบบการจัดเก็บที่แตกต่างกันได้\nตาราง 4.1 : คะแนนสอบวิชาคณิตศาสตร์และภาษาอังกฤษของนักเรียน (รูปแบบที่ 1)\nตาราง 4.2 : คะแนนสอบวิชาคณิตศาสตร์และภาษาอังกฤษของนักเรียน (รูปแบบที่ 2)\nอย่างไรก็ตามการจัดเก็บข้อมูลในชุดข้อมูลในรูปแบบที่เหมาะสมกับการดำเนินการวิเคราะห์ข้อมูล หรือการสร้างทัศนภาพข้อมูลจะช่วยให้การวิเคราะห์ข้อมูลตามวัตถุประสงค์ต่าง ๆ สามารถทำได้ง่ายและมีประสิทธิภาพ ในทางกลับกันการจัดเก็บข้อมูลในรูปแบบที่ไม่เหมาะสมจะเป็นอุปสรรคในการวิเคราะห์ข้อมูล นอกจากนี้ยังอาจเป็นปัจจัยที่ก่อให้เกิดความผิดพลาดในผลการวิเคราะห์อีกด้วย รูปแบบของชุดข้อมูลที่เหมาะสมและสนับสนุนให้การวิเคราะห์ข้อมูลสามารถดำเนินไปได้อย่างมีประสิทธิภาพเรียกว่า ชุดข้อมูลจัดระเบียบ (tidy data)\nชุดข้อมูลจัดระเบียบเป็นตารางข้อมูลที่มีลักษณะสำคัญของรูปแบบการจัดเก็บข้อมูล 3 ประการ (สิวะโชติ ศรีสุทธิยากร, 2564; Wickham, 2014) ดังนี้\nรูป 4.1 แสดงตัวอย่างของชุดข้อมูลจัดระเบียบที่มีคุณลักษณะข้างต้น สังเกตว่าหัวตาราง (แถวแรกของตาราง) จะเป็นส่วนที่ใช้ระบุชื่อของตัวแปรในแต่ละคอลัมน์ อย่างไรก็ตามในสถานการณ์จริงชุดข้อมูลส่วนใหญ่มักมีลักษณะที่ละเมิดเงื่อนไขของชุดข้อมูลจัดระเบียบข้างต้นอย่างน้อยหนึ่งข้อ การจัดระเบียบชุดข้อมูลจึงเป็นขั้นตอนที่มีความสำคัญภายใต้การดำเนินงานทางด้านวิทยาการข้อมูล เนื้อหาในตอนที่ 4.1 นี้จึงจะกล่าวถึง การสำรวจลักษณะของชุดข้อมูล เพื่อวิเคราะห์สภาพและระบุปัญหาความไม่เป็นระเบียบของชุดข้อมูล (ถ้ามี) จากนั้นจะกล่าวถึงวิธีการที่เกี่ยวข้องสำหรับแก้ปัญหาดังกล่าว รายละเอียดมีดังนี้\nที่มา : ดัดแปลงจาก สิวะโชติ ศรีสุทธิยากร (2564)"
  },
  {
    "objectID": "tidy.html#เรองท-4.1.1-การสำรวจลกษณะของชดขอมล",
    "href": "tidy.html#เรองท-4.1.1-การสำรวจลกษณะของชดขอมล",
    "title": "ตอนที่ 4.2 การจัดระเบียบข้อมูล (tidying data)",
    "section": "เรื่องที่ 4.1.1 การสำรวจลักษณะของชุดข้อมูล",
    "text": "เรื่องที่ 4.1.1 การสำรวจลักษณะของชุดข้อมูล\nในหัวข้อนี้จะใช้ชุดข้อมูล gapminder (Bryan, 2017) ที่ประกอบด้วยข้อมูลเกี่ยวกับจำนวนประชากร (pop) ผลิตภัณฑ์มวลรวมในประเทศต่อหัว (gdpPercap) และอายุขัยเฉลี่ยของประชากร (lifeExp) ของประเทศต่าง ๆ เป็นตัวอย่างประกอบการอธิบาย เมื่อผู้วิเคราะห์นำข้อมูล gapminder เข้าสู่โปรแกรมแล้วเรียกดูชุดข้อมูลจะได้ผลลัพธ์ที่มีลักษณะดังนี้\n\n\n       country continent year lifeExp      pop gdpPercap\n1  Afghanistan      Asia 1952  28.801  8425333  779.4453\n2  Afghanistan      Asia 1957  30.332  9240934  820.8530\n3  Afghanistan      Asia 1962  31.997 10267083  853.1007\n4  Afghanistan      Asia 1967  34.020 11537966  836.1971\n5  Afghanistan      Asia 1972  36.088 13079460  739.9811\n6  Afghanistan      Asia 1977  38.438 14880372  786.1134\n7  Afghanistan      Asia 1982  39.854 12881816  978.0114\n8  Afghanistan      Asia 1987  40.822 13867957  852.3959\n9  Afghanistan      Asia 1992  41.674 16317921  649.3414\n10 Afghanistan      Asia 1997  41.763 22227415  635.3414\n\n\n\n\n      country continent year lifeExp      pop gdpPercap\n1695 Zimbabwe    Africa 1962  52.358  4277736  527.2722\n1696 Zimbabwe    Africa 1967  53.995  4995432  569.7951\n1697 Zimbabwe    Africa 1972  55.635  5861135  799.3622\n1698 Zimbabwe    Africa 1977  57.674  6642107  685.5877\n1699 Zimbabwe    Africa 1982  60.363  7636524  788.8550\n1700 Zimbabwe    Africa 1987  62.351  9216418  706.1573\n1701 Zimbabwe    Africa 1992  60.377 10704340  693.4208\n1702 Zimbabwe    Africa 1997  46.809 11404948  792.4500\n1703 Zimbabwe    Africa 2002  39.989 11926563  672.0386\n1704 Zimbabwe    Africa 2007  43.487 12311143  469.7093\n\n\nผลลัพธ์ข้างต้นจะเห็นว่าชุดข้อมูล gapminder ประกอบด้วยตัวแปรทั้งหมด 6 ตัว ได้แก่ ประเทศ (country) ทวีป (continent) ปี (year) อายุขัยเฉลี่ยของประชากร (lifeExp) จำนวนประชากร (pop) และผลิตภัณฑ์มวลรวมต่อหัวภายในประเทศ (gdpPercap) ผู้อ่านจะสังเกตเห็นว่าการเรียนดูข้อมูลทั้งชุดขึ้นมาโดยตรงดังตัวอย่างข้างต้นเป็นวิธีการที่ไม่มีประสิทธิภาพในการสำรวจข้อมูล ทั้งนี้เป็นเพราะในสถานการณ์ที่ข้อมูลมีจำนวนมาก วิธีการดังกล่าวจะให้รายละเอียดของชุดข้อมูลที่มากเกินไปโดยไม่จำเป็น นอกจากนี้ยังมีโอกาสสูงที่จะเกิดปัญหาข้อมูลล้นหน้าจอแสดงผล จนผู้วิเคราะห์ไม่สามารถทราบสภาพของชุดข้อมูลดังกล่าวได้อย่างสะดวก\nในทางปฏิบัติการสำรวจชุดข้อมูลต่าง ๆ ผู้วิเคราะห์จะไม่ได้เรียกดูหรือสำรวจชุดข้อมูลทั้งหมดโดยตรง แต่จะใช้ module ของโปรแกรมวิเคราะห์ข้อมูลช่วยในการสำรวจ module ดังกล่าวจะทำหน้าที่สรุปสารสนเทศที่จำเป็นสำหรับการทำความเข้าใจสภาพของชุดข้อมูลดังกล่าว ได้แก่ การเรียกดูรายการและสถานะของตัวแปรในชุดข้อมูล และการเรียกดูส่วนหัวและส่วนท้ายของชุดข้อมูล รายละเอียดมีดังนี้\n\nการเรียกดูรายการและสถานะของตัวแปร\nวิธีการเรียกดูผลลัพธ์ส่วนนี้จะแตกต่างกันไปขึ้นอยู่กับผู้วิเคราะห์ว่าใช้โปรแกรมใด เช่น ในกรณีที่ใช้ภาษา R อาจเลือกใช้ฟังก์ชัน str() หรือ glimpse() หรือในกรณีที่ใช้ภาษา Python อาจเลือก method info() ภายใต้ pandas library เป็นต้น ผลการวิเคราะห์ด้านล่างแสดงผลลัพธ์ในภาษา R และ Python ดังกล่าว\n\n# R syntax\nlibrary(dplyr)\nglimpse(gapminder)\n\nRows: 1,704\nColumns: 6\n$ country   <fct> \"Afghanistan\", \"Afghanistan\", \"Afghanistan\", \"Afghanistan\", …\n$ continent <fct> Asia, Asia, Asia, Asia, Asia, Asia, Asia, Asia, Asia, Asia, …\n$ year      <int> 1952, 1957, 1962, 1967, 1972, 1977, 1982, 1987, 1992, 1997, …\n$ lifeExp   <dbl> 28.801, 30.332, 31.997, 34.020, 36.088, 38.438, 39.854, 40.8…\n$ pop       <int> 8425333, 9240934, 10267083, 11537966, 13079460, 14880372, 12…\n$ gdpPercap <dbl> 779.4453, 820.8530, 853.1007, 836.1971, 739.9811, 786.1134, …\n\n\n\n# Python syntax\nimport pandas\ngapminder.info()\n\n\n\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 1704 entries, 0 to 1703\nData columns (total 6 columns):\n #   Column     Non-Null Count  Dtype   \n---  ------     --------------  -----   \n 0   country    1704 non-null   category\n 1   continent  1704 non-null   category\n 2   year       1704 non-null   int32   \n 3   lifeExp    1704 non-null   float64 \n 4   pop        1704 non-null   int32   \n 5   gdpPercap  1704 non-null   float64 \ndtypes: category(2), float64(2), int32(2)\nmemory usage: 51.4 KB\n\n\nเมื่อพิจารณาผลลัพธ์จากภาษา R ข้างต้นแสดงให้เห็นว่าในชุดข้อมูล gapminder ประกอบด้วยข้อมูลจำนวน 1,704 หน่วย และมีจำนวน 6 คอลัมน์ โดยมีการรายงานชื่อของตัวแปรในแต่ละคอลัมน์ พร้อมทั้งระบุสถานะของตัวแปรดังกล่าว เช่น ตัวแปร country มีสถานะเป็นตัวแปรประเภทปัจจัย (fct) หรือตัวแปร year มีสถานะเป็นตัวแปรตัวเลขจำนวนเต็ม (int) หรือตัวแปร gdrPercap มีสถานะเป็นตัวแปรประเภทจำนวนจริง (dbl) เป็นต้น ผลลัพธ์นี้ช่วยให้ผู้วิเคราะห์ทราบว่าการนำเข้าข้อมูลดังกล่าว นำเข้ามาอย่างถูกต้องหรือไม่ หากมีตัวแปรใดที่ถูกจัดเก็บอยู่ในสถานะที่ไม่เหมาะสม ผู้วิเคราะห์ก็สามารถดำเนินการแก้ไขปรับเปลี่ยนให้เหมาะสมได้ และเมื่อพิจารณาผลลัพธ์จากภาษา Python พบว่าให้สารสนเทศในลักษณะเดียวกับภาษา R\n\n\nการเรียกดูส่วนหัวและส่วนท้ายของชุดข้อมูล\nวิธีการนี้เป็นวิธีการง่าย ๆ ที่ช่วยให้ผู้วิเคราะห์ทำความเข้าใจโครงสร้างของตารางข้อมูล ขอบเขตของตัวแปร รวมทั้งลักษณะของค่าสังเกตบางส่วนที่จัดเก็บอยู่ในชุดข้อมูล การดำเนินการส่วนนี้ด้วยภาษา R สามารถทำได้โดยใช้ฟังก์ชัน head() และ tail() ดังนี้\n\n# R syntax\nhead(gapminder)\n\n# A tibble: 6 × 6\n  country     continent  year lifeExp      pop gdpPercap\n  <fct>       <fct>     <int>   <dbl>    <int>     <dbl>\n1 Afghanistan Asia       1952    28.8  8425333      779.\n2 Afghanistan Asia       1957    30.3  9240934      821.\n3 Afghanistan Asia       1962    32.0 10267083      853.\n4 Afghanistan Asia       1967    34.0 11537966      836.\n5 Afghanistan Asia       1972    36.1 13079460      740.\n6 Afghanistan Asia       1977    38.4 14880372      786.\n\n\n\n# R syntax\ntail(gapminder)\n\n# A tibble: 6 × 6\n  country  continent  year lifeExp      pop gdpPercap\n  <fct>    <fct>     <int>   <dbl>    <int>     <dbl>\n1 Zimbabwe Africa     1982    60.4  7636524      789.\n2 Zimbabwe Africa     1987    62.4  9216418      706.\n3 Zimbabwe Africa     1992    60.4 10704340      693.\n4 Zimbabwe Africa     1997    46.8 11404948      792.\n5 Zimbabwe Africa     2002    40.0 11926563      672.\n6 Zimbabwe Africa     2007    43.5 12311143      470.\n\n\nส่วนภาษา Python สามารถทำได้โดยใช้ method head() และ tail() ของ pandas libary ดังนี้\n\n# Python syntax\ngapminder.head()\n\n\n\n       country continent  year  lifeExp       pop   gdpPercap\n0  Afghanistan      Asia  1952   28.801   8425333  779.445314\n1  Afghanistan      Asia  1957   30.332   9240934  820.853030\n2  Afghanistan      Asia  1962   31.997  10267083  853.100710\n3  Afghanistan      Asia  1967   34.020  11537966  836.197138\n4  Afghanistan      Asia  1972   36.088  13079460  739.981106\n\n\n\n# Python syntax\ngapminder.tail()\n\n\n\n       country continent  year  lifeExp       pop   gdpPercap\n1699  Zimbabwe    Africa  1987   62.351   9216418  706.157306\n1700  Zimbabwe    Africa  1992   60.377  10704340  693.420786\n1701  Zimbabwe    Africa  1997   46.809  11404948  792.449960\n1702  Zimbabwe    Africa  2002   39.989  11926563  672.038623\n1703  Zimbabwe    Africa  2007   43.487  12311143  469.709298\n\n\nในทางปฏิบัติผลการวิเคราะห์ด้วยวิธีการข้างต้นเพียงพอสำหรับผู้วิเคราะห์ที่จะใช้พิจารณาว่าโครงสร้างการจัดเก็บข้อมูลในชุดข้อมูลที่นำเข้ามามีลักษณะเป็นชุดข้อมูลจัดระเบียบที่เหมาะสำหรับการนำไปวิเคราะห์ข้อมูลตามวัตถุประสงค์แล้วหรือไม่ หากยังไม่เหมาะสมผู้วิเคราะห์จำเป็นต้องแก้ปัญหาในเชิงของโครงสร้างชุดข้อมูลดังกล่าวก่อนที่จะดำเนินการในขั้นตอนต่อไป หัวข้อถัดไปจะกล่าวถึงเครื่องมือหรือวิธีการพื้นฐานที่จำเป็นสำหรับปรับเปลี่ยนลักษณะของชุดข้อมูลให้ตรงกับความต้องการ"
  },
  {
    "objectID": "tidy.html#เรองท-4.1.2-การปรบเปลยนลกษณะของชดขอมล-reshaping-data",
    "href": "tidy.html#เรองท-4.1.2-การปรบเปลยนลกษณะของชดขอมล-reshaping-data",
    "title": "ตอนที่ 4.2 การจัดระเบียบข้อมูล (tidying data)",
    "section": "เรื่องที่ 4.1.2 การปรับเปลี่ยนลักษณะของชุดข้อมูล (reshaping data)",
    "text": "เรื่องที่ 4.1.2 การปรับเปลี่ยนลักษณะของชุดข้อมูล (reshaping data)\nชุดข้อมูลที่ยังไม่เป็นระเบียบมีหลากหลายลักษณะ และโดยมากมักพบเมื่อผู้วิเคราะห์ได้ข้อมูลมาจากแหล่งข้อมูลทุติยภูมิ เช่น ฐานข้อมูล หรือแหล่ง open data ต่าง ๆ หัวข้อนี้จะกล่าวถึงปัญหาข้อมูลไม่เป็นระเบียบที่มักพบและวิธีการแก้ปัญหาดังกล่าว รายละเอียดมีดังนี้\n\nการปรับเปลี่ยนรูปแบบชุดข้อมูลระหว่างชุดข้อมูลแบบกว้างกับชุดข้อมูลแบบยาว\nชุดข้อมูลอาจจำแนกได้เป็น 2 ลักษณะ ได้แก่ ชุดข้อมูลแบบกว้าง (wide format) และชุดข้อมูลแบบยาว (long format) รายละเอียดมีดังนี้\n\nชุดข้อมูลแบบกว้าง เป็นชุดข้อมูลที่มีการกระจายค่าสังเกตของตัวแปรสำคัญขึ้นไปอยู่บนคอลัมน์ ดังตัวอย่างชุดข้อมูล onet.xlsx ในตาราง 3 โดยส่วนใหญ่ตารางลักษณะนี้เหมาะสำหรับการนำเสนอข้อมูล หรือนำไปใช้สำหรับสร้างทัศนภาพข้อมูลในบางกรณี แต่มักไม่เหมาะที่จะนำไปเข้าสู่โมเดลวิเคราะห์ข้อมูลต่าง ๆ\nชุดข้อมูลแบบยาว เป็นชุดข้อมูลที่มีลักษณะเป็นไปตามเงื่อนไขของชุดข้อมูลจัดระเบียบ โดยมิติด้านคอลัมน์ใช้เก็บข้อมูลของตัวแปรแต่ละตัว ส่วนมิติด้านแถวใช้เก็บข้อมูลของหน่วยข้อมูล ชุดข้อมูล gapminder ข้างต้นเป็นตัวอย่างของชุดข้อมูลแบบยาว ชุดข้อมูลแบบยาวเป็นรูปแบบปกติที่มักพบในฐานข้อมูลแบบ SQL ทั่วไป\n\nตาราง 4.3 : (ตัวอย่างชุดข้อมูลแบบกว้าง) จำนวนนักเรียนจำแนกตามรายวิชาและช่วงคะแนนผลการสอบ O-NET ระดับชั้น ม.6 ปีการศึกษา 2560\n\n\n\n\n \n\n\nช่วงคะแนนผลสอบ O-NET\n\n  \n    วิชา \n    < 10 คะแนน \n    10-20 \n    20-30 \n    30-40 \n    40-50 \n    50-60 \n    60-70 \n    70-80 \n    80-90 \n    90-100 \n  \n \n\n  \n    ภาษาไทย \n    205 \n    10918 \n    39277 \n    59459 \n    80767 \n    84977 \n    61052 \n    28544 \n    6623 \n    221 \n  \n  \n    สังคมศึกษา \n    93 \n    11450 \n    119492 \n    155338 \n    64380 \n    17638 \n    3721 \n    447 \n    8 \n    0 \n  \n  \n    ภาษาอังกฤษ \n    2664 \n    120768 \n    146339 \n    48926 \n    21706 \n    12859 \n    8510 \n    5868 \n    3791 \n    1156 \n  \n  \n    คณิตศาสตร์ \n    52250 \n    163221 \n    81737 \n    29113 \n    14854 \n    9772 \n    7302 \n    5524 \n    4516 \n    4564 \n  \n  \n    วิทยาศาสตร์ \n    950 \n    61511 \n    183241 \n    75152 \n    25353 \n    12909 \n    7437 \n    3944 \n    1578 \n    157 \n  \n\n\n\n\n\nในทางปฏิบัติผู้วิเคราะห์มีโอกาสพบชุดข้อมูลทั้งสองลักษณะ การปรับเปลี่ยนรูปแบบของชุดข้อมูลดังกล่าว จากชุดข้อมูลแบบกว้างให้เป็นแบบยาว และจากให้อยู่ในรูปแบบยาวให้เป็นรูปแบบกว้าง จึงเป็นทักษะพื้นฐานที่จำเป็นสำหรับนักวิทยาการข้อมูล ในทำนองเดียวกับการสำรวจโครงสร้างชุดข้อมูล วิธีการปรับเปลี่ยนรูปแบบตารางข้อมูลมีความแตกต่างกันขึ้นอยู่กับโปรแกรมวิเคราะห์ข้อมูลที่เลือกใช้\nในกรณีที่ใช้ภาษา R ผู้วิเคราะห์สามารถดำเนินการได้หลายแบบ วิธีการหนึ่งที่สามารถทำได้สะดวกคือการใช้เครื่องมือใน package-tidyr พิจารณาชุดข้อมูล จำนวนผู้สำเร็จการศึกษา.xlsx ที่จัดเก็บอยู่ในชุดข้อมูล wide_data ด้านล่าง จะเห็นว่าเป็นชุดข้อมูลรูปแบบกว้างที่แสดงจำนวนผู้สำเร็จการศึกษาในระดับ ปวช. และ ปวส. จำแนกตามสาขาวิชา\n\n\n# A tibble: 9 × 4\n  `สาขาวิชา`               รวม  ปวช.  ปวส.\n  <chr>                 <dbl> <dbl> <dbl>\n1 อุตสาหกรรม            123268 65724 57544\n2 พาณิชยกรรม /บริหารธุรกิจ 106556 55257 51299\n3 อุตสาหกรรมการท่องเที่ยว   10779  6696  4083\n4 คหกรรม                 7171  4101  3070\n5 เกษตรกรรม              6026  2926  3100\n6 ศิลปกรรม                5175  4163  1012\n7 เทคโนโลยีสารสนเทศฯ      3702  1758  1944\n8 ประมง                   576    91   485\n9 อุตสาหกรรมสิ่งทอ            87    39    48\n\n\nหากผู้วิเคราะห์ต้องการปรับรูปแบบของชุดข้อมูล wide_data ข้างต้นให้เป็นชุดข้อมูลแบบยาว สามารถทำได้โดยใช้ฟังก์ชัน pivot_longer() โดยกำหนดอารกิวเมนท์ data เพื่อระบุชุดข้อมูลที่ต้องการปรับให้เป็นรูปแบบยาว cols เพื่อกำหนดคอลัมน์ในชุดข้อมูลแบบกว้างที่จะยุบรวมไว้ภายในคอลัมน์เดียวกัน names_to ใช้กำหนดชื่อคอลัมน์ใหม่สำหรับบรรจุคอลัมน์ที่ยุบรวมมาจากชุดข้อมูลแบบกว้างเดิม และ values_to ใช้กำหนดชื่อคอลัมน์สำหรับจัดเก็บค่าสังเกตที่อยู่ภายใต้คอลัมน์ที่ยุบรวมมา ตัวอย่างด้านล่างแสดงการปรับรูปแบบของชุดข้อมูล จำนวนผู้สำเร็จการศึกษา.xlsx ที่จัดเก็บอยู่ในชุดข้อมูล wide_data ให้เป็นชุดข้อมูลแบบยาว\n\n# R syntax\nlong_data<-pivot_longer(data=wide_data, \n                        cols=2:4, \n                        names_to = \"category\", \n                        values_to = \"number\")\nlong_data%>%data.frame()\n\n               สาขาว.ชา category number\n1             อุตสาหกรรม      รวม 123268\n2             อุตสาหกรรม     ปวช.  65724\n3             อุตสาหกรรม     ปวส.  57544\n4  พาณิชยกรรม /บริหารธุรกิจ      รวม 106556\n5  พาณิชยกรรม /บริหารธุรกิจ     ปวช.  55257\n6  พาณิชยกรรม /บริหารธุรกิจ     ปวส.  51299\n7   อุตสาหกรรมการท่องเที่ยว      รวม  10779\n8   อุตสาหกรรมการท่องเที่ยว     ปวช.   6696\n9   อุตสาหกรรมการท่องเที่ยว     ปวส.   4083\n10               คหกรรม      รวม   7171\n11               คหกรรม     ปวช.   4101\n12               คหกรรม     ปวส.   3070\n13            เกษตรกรรม      รวม   6026\n14            เกษตรกรรม     ปวช.   2926\n15            เกษตรกรรม     ปวส.   3100\n16              ศิลปกรรม      รวม   5175\n17              ศิลปกรรม     ปวช.   4163\n18              ศิลปกรรม     ปวส.   1012\n19    เทคโนโลยีสารสนเทศฯ      รวม   3702\n20    เทคโนโลยีสารสนเทศฯ     ปวช.   1758\n21    เทคโนโลยีสารสนเทศฯ     ปวส.   1944\n22                ประมง      รวม    576\n23                ประมง     ปวช.     91\n24                ประมง     ปวส.    485\n25        อุตสาหกรรมสิ่งทอ      รวม     87\n26        อุตสาหกรรมสิ่งทอ     ปวช.     39\n27        อุตสาหกรรมสิ่งทอ     ปวส.     48\n\n\nในทางกลับกันหากมีชุดข้อมูลแบบยาว และผู้วิเคราะห์ต้องการปรับเปลี่ยนให้เป็นชุดข้อมูลแบบกว้างสามารถทำได้ด้วยฟังก์ชัน pivot_wider() ฟังก์ชันนี้มีอาร์กิวเมนท์จำเป็นที่จะต้องระบุ 3 ตัวได้แก่ data เพื่อระบุชุดข้อมูลที่ต้องการปรับให้เป็นรูปแบบกว้าง names_from เพื่อระบุว่าจะนำค่าสังเกตจากคอลัมน์ใดขยายไปเป็นหัวคอลัมน์ของตารางใหม่ และ values_from ใช้ระบุว่าจะเอาข้อมูล/ค่าสังเกตจากคอลัมน์ใดไปอยู่ภายใต้คอลัมน์ใหม่ที่ขยายจากการระบุใน names_from ตัวอย่างด้านล่างแสดงการเปลี่ยนชุดข้อมูล long_data ในข้างต้นให้กลับเป็นชุดข้อมูลแบบกว้างเหมือนเดิม\n\n# R syntax\npivot_wider(data = long_data,\n            names_from = \"category\",\n            values_from = \"number\")\n\n# A tibble: 9 × 4\n  `สาขาวิชา`               รวม  ปวช.  ปวส.\n  <chr>                 <dbl> <dbl> <dbl>\n1 อุตสาหกรรม            123268 65724 57544\n2 พาณิชยกรรม /บริหารธุรกิจ 106556 55257 51299\n3 อุตสาหกรรมการท่องเที่ยว   10779  6696  4083\n4 คหกรรม                 7171  4101  3070\n5 เกษตรกรรม              6026  2926  3100\n6 ศิลปกรรม                5175  4163  1012\n7 เทคโนโลยีสารสนเทศฯ      3702  1758  1944\n8 ประมง                   576    91   485\n9 อุตสาหกรรมสิ่งทอ            87    39    48\n\n\nถ้าผู้วิเคราะห์ต้องการศึกษารายละเอียดเพิ่มเติมเกี่ยวกับฟังก์ชันต่าง ๆ ของโปรแกรม R สามารถเรียกดูคู่มือของฟังก์ชันดังกล่าวได้โดยใช้คำสั่ง ?XXX หรือ help(XXX) เช่น หากต้องการรายละเอียดของฟังก์ชัน pivot_longer() ให้พิมพ์คำสั่ง ?pivot_longer() หรือ help(pivot_longer() เป็นต้น\nในกรณีที่ใช้ภาษา Python การปรับเปลี่ยนชุดข้อมูลแบบกว้างให้เป็นแบบยาวสามารถทำได้โดยใช้ฟังก์ชัน melt() ภายใต้ pandas library ฟังก์ชัน melt() มีพารามิเตอร์ควบคุมการทำงานของฟังก์ชันที่สำคัญ 3 ตัวได้แก่ frame ใช้ระบุชุดข้อมูล (pandas.DataFrame) ที่ต้องการดำเนินงาน id_vars ใช้ระบุคอลัมน์หรือตัวแปรที่เป็น id ของหน่วยข้อมูล และ value_vars ทำงานเหมือนกับอาร์กิวเมนท์ names_to ของ pivot_longer() ในโปรแกรม R ตัวอย่างด้านล่างแสดงการปรับรูปแบบชุดข้อมูล จำนวนผู้สำเร็จการศึกษา.xlsx ที่เป็นชุดข้อมูลแบบกว้างให้เป็นชุดข้อมูลแบบยาวด้วยฟังก์ชันดังกล่าว โดยในตัวอย่างชุดข้อมูลดังกล่าวจัดเก็บอยู่ในตัวแปรชื่อ wide_data\n\n\n\n\n# Python syntax\nimport pandas as pd\nlong_data = pd.melt(frame = wide_data, \n                    id_vars=['สาขาวิชา'],\n                    value_vars=['รวม','ปวช.', 'ปวส.'])\nlong_data\n\n                    สาขาวิชา variable     value\n0                 อุตสาหกรรม      รวม  123268.0\n1   พาณิชยกรรม /บริหารธุรกิจ      รวม  106556.0\n2    อุตสาหกรรมการท่องเที่ยว      รวม   10779.0\n3                     คหกรรม      รวม    7171.0\n4                  เกษตรกรรม      รวม    6026.0\n5                   ศิลปกรรม      รวม    5175.0\n6         เทคโนโลยีสารสนเทศฯ      รวม    3702.0\n7                      ประมง      รวม     576.0\n8           อุตสาหกรรมสิ่งทอ      รวม      87.0\n9                 อุตสาหกรรม     ปวช.   65724.0\n10  พาณิชยกรรม /บริหารธุรกิจ     ปวช.   55257.0\n11   อุตสาหกรรมการท่องเที่ยว     ปวช.    6696.0\n12                    คหกรรม     ปวช.    4101.0\n13                 เกษตรกรรม     ปวช.    2926.0\n14                  ศิลปกรรม     ปวช.    4163.0\n15        เทคโนโลยีสารสนเทศฯ     ปวช.    1758.0\n16                     ประมง     ปวช.      91.0\n17          อุตสาหกรรมสิ่งทอ     ปวช.      39.0\n18                อุตสาหกรรม     ปวส.   57544.0\n19  พาณิชยกรรม /บริหารธุรกิจ     ปวส.   51299.0\n20   อุตสาหกรรมการท่องเที่ยว     ปวส.    4083.0\n21                    คหกรรม     ปวส.    3070.0\n22                 เกษตรกรรม     ปวส.    3100.0\n23                  ศิลปกรรม     ปวส.    1012.0\n24        เทคโนโลยีสารสนเทศฯ     ปวส.    1944.0\n25                     ประมง     ปวส.     485.0\n26          อุตสาหกรรมสิ่งทอ     ปวส.      48.0\n\n\nใน Python ผู้อ่านสามารถเรียกดูรายละเอียดของฟังก์ชันที่ต้องการใช้งานโดยพิมพ์คำส่ง ?XXX หรือ help(XXXX) เหมือนกับภาษา R เช่นในกรณีนี้ต้องการรายละเอียดการใช้งานฟังก์ชัน melt()ให้พิมพ์คำสั่ง help(pd.melt)\nในทางกลับกันหากต้องการปรับเปลี่ยนรูปแบบของตารางแบบยาวให้เป็นแบบกว้างสามารถทำได้ด้วยฟังก์ชัน pivot() ดังตัวอย่างต่อไปนี้\n\npd.pivot(data= long_data, \n                    index=['สาขาวิชา'],\n                    columns=['variable'],\n                    values=['value'])\n\n                            value                   \nvariable                     ปวช.     ปวส.       รวม\nสาขาวิชา                                            \nคหกรรม                     4101.0   3070.0    7171.0\nประมง                        91.0    485.0     576.0\nพาณิชยกรรม /บริหารธุรกิจ  55257.0  51299.0  106556.0\nศิลปกรรม                   4163.0   1012.0    5175.0\nอุตสาหกรรม                65724.0  57544.0  123268.0\nอุตสาหกรรมการท่องเที่ยว    6696.0   4083.0   10779.0\nอุตสาหกรรมสิ่งทอ             39.0     48.0      87.0\nเกษตรกรรม                  2926.0   3100.0    6026.0\nเทคโนโลยีสารสนเทศฯ         1758.0   1944.0    3702.0\n\n\nอีกวิธีการหนึ่งในการปรับรูปแบบตารางระหว่างตารางรูปแบบกว้างกับยาวด้วยภาษา Python คือการใช้ library datar ที่เป็น API ของ package-dplyr และ tidyr ที่ใช้จัดกระทำและจัดระเบียบชุดข้อมูลใน R กล่าวคือ ผู้วิเคราะห์สามารถใช้ฟังก์ชัน pivot_longer() และ pivot_wider() รวมทั้งฟังก์ชันอื่น ๆ ที่เกี่ยวข้องใน Python ได้เหมือนกับที่ดำเนินการในภาษา R ก่อนการใช้งาน library ผู้วิเคราะห์จำเป็นต้องดาวน์โหลดและติดตั้ง library ลงในเครื่องก่อน โดยภายในหน้าต่าง terminal ให้พิมพ์คำสั่ง pip install -U datar รายละเอียดเพิ่มเติมสามารถศึกษาได้จาก https://github.com/pwwang/datar\n\n\nการแยกคอลัมน์\nในบางกรณีชุดข้อมูลที่นำใช้ในการวิเคราะห์อาจมีบางคอลัมน์ที่จัดเก็บค่าสังเกตของหลายตัวแปรอยู่ภายในเซลล์เดียวกัน ดังตัวอย่างในตาราง 4 (ดาวน์โหลดได้จาก คะแนนเชาวน์ปัญญาของนักเรียน.xlsx (สิวะโชติ ศรีสุทธิยากร, 2564)) จากตารางจะเห็นว่าคอลัมน์ที่ 3 (gender.age) เป็นคอลัมน์ที่จัดเก็บค่าสังเกตของตัวแปรจำนวน 2 ตัวร่วมกัน ได้แก่ เพศ และ อายุ ของนักเรียน ซึ่งละเมิดเงื่อนไขของชุดข้อมูลจัดระเบียบ การแก้ปัญหาจึงจำเป็นต้องแยกค่าสังเกตในคอลัมน์ดังกล่าวออกจากกันให้เป็น 2 คอลัมน์ได้แก่ คอลัมน์ของเพศ และอายุ ตามลำดับ\nตาราง 4.4 คะแนนเชาว์ปัญญาของนักเรียน\n\n\n\n\n \n  \n    id \n    จังหวัด \n    gender.age \n    IQ \n  \n \n\n  \n    1 \n    กรุงเทพฯ \n    ชาย/14 \n    80 \n  \n  \n    2 \n    กรุงเทพฯ \n    ชาย/24 \n    101 \n  \n  \n    3 \n    กรุงเทพฯ \n    ชาย/25 \n    105 \n  \n  \n    4 \n    กรุงเทพฯ \n    หญิง/54 \n    99 \n  \n  \n    5 \n    กรุงเทพฯ \n    ชาย/18 \n    100 \n  \n  \n    6 \n    กรุงเทพฯ \n    หญิง/65 \n    105 \n  \n  \n    7 \n    เชียงใหม่ \n    ชาย/14 \n    90 \n  \n  \n    8 \n    เชียงใหม่ \n    หญิง/15 \n    110 \n  \n  \n    9 \n    เชียงใหม่ \n    ชาย/37 \n    103 \n  \n  \n    10 \n    เชียงใหม่ \n    หญิง/28 \n    108 \n  \n  \n    11 \n    เชียงใหม่ \n    ชาย/44 \n    98 \n  \n  \n    12 \n    เชียงใหม่ \n    หญิง/34 \n    106 \n  \n\n\n\n\n\nที่มา: สิวะโชติ ศรีสุทธิยากร (2564)\nการแยกคอลัมน์ในชุดข้อมูลดังกล่าวด้วยภาษา R สามารถทำได้หลายวิธีการ ใน package-tidyr มีฟังก์ชัน seperate() ที่สามารถใช้ดำเนินการดังกล่าวได้ ฟังก์ชัน separate() มีอาร์กิวเมนท์สำคัญจำนวน 4 ตัวได้แก่ data ใช้สำหรับระบุชุดข้อมูลที่ต้องการแยกคอลัมน์ col ใช้ระบุคอลัมน์ที่ต้องการแยกค่าสังเกตออกจากกัน into ใช้กำหนดชื่อของคอลัมน์ใหม่ที่ภายหลังจากแยกค่าสังเกตของคอลัมน์เดิมออกจากกัน และ sep ใช้ระบุลลักษณะของตัวคั่น (seperator) ที่ใช้สำหรับแยกข้อมูล การกำหนดตัวคั่นนี้สามารถทำได้ 3 ลักษณะ ได้แก่ การกำหนดด้วยตัวอักษร การกำหนดด้วยตำแหน่งของตัวคั่น และการกำหนดด้วยนิพจน์ปกติ (regular expression) รายละเอียดสามารถศึกษาได้จาก สิวะโชติ ศรีสุทธิยากร (2564)\nตัวอย่างด้านล่างแสดงการใช้ฟังก์ชัน separate() เพื่อแยกค่าสังเกตในคอลัมน์ gender.age ออกเป็นคอลัมน์ gender และ age ตามลำดับ จากตัวอย่างจะเห็นว่าในคอลัมน์ gender.age มีการใช้ตัวคั่นข้อมูลเป็น / จึงกำหนดอาร์กิวเมนท์ sep=\"/\"\n\niq_sep<-separate(data = iq,\n         col = \"gender.age\",\n         into = c(\"gender\",\"age\"),\n         sep=\"/\")\niq_sep\n\n# A tibble: 12 × 5\n      id `จังหวัด` gender age      IQ\n   <dbl> <chr>   <chr>  <chr> <dbl>\n 1     1 กรุงเทพฯ ชาย    14       80\n 2     2 กรุงเทพฯ ชาย    24      101\n 3     3 กรุงเทพฯ ชาย    25      105\n 4     4 กรุงเทพฯ หญิง    54       99\n 5     5 กรุงเทพฯ ชาย    18      100\n 6     6 กรุงเทพฯ หญิง    65      105\n 7     7 เชียงใหม่ ชาย    14       90\n 8     8 เชียงใหม่ หญิง    15      110\n 9     9 เชียงใหม่ ชาย    37      103\n10    10 เชียงใหม่ หญิง    28      108\n11    11 เชียงใหม่ ชาย    44       98\n12    12 เชียงใหม่ หญิง    34      106\n\n\nในกรณีที่ใช้ภาษา Python สามารถดำเนินการได้โดยใช้ฟังก์ชัน str.split() ภายใต้ pandas library โดยฟังก์ชันดังกล่าวมีพารามิเตอร์ที่สำคัญ 1 ตัวได้แก่ separator ที่ใช้สำหรับระบุลักษณะของตัวคั่นข้อมูลในคอลัมน์ที่ต้องการแยก ตัวอย่างการใช้ฟังก์ชัน str.split() เพื่อแยกคอลัมน์ gender.age ในชุดข้อมูล iq เป็นดังนี้\n\n\n\n\niq[\"gender\"] = iq[\"gender.age\"].str.split(\"/\", expand=True)[0]\niq[\"age\"] = iq[\"gender.age\"].str.split(\"/\", expand=True)[1]\niq\n\n      id    จังหวัด gender.age     IQ gender age\n0    1.0   กรุงเทพฯ     ชาย/14   80.0    ชาย  14\n1    2.0   กรุงเทพฯ     ชาย/24  101.0    ชาย  24\n2    3.0   กรุงเทพฯ     ชาย/25  105.0    ชาย  25\n3    4.0   กรุงเทพฯ    หญิง/54   99.0   หญิง  54\n4    5.0   กรุงเทพฯ     ชาย/18  100.0    ชาย  18\n5    6.0   กรุงเทพฯ    หญิง/65  105.0   หญิง  65\n6    7.0  เชียงใหม่     ชาย/14   90.0    ชาย  14\n7    8.0  เชียงใหม่    หญิง/15  110.0   หญิง  15\n8    9.0  เชียงใหม่     ชาย/37  103.0    ชาย  37\n9   10.0  เชียงใหม่    หญิง/28  108.0   หญิง  28\n10  11.0  เชียงใหม่     ชาย/44   98.0    ชาย  44\n11  12.0  เชียงใหม่    หญิง/34  106.0   หญิง  34\n\n\n\n\nการยุบรวมคอลัมน์\nอีกกรณีคือเป็นไปได้ที่ข้อมูลของตัวแปรเดียวกันอาจถูกเก็บอยู่ในหลายคอลัมน์ เช่นข้อมูลคำนำหน้า ชื่อ และนามสกุล หรือ ข้อมูลเวลา (วัน เดือน ปี) ตาราง 5 แสดงข้อมูลจากชุดข้อมูล login.xlsx ที่มีปัญหาดังกล่าว จากตารางจะเห็นว่ามีการจัดเก็บคำนำหน้า และชื่อของผู้เข้าระบบอยู่คนละคอลัมน์กัน\nตาราง 5 จำนวนครั้งของการเข้าระบบ\n\n\n\n\n \n  \n    คำนำหน้า \n    ชื่อ \n    จำนวนครั้งที่เข้าระบบ \n  \n \n\n  \n    นาย \n    บุญถึง \n    14 \n  \n  \n    นางสาว \n    บุญเติม \n    20 \n  \n  \n    นาย \n    บุญมาก \n    17 \n  \n  \n    นางสาว \n    บุญมี \n    18 \n  \n  \n    นาย \n    บุญหนัก \n    6 \n  \n  \n    นาง \n    บุญอยู่ \n    18 \n  \n  \n    นางสาว \n    บุญมา \n    18 \n  \n  \n    นาย \n    บุญทับ \n    14 \n  \n  \n    นาง \n    บุญชอบ \n    18 \n  \n\n\n\n\n\nการยุบรวมคอลัมน์ทั้งสองเข้าด้วยกันในภาษา R สามารถทำได้ด้วยฟังก์ชัน unite() ของ package-tidyr ฟังก์ชันนี้มีอาร์กิวเมนท์ที่สำคัญได้แก่ data ใช้ระบุชุดข้อมูลที่ต้องการดำเนินงาน col ใช้ระบุชื่อของคอลัมน์ใหม่ภายหลังจากยุบรวมคอลัมน์เดิมเข้าด้วยกัน และ sep ใช้สำหรับระบุตัวคั่นสำหรับคั่นข้อมูลที่ยุบรวมกัน (ค่าเริ่มต้นของอาร์กิวเมนท์นี้กำหนดให้ใช้สัญลักษณ์ underscore sep=\"_\")\nตัวอย่างต่อไปนี้แสดงการใช้ฟังก์ชัน unite() ดังกล่าว สมมุติว่า login.xlsx ในข้างต้นถูกจัดเก็บในโปรแกรม R โดยเก็บไว้ในตัวแปร login ผู้วิเคราะห์สามารถยุบรวมคอลัมน์ คำนำหน้า และ ชื่อ เข้าด้วยกัน โดยใช้ฟังก์ชัน unite() ได้ดังนี้\n\nlogin_united<-unite(login, \n      col=\"name\",\n      \"คำนำหน้า\", \"ชื่อ\")\nlogin_united\n\n# A tibble: 9 × 2\n  name         `จำนวนครั้งที่เข้าระบบ`\n  <chr>                     <dbl>\n1 นาย_บุญถึง                     14\n2 นางสาว_บุญเติม                 20\n3 นาย_บุญมาก                    17\n4 นางสาว_บุญมี                   18\n5 นาย_บุญหนัก                     6\n6 นาง_บุญอยู่                     18\n7 นางสาว_บุญมา                  18\n8 นาย_บุญทับ                     14\n9 นาง_บุญชอบ                    18\n\n\nสำหรับภาษา Python การยุบรวมคอลัมน์ตั้งแต่ 2 คอลัมน์ขึ้นไปเข้าด้วยกันทำได้ง่ายมากโดยการใช้ตัวดำเนินการเชื่อม (concatenate operator) ดังตัวอย่างต่อไปนี้\n\n\n\n\nlogin[\"name\"] = login[\"คำนำหน้า\"] + login[\"ชื่อ\"]\nlogin\n\n  คำนำหน้า     ชื่อ  จำนวนครั้งที่เข้าระบบ           name\n0      นาย   บุญถึง                   14.0      นายบุญถึง\n1   นางสาว  บุญเติม                   20.0  นางสาวบุญเติม\n2      นาย   บุญมาก                   17.0      นายบุญมาก\n3   นางสาว    บุญมี                   18.0    นางสาวบุญมี\n4      นาย  บุญหนัก                    6.0     นายบุญหนัก\n5      นาง  บุญอยู่                   18.0     นางบุญอยู่\n6   นางสาว    บุญมา                   18.0    นางสาวบุญมา\n7      นาย   บุญทับ                   14.0      นายบุญทับ\n8      นาง   บุญชอบ                   18.0      นางบุญชอบ\n\n\n\n\nการรวมชุดข้อมูลตามแถว (rows combined)\nงานทางด้านสถิติและวิทยาการข้อมูลในปัจจุบันบ่อยครั้งข้อมูลสำคัญมักมาจากหลายแหล่งข้อมูล เช่น อาจได้มาจากการเก็บเกี่ยวข้อมูลจากเว็ปไซด์ส่วนนึง (web scraping) และส่วนที่เหลืออาจเป็นข้อมูลที่ได้จากฐานข้อมูลเปิดต่าง ๆ หากชุดข้อมูลดังกล่าวเป็นข้อมูลของหน่วยการวิเคราะห์เดียวกัน หรือสามารถจัดกระทำให้เป็นข้อมูลของหน่วยการวิเคราะห์เดียวกันได้แล้ว การจะนำข้อมูลดังกล่าวมาวิเคราะห์ร่วมกันจำเป็นที่จะต้องยุบรวมชุดข้อมูลดังกล่าวเข้าด้วยกันก่อน การยุบรวมชุดข้อมูลอาจจำแนกได้เป็น 2 ลักษณะ ได้แก่ การยุบรวมข้อมูลตามแถว (rows combined) และการยุบรวมข้อมูลตามคอลัมน์ (columns combined) หัวข้อนี้จะกล่าวถึงการยุบรวมข้อมูลตามแถว รายละเอียดมีดังนี้\nรูป 4.2 แสดงลักษณะของการยุบรวมข้อมูลตามแถว จากรูปจะเห็นว่าเริ่มต้นมีชุดข้อมูลจากแหล่งข้อมูลที่แตกต่างกันจำนวน 3 แหล่ง ได้แก่ A, B และ C โดยที่ชุดข้อมูลจากแต่ละแหล่งดังกล่าวเก็บข้อมูลของตัวแปรเดียวกัน และมีจำนวนคอลัมน์เท่ากัน แต่จะสังเกตเห็นว่าแต่ละชุดข้อมูลมีหน่วยข้อมูลที่แตกต่างกัน การยุบรวมชุดข้อมูลทั้ง 3 ตามแถวจะให้ผลลัพธ์เป็นชุดข้อมูลที่ใหญ่ขึ้นจากเดิม โดยมีหน่วยข้อมูลทั้งหมดจากทั้ง 3 ชุดข้อมูลข้างต้นมาจัดเก็บอยู่ภายใต้ชุดข้อมูลใหม่ขนาด 9 x 3\n\n\n\nรูป 4.2 ตัวอย่างแสดงลักษณะการยุบรวมชุดข้อมูลตามแถว (row combined)\n\n\nที่มา : สิวะโชติ ศรีสุทธิยากร (2564)\nการรวมชุดข้อมูลตามแถวด้วยภาษา R สามารถทำได้หลายวิธีการ ฟังก์ชัน bind_rows() ของ package-dplyr สามารถใช้เพื่อรวมชุดข้อมูลดังกล่าวได้ อาร์กิวเมนท์ของฟังก์ชัน bind_rows() ได้แก่ชุดข้อมูลแบบ Dataframe ที่ต้องการนำมารวมกันตามแถว เงื่อนไขของการใช้ฟังก์ชันนี้คือชุดข้อมูลที่จะนำมารวมกันจำเป็นต้องมีจำนวนคอลัมน์เท่ากัน แต่ละคอลัมน์จัดเก็บข้อมูลของตัวแปรเดียวกันและมีการจัดเรียงลำดับของตัวแปรที่เหมือนกัน\nตัวอย่างต่อไปนี้แสดงการยุบรวมข้อมูลตามแถวด้วยฟังก์ชัน bind_rows() สมมุติว่าผู้วิเคราะห์มีไฟล์ข้อมูลของกลุ่มเป้าหมายเดียวกันจำนวน 4 ไฟล์ ที่สามารถดาวน์โหลดไฟล์ดังกล่าวได้จาก https://bit.ly/2AuQgqr (สิวะโชติ ศรีสุทธิยากร, 2564) ไฟล์ข้อมูลทั้ง 4 ประกอบด้วย file1.xlsx, file2.xlsx, file3.xlsx และ file4.xlsx ตามลำดับ โดยที่แต่ละไฟล์จัดเก็บข้อมูลของนักเรียนไฟล์ละ 5 คน ตารางด้านล่างแสดงข้อมูลที่จัดเก็บอยู่ในไฟล์ file1.xlsx\n\n\n# A tibble: 5 × 5\n  student.name Lecture.pre PBL.pre Lecture.post PBL.post\n  <chr>              <dbl>   <dbl>        <dbl>    <dbl>\n1 บุญมี                   20      NA           45       NA\n2 บุญมาก                 16      NA           34       NA\n3 บุญเกิน                 NA      18           NA       67\n4 บุญถึง                  NA      25           NA       93\n5 บุญธรรม                13      NA           50       NA\n\n\nเมื่อผู้อ่านได้ดำเนินการสำรวจไฟล์ข้อมูลทั้ง 4 แล้วจะพบว่าโครงการการจัดเก็บข้อมูลของทั้ง 4 ไฟล์มีลักษณะเหมือนกัน ชุดข้อมูลทั้ง 4 จึงสามารถยุบรวมกันตามแถวได้โดยใช้ฟังก์ชัน rbind() ในข้างต้น ตัวอย่างนี้ผู้เขียนได้นำเข้าข้อมูลจากทั้ง 4 ไฟล์และจัดเก็บอยู่ในชุดข้อมูลชื่อ dat1, dat2, dat3 และ dat4 ตามลำดับ การเขียนคำสั่งเพิ่มยุบรวมชุดข้อมูลดังกล่าวตามแถวเป็นดังนี้\n\ndat_rbind <-bind_rows(dat1, dat2, dat3, dat4)\ndat_rbind\n\n# A tibble: 20 × 5\n   student.name Lecture.pre PBL.pre Lecture.post PBL.post\n   <chr>              <dbl>   <dbl>        <dbl>    <dbl>\n 1 บุญมี                   20      NA           45       NA\n 2 บุญมาก                 16      NA           34       NA\n 3 บุญเกิน                 NA      18           NA       67\n 4 บุญถึง                  NA      25           NA       93\n 5 บุญธรรม                13      NA           50       NA\n 6 บุญใหญ่                 NA      17           NA       71\n 7 บุญหนัก                 14      NA           48       NA\n 8 บุญมา                  NA      20           NA       83\n 9 บุญเยอะ                NA      28           NA       75\n10 บุญแฝง                 NA      21           NA       73\n11 บุญดี                   22      NA           32       NA\n12 บุญแรง                 NA      17           NA       68\n13 บุญดัง                  14      NA           70       NA\n14 บุญจริง                 15      NA           64       NA\n15 บุญเติม                 19      NA           55       NA\n16 บุญรอด                 NA      15           NA       82\n17 บุญชอบ                 18      NA           59       NA\n18 บุญผ่อง                 NA      12           NA       68\n19 บุญสืบ                   8      NA           62       NA\n20 บุญเหลือ                NA      25           NA       87\n\n\nสำหรับภาษา Python การยุบรวมชุดข้อมูลตามแถวสามารถดำเนินการได้หลายวิธีการเช่นเดียวกับภาษา R ฟังก์ชันหนึ่งที่สามารถทำได้คือฟังก์ชัน append() ภายใต้ pandas library ตัวอย่างต่อไปนี้แสดงการยุบรวมชุดข้อมูลใน file1.xlsx, file2.xlsx, file3.xlsx และ file4.xlsx ตามแถว ทั้งนี้ในตัวอย่างดังกล่าวได้จัดเก็บข้อมูลทั้ง 4 ไว้ในตัวแปรได้แก่ dat1, dat2, …, dat4 เช่นเดียวกับตัวอย่างของภาษา R ผลลัพธ์ด้านล่างแสดงตัวอย่างของชุดข้อมูล dat1 ที่เก็บอยู่ใน Python\n\n\n\n\ndat1\n\n  student.name  Lecture.pre  PBL.pre  Lecture.post  PBL.post\n0        บุญมี         20.0      NaN          45.0       NaN\n1       บุญมาก         16.0      NaN          34.0       NaN\n2      บุญเกิน          NaN     18.0           NaN      67.0\n3       บุญถึง          NaN     25.0           NaN      93.0\n4      บุญธรรม         13.0      NaN          50.0       NaN\n\ndat1.info()\n\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 5 entries, 0 to 4\nData columns (total 5 columns):\n #   Column        Non-Null Count  Dtype  \n---  ------        --------------  -----  \n 0   student.name  5 non-null      object \n 1   Lecture.pre   3 non-null      float64\n 2   PBL.pre       2 non-null      float64\n 3   Lecture.post  3 non-null      float64\n 4   PBL.post      2 non-null      float64\ndtypes: float64(4), object(1)\nmemory usage: 328.0+ bytes\n\n\nการยุบรวมชุดข้อมูลทั้ง 4 ตามแถวด้วยฟังก์ชัน append() สามารถทำได้ดังนี้\n\nimport pandas as pd\ndat_rbind = dat1.append(dat2)\ndat_rbind\n\n  student.name  Lecture.pre  PBL.pre  Lecture.post  PBL.post\n0        บุญมี         20.0      NaN          45.0       NaN\n1       บุญมาก         16.0      NaN          34.0       NaN\n2      บุญเกิน          NaN     18.0           NaN      67.0\n3       บุญถึง          NaN     25.0           NaN      93.0\n4      บุญธรรม         13.0      NaN          50.0       NaN\n0      บุญใหญ่          NaN     17.0           NaN      71.0\n1      บุญหนัก         14.0      NaN          48.0       NaN\n2        บุญมา          NaN     20.0           NaN      83.0\n3      บุญเยอะ          NaN     28.0           NaN      75.0\n4       บุญแฝง          NaN     21.0           NaN      73.0\n\n\nในกรณีที่มีชุดข้อมูลมากกว่า 2 ชุด ที่ต้องการยุบรวมเข้าด้วยกันตามแถว สามารถใช้ฟังก์ชัน append() เรียงต่อกกันได้ดังตัวอย่างต่อไปนี้\n\ndat_rbind = dat1.append(dat2).append(dat3).append(dat4)\ndat_rbind\n\n  student.name  Lecture.pre  PBL.pre  Lecture.post  PBL.post\n0        บุญมี         20.0      NaN          45.0       NaN\n1       บุญมาก         16.0      NaN          34.0       NaN\n2      บุญเกิน          NaN     18.0           NaN      67.0\n3       บุญถึง          NaN     25.0           NaN      93.0\n4      บุญธรรม         13.0      NaN          50.0       NaN\n0      บุญใหญ่          NaN     17.0           NaN      71.0\n1      บุญหนัก         14.0      NaN          48.0       NaN\n2        บุญมา          NaN     20.0           NaN      83.0\n3      บุญเยอะ          NaN     28.0           NaN      75.0\n4       บุญแฝง          NaN     21.0           NaN      73.0\n0        บุญดี         22.0      NaN          32.0       NaN\n1       บุญแรง          NaN     17.0           NaN      68.0\n2       บุญดัง         14.0      NaN          70.0       NaN\n3      บุญจริง         15.0      NaN          64.0       NaN\n4      บุญเติม         19.0      NaN          55.0       NaN\n0       บุญรอด          NaN     15.0           NaN      82.0\n1       บุญชอบ         18.0      NaN          59.0       NaN\n2      บุญผ่อง          NaN     12.0           NaN      68.0\n3       บุญสืบ          8.0      NaN          62.0       NaN\n4     บุญเหลือ          NaN     25.0           NaN      87.0\n\n\n\n\nการยุบรวมข้อมูลตามคอลัมน์ (columns combined)\nการยุบรวมข้อมูลตามคอลัมน์มีการดำเนินการคล้ายกับการยุบรวมตามแถว แต่เปลี่ยนมิติของการจับคู่เป็นการจับคู่ข้อมูลระหว่างหน่วยข้อมูลเดียวกันที่อยู่ต่างชุดข้อมูลกัน รูป 4.3 แสดงลักษณะของการยุบรวมข้อมูลตามคอลัมน์ จากรูปจะเห็นว่า การยุบรวมข้อมูลลักษณะนี้เป็นการนำชุดข้อมูลหลายชุดของหน่วยข้อมูลเดียวกันหรือมีหน่วยข้อมูลเป็นส่วนย่อยของกันและกัน และมีตัวแปรที่แตกต่างกันมารวมเข้าเป็นชุดข้อมูลเดียวกัน\n\n\n\nรูป 4.3 ตัวอย่างแสดงลักษณะการยุบรวมชุดข้อมูลตามคอลัมน์ (column combined)\n\n\nที่มา : สิวะโชติ ศรีสุทธิยากร (2564)\nการยุบรวมข้อมูลตามคอลัมน์ด้วยภาษา R สามารถดำเนินการได้หลายวิธีการมาก วิธีการแรกคือการใช้ฟังก์ชัน bind_cols() ของ package-dplyr ที่มีการทำงานเหมือนกับฟังก์ชัน bind_rows() แต่จะดำเนินการรวมข้อมูลตามคอลัมน์แทน เงื่อนไขของฟังก์ชันนี้ที่ไม่ค่อยสะดวกนักคือ ชุดข้อมูลที่จะยุบรวมกันตามคอลัมน์ต้องเป็นชุดข้อมูลของหน่วยข้อมูลเดียวกัน แต่มีตัวแปรที่แตกต่างกัน และการจัดเรียงหน่วยข้อมูลต้องเป็นไปในลำดับเดียวกัน ดังในรูป 4.3 ข้างต้น (ผู้อ่านสามารถศึกษารายละเอียดของฟังก์ชัน bind_cols() ได้โดยพิมพ์คำสั่ง ?bind_cols())\nในทางปฏิบัติเมื่อผู้วิเคราะห์ดำเนินการกับข้อมูลขนาดใหญ่หลายชุดที่มาจากฐานข้อมูลที่แตกต่างกัน ชุดข้อมูลดังกล่าวมักจะมีการจัดเรียงลำดับของหน่วยข้อมูลที่แตกต่างกัน นอกจากนี้ชุดข้อมูลทั้งหมดยังอาจมีบางหน่วยข้อมูลที่แตกต่างกันและไม่สามารถยุบรวมกันได้ สถานการณ์ที่ซับซ้อนลักษณะนี้การยุบรวมด้วยฟังก์ชัน bind_cols() จะเป็นวิธีการที่ค่อนข้างลำบาก การใช้กลุ่มฟังก์ชัน join ของ package-dplyr เป็นวิธีการที่เหมาะสมมากกว่า กลุ่มฟังก์ชัน join ดังกล่าวประกอบด้วยฟังก์ชัน 4 ตัวที่ทำงานแตกต่างกัน เพื่อรองรับความต้องการในการยุบรวมข้อมูลตามคอลัมน์ของผู้วิเคราะห์ที่แตกต่างกัน ได้แก่ inner_join(), full_join(), left_join() และ right_join() รูป 4.4 แสดงลักษณะการทำงานของกลุ่มฟังก์ชัน join ดังกล่าว จากรูปจะเห็นความแตกต่างของฟังก์ชันทั้ง 4 ตัวว่าอยู่ที่การเลือกจัดเก็บหรือไม่จัดเก็บหน่วยข้อมูลจากชุดข้อมูลที่จะยุบรวมกันอย่างไร กล่าวคือ inner_join() จะเลือกจัดเก็บเฉพาะหน่วยข้อมูลที่มีร่วมกันระหว่างชุดข้อมูลทั้งสองเท่านั้น ในขณะที่ left_join() จะเก็บหน่วยข้อมูลชุดทางซ้าย (เรียกว่าชุด x) ไว้ทั้งหมด แต่จะเลือกจัดเก็บข้อมูลชุดทางขวา (เรียกว่าชุด y) เฉพาะส่วนที่มีข้อมูลร่วมกันกับชุด x เท่านั้น ฟังก์ชัน right_joint() มีการดำเนินการเหมือนกับ left_join() แต่มีทิศทางการจัดเก็บข้อมูลที่ตรงข้ามกัน ส่วนฟังก์ชัน full_join() จะเก็บหน่วยข้อมูลทุกหน่วยไว้ไม่ว่าหน่วยข้อมูลนั้นจะมีอยู่ร่วมกันในทั้งสองชุดข้อมูลหรือไม่\n ที่มา : สิวะโชติ ศรีสุทธิยากร (2564)\nฟังก์ชันในกลุ่ม join มีอาร์กิวเมนท์ที่สำคัญเหมือนกันได้แก่ x และ y คือชุดข้อมูลที่ต้องการยุบรวมกันตามคอลัมน์ และ by ใช้ระบุตัวแปร id ที่จะใช้จับคู่หน่วยข้อมูลระหว่างชุดข้อมูลทั้งสอง ทั้งนี้การระบุอาร์กิวเมนท์นี้จะต้องระบุเป็นเวกเตอร์ตัวอักษร (character vector)\nตัวอย่างต่อไปนี้แสดงการใช้ฟังก์ชัน join ทั้ง 4 ตัวเพื่อยุบรวมข้อมูลตามคอลัมน์ ชุดข้อมูลที่ใช้เป็นตัวอย่างเป็นชุดข้อมูลที่สร้างขึ้นด้วยการกำหนดค่าด้วยมือ ประกอบด้วยชุดข้อมูล X และ Y สังเกตว่าชุดข้อมูลทั้งหมดมีตัวแปร id ที่ใช้สำหรับอ้างอิงหน่วยข้อมูล นอกจากนี้ชุดข้อมูลทั้งสองมีหน่วยข้อมูลที่เหมือนกันเพียงบางส่วน และมีการจัดเก็บข้อมูลของตัวแปรที่แตกต่างกัน\n\nX<-data.frame(id=c(1,2,3,4),\n              gender = c(\"m\",\"f\",\"f\",\"m\"),\n              income = c(10,5,20,15))\n\nY<-data.frame(id=c(1,2,5,6,7),\n              score = c(30,50,20,100, 75),\n              location = c(\"N\",\"NE\",\"S\",\"C\",\"W\"))\n\n\nX\n\n  id gender income\n1  1      m     10\n2  2      f      5\n3  3      f     20\n4  4      m     15\n\nY\n\n  id score location\n1  1    30        N\n2  2    50       NE\n3  5    20        S\n4  6   100        C\n5  7    75        W\n\n\nผลลัพธ์ที่ได้จากการยุบรวมข้อมูลตามคอลัมน์ด้วยฟังก์ชัน join ทั้ง 4 ตัวเป็นดังนี้ ผู้อ่านลองพิจารณาความแตกต่างของผลลัพธ์ที่ได้จากฟังก์ชันทั้ง 4 ใน output ด้านล่าง\n\ninner_join(X, Y, by = \"id\")\n\n  id gender income score location\n1  1      m     10    30        N\n2  2      f      5    50       NE\n\nleft_join(X, Y, by = \"id\")\n\n  id gender income score location\n1  1      m     10    30        N\n2  2      f      5    50       NE\n3  3      f     20    NA     <NA>\n4  4      m     15    NA     <NA>\n\nright_join(X, Y, by = \"id\")\n\n  id gender income score location\n1  1      m     10    30        N\n2  2      f      5    50       NE\n3  5   <NA>     NA    20        S\n4  6   <NA>     NA   100        C\n5  7   <NA>     NA    75        W\n\nfull_join(X, Y, by = \"id\")\n\n  id gender income score location\n1  1      m     10    30        N\n2  2      f      5    50       NE\n3  3      f     20    NA     <NA>\n4  4      m     15    NA     <NA>\n5  5   <NA>     NA    20        S\n6  6   <NA>     NA   100        C\n7  7   <NA>     NA    75        W\n\n\nในภาษา Python มีฟังก์ชันที่เทียบเคียงได้กับกลุ่มฟังก์ชัน join ของภาษา R เช่นเดียวกันได้แก่ ฟังก์ชัน merge() ภายใต้ pandas library ฟังก์ชันดังกล่าวมีพารามิเตอร์ที่สำคัญได้แก่ left และ right ใช้ระบุชุดข้อมูลทางซ้ายและทางขวาสำหรับการยุบรวม on ใช้ระบุ id สำหรับการจับคู่หน่วยข้อมูลเดียวกันระหว่างสองชุดข้อมูลที่ต้องการยุบรวมกัน และ how ใช้ระบุลักษณะของการยุบรวมระหว่างชุดข้อมูล โดยสามารถเลือกกำหนดได้ 4 แบบเช่นเดียวกับภาษา R ได้แก่ inner, left, right และ outer โดยที่ outer จะเทียบเท่ากับ full_join() ในภาษา R ข้างต้น\nตัวอย่างต่อไปนี้แสดงการใช้ฟังก์ชัน pd.merge() เพื่อยุบรวมชุดข้อมูล X และ Y ด้านล่าง ด้วยวิธีการทั้ง 4 แบบ\n\nX = {'id': [1,2,3,4],\n     'gender': [\"m\",\"f\",\"f\",\"m\"],\n     'income': [10,5,20,15]}\n\nY = {'id': [1,2,5,6,7],\n    'score': [30,50,20,100, 75],\n    'location': [\"N\",\"NE\",\"S\",\"C\",\"W\"]}\n    \nX = pd.DataFrame(X)\nY = pd.DataFrame(Y)\n\n\nX\n\n   id gender  income\n0   1      m      10\n1   2      f       5\n2   3      f      20\n3   4      m      15\n\nY\n\n   id  score location\n0   1     30        N\n1   2     50       NE\n2   5     20        S\n3   6    100        C\n4   7     75        W\n\n\n\npd.merge(X, Y, on=\"id\", how=\"inner\")\n\n   id gender  income  score location\n0   1      m      10     30        N\n1   2      f       5     50       NE\n\npd.merge(X, Y, on=\"id\", how=\"left\")\n\n   id gender  income  score location\n0   1      m      10   30.0        N\n1   2      f       5   50.0       NE\n2   3      f      20    NaN      NaN\n3   4      m      15    NaN      NaN\n\npd.merge(X, Y, on=\"id\", how=\"right\")\n\n   id gender  income  score location\n0   1      m    10.0     30        N\n1   2      f     5.0     50       NE\n2   5    NaN     NaN     20        S\n3   6    NaN     NaN    100        C\n4   7    NaN     NaN     75        W\n\npd.merge(X, Y, on=\"id\", how=\"outer\")\n\n   id gender  income  score location\n0   1      m    10.0   30.0        N\n1   2      f     5.0   50.0       NE\n2   3      f    20.0    NaN      NaN\n3   4      m    15.0    NaN      NaN\n4   5    NaN     NaN   20.0        S\n5   6    NaN     NaN  100.0        C\n6   7    NaN     NaN   75.0        W"
  },
  {
    "objectID": "import.html",
    "href": "import.html",
    "title": "ตอนที่ 4.1 การนำเข้าและเขียนชุดข้อมูล (importing and writing data)",
    "section": "",
    "text": "การนำเข้าข้อมูลถือได้ว่าเป็นขั้นตอนแรกของการดำเนินงานวิเคราะห์ข้อมูล ในบทเรียนนี้จะกล่าวถึงการนำเข้าข้อมูลลักษณะต่าง ๆ ในภาษา R และ Python รวมทั้งการเขียนชุดข้อมูลเป็นไฟล์ข้อมูลเพื่อนำไปใช้ตามวัตถุประสงค์ต่าง ๆ บทเรียนนี้จะกล่าวถึงการนำเข้าไฟล์ข้อมูลที่มักใช้ในการทำงานทางด้านสถิติและวิทยาการข้อมูล ได้แก่ ไฟล์ข้อมูลประเภท flat file และไฟล์ข้อมูลประเภท spreadsheet รายละเอียดมีดังนี้"
  },
  {
    "objectID": "import.html#เรองท-4.1.1-การนำเขาขอมลประเภท-flat-file",
    "href": "import.html#เรองท-4.1.1-การนำเขาขอมลประเภท-flat-file",
    "title": "ตอนที่ 4.1 การนำเข้าและเขียนชุดข้อมูล (importing and writing data)",
    "section": "เรื่องที่ 4.1.1 การนำเข้าข้อมูลประเภท flat file",
    "text": "เรื่องที่ 4.1.1 การนำเข้าข้อมูลประเภท flat file\nflat files เป็นไฟล์ข้อมูลที่อยู่ในรูปแบบข้อความ (plain text) และชุดข้อมูลไม่ได้มีโครงสร้างการจัดเก็บในรูปแบบตารางหรือ spreadsheet แต่ flat file จะมีการใช้ตัวอักษรพิเศษ เช่น comma (,), slash (/) หรือ underscore (_) เป็นตัวคั่น (separator or delimiter) เพื่อจำแนกข้อมูลที่แตกต่างกันออกจากกัน รูป 4.1 แสดงลักษณะของชุดข้อมูลแบบ flat file ที่มีการใช้ตัวคั่นแบบ comma (,) และแบบเว้นวรรค (tab) จากรูปจะเห็นว่าตัวอย่างของไฟล์ข้อมูลทั้งสองมีโครงสร้างการจัดเก็บข้อมูลที่เหมือนกันกล่าวคือ ในแถวแรกของไฟล์ข้อมูลเป็นที่จัดเก็บชื่อของตัวแปรภายในชุดข้อมูล และตั้งแต่แถวที่สองเป็นต้นไปเป็นที่จัดเก็บข้อมูลของตัวแปรต่าง ๆ ของแต่ละหน่วยข้อมูล อย่างไรก็ตามในทางปฏิบัติแถวแรกของไฟล์ข้อมูลไม่จำเป็นจะต้องเป็นชื่อของตัวแปรเสมอไป\n\n\n\nรูป 4.1 ตัวอย่างโครงสร้างของ flat file แบบ CSV และ TSV\n\n\nที่มา : สิวะโชติ ศรีสุทธิยากร (2564)\nflat file ยังมีการเรียกชื่อที่เฉพาะตามลักษณะของตัวคั่นที่ใช้ในชุดข้อมูล จากรูปจะเห็นว่าชุดข้อมูลด้านบนมีการใช้ comma (,) เป็นตัวคั่น จะเรียกไฟล์ข้อมูลประเภทนี้ว่า comma separated values (CSV) หรืออาจเรียกว่า comma-delimited ก็ได้ ส่วนชุดข้อมูลด้านล่างของรูปมีการใช้ตัวคั่นเป็นการเว้นวรรค (tab) จะเรียกชุดข้อมูลประเภทนี้ว่า tab separated values (TSV) หรือ tab-delimited\n\nการนำเข้าและเขียนไฟล์แบบ CSV\nหัวข้อนี้จะกล่าวถึงวิธีการนำเข้าและเขียนไฟล์ข้อมูลแบบ CSV โดยจำแนกเนื้อหาออกเป็นสองส่วนได้แก่ ส่วนของภาษา R และ ภาษา Python รายละเอียดมีดังนี้\n\nภาษา R\nภาษา R สามารถนำเข้าและเขียนไฟล์ CSV ได้หลายวิธี วิธีการแรกเป็นการนำเข้าด้วยฟังก์ชันจาก package-utils ที่เป็น package พื้นฐานของ R ได้แก่ฟังก์ชัน read.csv() ที่มีอาร์กิวเมนท์สำคัญได้แก่ file ใช้ระบุที่อยู่และชื่อของไฟล์ข้อมูลแบบ CSV ที่ต้องการนำเข้าอาร์กิวเมนท์นี้ผู้วิเคราะห์จำเป็นต้องกำหนดแบบตัวแปรตัวอักษร (กล่าวคือต้องระบุไว้ภายใต้เครื่องหมาย quotation) อาร์กิวเมนท์ header ใช้ระบุว่าไฟล์ข้อมูลที่นำเข้ามีแถวแรกของไฟล์เป็นชื่อของตัวแปรหรือไม่ การกำหนดอาร์กิวเมนท์นี้กำหนดเป็นค่าความจริงได้แก่ TRUE หรือ FALSE โดยหากกำหนดเป็น TRUE (ค่าเริ่มต้น) จะหมายถึงการระบุว่าใช้แถวแรกของไฟล์ข้อมูลเป็นชื่อของตัวแปรในแต่ละคอลัมน์ ในกรณีที่กำหนดเป็น FALSE ฟังก์ชัน CSV จะกำหนดชื่อของคอลัมน์ให้โดยอัตโนมัติ ตัวอย่างด้านล่างแสดงการนำเข้าชุดข้อมูล gapminder_mini.csv\n\n# R syntax\ndat <- read.csv(\"gapminder_mini.csv\", header = TRUE)\nstr(dat)\n\n\n\n'data.frame':   142 obs. of  4 variables:\n $ X        : int  1 2 3 4 5 6 7 8 9 10 ...\n $ country  : chr  \"Afghanistan\" \"Albania\" \"Algeria\" \"Angola\" ...\n $ gdpPercap: num  975 5937 6223 4797 12779 ...\n $ lifeExp  : num  43.8 76.4 72.3 42.7 75.3 ...\n\n\nอาร์กิวเมนท์อีกตัวที่สำคัญของฟังก์ชัน read.csv() คืออาร์กิวเมนท์ na.strings ใช้ในกรณีที่ชุดข้อมูลที่ต้องการนำเข้ามีค่าสูญหาย การระบุอาร์กิวเมนท์ดังกล่าวให้ระบุเป็นสัญลักษณ์ที่ใช้แทนค่าสูญหายของชุดข้อมูลที่ต้องการนำเข้า เช่น หากชุดข้อมูลที่นำเข้าใช้สัญลักษณ์ -999 แทนค่าสูญหายให้กำหนด na.strings = -999 เป็นต้น นอกจากนี้ฟังก์ชัน read.csv() ยังมีอาร์กิวเมนท์ stringsAsFactors ที่กำหนดค่าเป็น TRUE หรือ FALSE เพื่อแปลงคอลัมน์ตัวอักษรในชุดข้อมูลให้เป็นตัวแปรแบบ factor ซึ่งเป็นตัวแปรแบบจัดประเภทของ R ผู้อ่านสามารถศึกษารายละเอียดเพิ่มเติมได้จาก สิวะโชติ ศรีสุทธิยากร (2564) หน้า 40\nตัวอย่างข้างต้นมีการใช้ฟังก์ชัน str() เพื่อเรียกดูข้อมูลเบื้องต้นของชุดข้อมูล gapminder_mini.csv ที่นำเข้ามาด้วยฟังก์ชัน read.csv() ในข้างต้น ฟังก์ชันดังกล่าวจะรายงานมิติหรือขนาดของชุดข้อมูล ชื่อของตัวแปรในแต่ละคอลัมนท์ รวมทั้งคุณลักษณะของตัวแปรภายในแต่ละคอลัมน์ สำหรับผู้ที่เคยใช้ SPSS จะพอเทียบเคียงได้ว่าผลลัพธ์จากฟังก์ชัน str() นี้จะให้สารสนเทศในทำนองเดียวกับหน้าต่าง variable view ของโปรแกรม SPSS รายละเอียดของฟังก์ชันนี้จะกล่าวอีกครั้งหนึ่งในหัวข้อ 4.2\nภาษา R ยังมีความสามารถในการเขียนไฟล์ชุดข้อมูลเพื่อส่งออกไปบันทึกในคอมพิวเตอร์สำหรับนำไปใช้ในวัตถุประสงค์ต่าง ๆ การเขียนไฟล์แบบ CSV สามารถทำได้หลายวิธีการเช่นกัน วิธีการพื้นฐานคือการใช้ฟังก์ชัน write.csv() ที่มีอาร์กิวเมนท์สำคัญ 2 ตัวได้แก่ x คือชุดข้อมูลแบบ Dataframe ที่ต้องการเขียนออกไปเป็นไฟล์แบบ CSV และ file ใช้ระบุที่อยู่และชื่อของไฟล์ปลายทางที่จะให้ R เขียนออกไปบันทึกในคอมพิวเตอร์ ทั้งนี้รูปแบบของชื่อไฟล์ต้องเขียนในลักษณะตัวอักษรกล่าวคืออยู่ภายใต้เครื่องหมาย quotation และมีนามสกุลของไฟล์เป็นแบบ `*.csv` ดังตัวอย่างด้านล่าง\n\n# R syntax\nwrite.csv(dat, file=\"Desktop/mydata.csv\")\n\nคำสั่งด้านบนจะเขียนไฟล์ my.data.csv ไว้บน Desktop ของเครื่องคอมพิวเตอร์ ในกรณีที่ผู้วิเคราะห์กำหนดแค่ชื่อไฟล์ปลายทางแต่ไม่ได้กำหนดที่อยู่ของไฟล์ เช่น write.csv(dat, file=\"mydata.csv\") ไฟล์ที่สร้างขึ้นจะบันทึกไว้ใน folder เป็นค่าเริ่มต้นหรือ folder ที่กำหนดเป็น working directory เอาไว้ การกำหนด working directory สามารถทำได้โดยใช้ฟังก์ชัน setwd() โดยภายในฟังก์ชันให้ใส่ที่อยู่ของ folder ที่ต้องการกำหนดให้เป็น working directory ในลักษณะตัวอักษร เช่น setwd(\"/Desktop/myjob\") หมายถึงกำหนดให้ working directory เป็น folder myjob ที่อยู่บน Desktop ของเครื่องคอมพิวเตอร์ รายละเอียดอื่น ๆ เกี่ยวกับการกำหนด working directory ใน R สามารถศึกษาเพิ่มเติมได้จาก สิวะโชติ ศรีสุทธิยากร (2564)\nรูปด้านล่างแสดงลักษณะของไฟล์ข้อมูล mydata.csv ที่เขียนออกจากโปรแกรม R ด้วยคำสั่งในข้างต้น จากรูปใช้โปรแกรม text editor เพื่อเปิดไฟล์ดังกล่าว\n\n\n\nไฟล์ข้อมูล myCSV.csv\n\n\nโดยปกติแล้ว MS Excel หรือ Number หรือ googlesheet มีตัวอ่านไฟล์ข้อมูลประเภท flatfile อยู่แล้วผู้อ่านสามารถใช้โปรแกรมดังกล่าวเพื่อเปิดไฟล์ข้อมูลประเภท CSV หรือ flatfile ประเภทอื่น ๆ ได้โดยง่าย\n\n\nภาษา Python\nสำหรับการนำเข้าและเขียนไฟล์ข้อมูลแบบ CSV ด้วยภาษา Python สามารถทำได้โดยใช้ฟังก์ชัน pd.read_csv() ของ pandas library ฟังก์ชันนี้มีพารามิเตอร์ได้แก่ filepath ใช้กำหนดที่อยู่และชื่อของไฟล์ที่ต้องการนำเข้า พารามิเตอร์ sep สำหรับระบุตัวอักษรที่ใช้เป็นตัวคั่นในชุดข้อมูล ซึ่งในกรณีนี้จะกำหนดให้ sep=\",\" เพื่อนำเข้าชุดข้อมูลแบบ CSV พารามิเตอร์ header สำหรับระบุว่าแถวที่เท่าไหร่ในตารางข้อมูลจะใช้เป็นชื่อของตัวแปร (เริ่มจาก 0) พารามิเตอร์ skiprows ใช้กำหนดให้ Python อ่านไฟล์ข้อมูลโดยข้ามแถวไปจำนวนเท่ากับที่กำหนด พารามิเตอร์นี้มีประโยชน์มากสำหรับการนำเข้าไฟล์ข้อมูลจากองค์กร หรือ logfile ที่หัวของตารางมักมีคำอธิบายหรือ caption ต่าง ๆ ก่อนที่จะเป็นส่วนของตารางข้อมูล ฟังก์ชัน pd.read_csv() ยังมีพารามิเตอร์อีกหลายตัว (optional parameters) ที่สามารถกำหนดเพื่อปรับแต่งลักษณะของข้อมูลที่นำเข้ามาได้ รายละเอียดอื่น ๆ ผู้อ่านสามารถศึกษาเพิ่มเติมได้จาก https://pandas.pydata.org/docs/reference/api/pandas.read_csv.html\n\n# Python syntax\nimport pandas as pd\ndat = pd.read_csv(\"/Users/siwachoat/Downloads/gapminder.csv\", header=0)\ndat\n\n     Unnamed: 0             country     gdpPercap  lifeExp\n0             1         Afghanistan    974.580338   43.828\n1             2             Albania   5937.029526   76.423\n2             3             Algeria   6223.367465   72.301\n3             4              Angola   4797.231267   42.731\n4             5           Argentina  12779.379640   75.320\n..          ...                 ...           ...      ...\n137         138             Vietnam   2441.576404   74.249\n138         139  West Bank and Gaza   3025.349798   73.422\n139         140         Yemen, Rep.   2280.769906   62.698\n140         141              Zambia   1271.211593   42.384\n141         142            Zimbabwe    469.709298   43.487\n\n[142 rows x 4 columns]\n\n\nการเขียนไฟล์ CSV ด้วยภาษา Python สามารถทำได้หลายวิธี วิธีการหนึ่งคือการใช้ method to_csv() ซึ่งเป็น method หนึ่งภายใต้ pandas library พารามิเตอร์สำคัญของ method นี้ได้แก่ ตัวอย่างด้านล่างแสดงการเขียนไฟล์ข้อมูลใน Python เพื่อบันทึกลงใน folder ที่กำหนดไว้บนเครื่องคอมพิวเตอร์ สมมุติว่าผู้วิเคราะห์สร้างชุดข้อมูลใน Python เพื่อเก็บข้อมูลคะแนนสอบของนิสิตในรายวิชาแคลคูลัส (calculus) สถิติ (statistics) และคณิตศาสตร์ (math) การเขียนไฟล์ข้อมูลดังกล่าวเป็นไฟล์ CSV สามารถทำได้ดังนี้\n\nimport pandas as pd\nheader = [\"students\",\"calculus\",\"statistics\",\"math\"]\nrow_data = [[1,80,75,70],\n            [2,40,55,60],\n            [3,84,85,86],\n            [4,51,38,43],\n            [5,67,73,77]]\ndata = pd.DataFrame(row_data, columns=header)\ndata\n\n   students  calculus  statistics  math\n0         1        80          75    70\n1         2        40          55    60\n2         3        84          85    86\n3         4        51          38    43\n4         5        67          73    77\n\ndata.to_csv(\"myCSV.csv\", sep=\",\")\n\nผู้อ่านสามารถศึกษารายละเอียดของ to_csv() ได้จาก https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.to_csv.html\n\n\n\nการนำเข้าและเขียนไฟล์แบบ TSV\nดังที่กล่าวไปแล้วข้างต้น ไฟล์แบบ TSV เป็นไฟล์ข้อมูลแบบ flat file ที่มีการใช้ตัวคั่นข้อมูลเป็นเครื่องหมายเว้นวรรค (tab) การนำเข้าไฟล์ข้อมูล TSV การนำเข้าและเขียนไฟล์ลักษณะดังกล่าวของแต่ละภาษาจึงสามารถดำเนินการได้ในทำนองเดียวกับไฟล์แบบ CSV รายละเอียดมีดังนี้\n\nภาษา R\nในภาษา R สามารถทำได้โดยใช้ฟังก์ชัน read.table() โดยอาร์กิวเมนท์ของฟังก์ชันนี้มีส่วนของอาร์กิวเมนท์จำเป็นที่เหมือนกับของฟังก์ชัน read.csv() ได้แก่ file ที่ใช้ระบุที่อยู่และชื่อของไฟล์ข้อมูลที่ต้องการนำเข้า โดยจะต้องระบุในลักษณะของตัวแปรตัวอักษรใน R กล่าวคือต้องระบุภายใต้เครื่องหมาย quotation อาร์กิวเมนท์ header ที่กำหนดได้ 2 ค่าคือ TRUE และ FALSE โดยที่ค่าเริ่มต้นคือ header=FALSE ซึ่งหมายความว่าตารางข้อมูลที่จะนำเข้ามานั้นเป็นตารางที่ไม่มีหัวตาราง และอาร์กิวเมนท์ sep ใช้ระบุลักษณะของตัวคั่นข้อมูลที่ใช้ในไฟล์ข้อมูล อาร์กิวเมนท์นี้จึงทำให้ฟังก์ชัน read.table() สามารถนำเข้า flat file ได้หลายประเภทไม่ได้จำกัดแค่เฉพาะ CSV หรือ TSV เท่านั้น นอกจากนี้ยังมีอาร์กิวเมนท์ skip ที่ทำงานเหมือนกับพารามิเตอร์ skiprows ในฟังก์ชัน pd.read_csv() ของภาษา Python ฟังก์ชัน read.table() เป็นฟังก์ชันที่มีอาร์กิวเมนท์ที่สามารถกำหนดได้จำนวนมาก รายละเอียดอื่น ๆ เกี่ยวข้องผู้อ่านสามารถศึกษาได้จากคู่มือของฟังก์ชันโดยพิมพ์คำสั่ง ?read.table()\nจากที่กล่าวในข้างต้นจะเห็นว่า read.table() เป็นฟังก์ชันทั่วไปของ read.csv() ตัวอย่างต่อไปนี้แสดงให้เห็นว่าสามารถใช้ฟังก์ชัน read.table() เพื่อนำเข้าไฟล์แบบ CSV ได้\n\ndat <- read.table(\"/Users/siwachoat/Downloads/gapminder.csv\", header=TRUE, sep=\",\")\nhead(dat)\n\n  X     country  gdpPercap lifeExp\n1 1 Afghanistan   974.5803  43.828\n2 2     Albania  5937.0295  76.423\n3 3     Algeria  6223.3675  72.301\n4 4      Angola  4797.2313  42.731\n5 5   Argentina 12779.3796  75.320\n6 6   Australia 34435.3674  81.235\n\n\nชุดข้อมูล myTSV.txt เป็นชุดข้อมูลแบบ flat file ที่มีการใช้ตัวคั่นเป็นเครื่องหมายเว้นวรรค (tab) การนำชุดข้อมูลดังกล่าวเข้าสู่โปรแกรม R ด้วยฟังก์ชัน read.table() สามารถทำได้โดยกำหนดอาร์กิวเมนท์ sep = \" \" ดังตัวอย่างต่อไปนี้\n\ndat_TSV <- read.table(\"https://raw.githubusercontent.com/ssiwacho/dataset/main/myTSV.txt\",\n                      header = TRUE, sep = \" \")\ndat_TSV\n\n  X students calculus statistics math\n1 0        1       80         75   70\n2 1        2       40         55   60\n3 2        3       84         85   86\n4 3        4       51         38   43\n5 4        5       67         73   77\n\n\nในทำนองเดียวกับการนำเข้าและเขียนไฟล์ CSV การเขียนไฟล์ TSV สามารถทำได้โดยใช้ฟังก์ชัน write.table() ที่มีอาร์กิวเมนท์สำคัญเหมือนกับฟังก์ชัน write.csv() ทุกประการ ความแตกต่างระหว่าง write.table() กับ write.csv() อันหนึ่งคือฟังก์ชัน write.table() มีอาร์กิวเมนท์ sep ที่ทำให้ผู้วิเคราะห์สามารถเลือกกำหนดได้ว่าจะเขียนไฟล์ข้อมูลของตนเองโดยใช้ตัวคั่นแบบใด ตัวอย่างต่อไปนี้แสดงการเขียนไฟล์ TSV ด้วยฟังก์ชัน write.table() จากชุดข้อมูลแบบ data.frame ที่สร้างเองบนโปรแกรม R\n\n#เพศของนักเรียน\ngender <- c(\"M\",\"M\",\"F\",\"F\",\"F\",\"M\") \n#วิธีการสอนของครู\nmethod <- c(\"LEC\",\"LEC\",\"LEC\",\"PBL\",\"PBL\",\"PBL\") \n# คะแนนสอบวิชา Eng\neng <- c(6, 5.5, 7, 7, 8, 8.5)\n\nmydat<-data.frame(gender, method, eng)\nmydat\n\n  gender method eng\n1      M    LEC 6.0\n2      M    LEC 5.5\n3      F    LEC 7.0\n4      F    PBL 7.0\n5      F    PBL 8.0\n6      M    PBL 8.5\n\n\nชุดคำสั่งข้างต้นเป็นการสร้างชุดข้อมูลแบบ data.frame ในโปรแกรม R ด้วยฟังก์ชัน data.frame() โดยเก็บชุดข้อมูลดังกล่าวเอาไว้ในตัวแปรชื่อ mydat การเขียนชุดข้อมูลนี้ออกไปบนเครื่องคอมพิวเตอร์เพื่อเก็บเป็นไฟล์ข้อมูลประเภท TSV สามารถดำเนินการได้ด้วยฟังก์ชัน write.table() ดังนี้\n\nwrite.table(mydat, file=\"mytsvfromR.txt\", sep=\" \")\n\nรูปต่อไปนี้แสดงลักษณะของไฟล์ข้อมูล mstsvformR.txt ที่เขียนด้วยฟังก์ชัน write.table() ในข้างต้น จากรูปไฟล์ข้อมูลดังกล่าวเปิดด้วยโปรแกรม text editor\n\n\n\nไฟล์ข้อมูล mytsvfromR.txt\n\n\n\n\nภาษา Python\nสำหรับภาษา Python การนำเข้าและเขียนไฟล์ TSV รวมทั้ง flat file แบบอื่น ๆ สามารถทำได้ด้วยฟังก์ชัน pd.read_csv() โดยเปลี่ยนค่าของพารามิเตอร์ sep ให้ตรงกับตัวคั่นที่ใช้ในไฟล์ข้อมูล ยกตัวอย่างเช่น หากต้องการนำเข้าชุดข้อมูล myTSV.txt สามารถดำเนินการได้ดังนี้\n\ndat_TSV = pd.read_csv(\"https://raw.githubusercontent.com/ssiwacho/dataset/main/myTSV.txt\",\n                      header = 0, sep = \" \")\ndat_TSV\n\n   Unnamed: 0  students  calculus  statistics  math\n0           0         1        80          75    70\n1           1         2        40          55    60\n2           2         3        84          85    86\n3           3         4        51          38    43\n4           4         5        67          73    77"
  },
  {
    "objectID": "tidy.html#เรองท-4.2.1-การสำรวจลกษณะของชดขอมล",
    "href": "tidy.html#เรองท-4.2.1-การสำรวจลกษณะของชดขอมล",
    "title": "ตอนที่ 4.2 การจัดระเบียบข้อมูล (tidying data)",
    "section": "เรื่องที่ 4.2.1 การสำรวจลักษณะของชุดข้อมูล",
    "text": "เรื่องที่ 4.2.1 การสำรวจลักษณะของชุดข้อมูล\nในหัวข้อนี้จะใช้ชุดข้อมูล gapminder (Bryan, 2017) ที่ประกอบด้วยข้อมูลเกี่ยวกับจำนวนประชากร (pop) ผลิตภัณฑ์มวลรวมในประเทศต่อหัว (gdpPercap) และอายุขัยเฉลี่ยของประชากร (lifeExp) ของประเทศต่าง ๆ เป็นตัวอย่างประกอบการอธิบาย เมื่อผู้วิเคราะห์นำข้อมูล gapminder เข้าสู่โปรแกรมแล้วเรียกดูชุดข้อมูลจะได้ผลลัพธ์ที่มีลักษณะดังนี้\n\n\n       country continent year lifeExp      pop gdpPercap\n1  Afghanistan      Asia 1952  28.801  8425333  779.4453\n2  Afghanistan      Asia 1957  30.332  9240934  820.8530\n3  Afghanistan      Asia 1962  31.997 10267083  853.1007\n4  Afghanistan      Asia 1967  34.020 11537966  836.1971\n5  Afghanistan      Asia 1972  36.088 13079460  739.9811\n6  Afghanistan      Asia 1977  38.438 14880372  786.1134\n7  Afghanistan      Asia 1982  39.854 12881816  978.0114\n8  Afghanistan      Asia 1987  40.822 13867957  852.3959\n9  Afghanistan      Asia 1992  41.674 16317921  649.3414\n10 Afghanistan      Asia 1997  41.763 22227415  635.3414\n\n\n\n\n      country continent year lifeExp      pop gdpPercap\n1695 Zimbabwe    Africa 1962  52.358  4277736  527.2722\n1696 Zimbabwe    Africa 1967  53.995  4995432  569.7951\n1697 Zimbabwe    Africa 1972  55.635  5861135  799.3622\n1698 Zimbabwe    Africa 1977  57.674  6642107  685.5877\n1699 Zimbabwe    Africa 1982  60.363  7636524  788.8550\n1700 Zimbabwe    Africa 1987  62.351  9216418  706.1573\n1701 Zimbabwe    Africa 1992  60.377 10704340  693.4208\n1702 Zimbabwe    Africa 1997  46.809 11404948  792.4500\n1703 Zimbabwe    Africa 2002  39.989 11926563  672.0386\n1704 Zimbabwe    Africa 2007  43.487 12311143  469.7093\n\n\nผลลัพธ์ข้างต้นจะเห็นว่าชุดข้อมูล gapminder ประกอบด้วยตัวแปรทั้งหมด 6 ตัว ได้แก่ ประเทศ (country) ทวีป (continent) ปี (year) อายุขัยเฉลี่ยของประชากร (lifeExp) จำนวนประชากร (pop) และผลิตภัณฑ์มวลรวมต่อหัวภายในประเทศ (gdpPercap) ผู้อ่านจะสังเกตเห็นว่าการเรียนดูข้อมูลทั้งชุดขึ้นมาโดยตรงดังตัวอย่างข้างต้นเป็นวิธีการที่ไม่มีประสิทธิภาพในการสำรวจข้อมูล ทั้งนี้เป็นเพราะในสถานการณ์ที่ข้อมูลมีจำนวนมาก วิธีการดังกล่าวจะให้รายละเอียดของชุดข้อมูลที่มากเกินไปโดยไม่จำเป็น นอกจากนี้ยังมีโอกาสสูงที่จะเกิดปัญหาข้อมูลล้นหน้าจอแสดงผล จนผู้วิเคราะห์ไม่สามารถทราบสภาพของชุดข้อมูลดังกล่าวได้อย่างสะดวก\nในทางปฏิบัติการสำรวจชุดข้อมูลต่าง ๆ ผู้วิเคราะห์จะไม่ได้เรียกดูหรือสำรวจชุดข้อมูลทั้งหมดโดยตรง แต่จะใช้ module ของโปรแกรมวิเคราะห์ข้อมูลช่วยในการสำรวจ module ดังกล่าวจะทำหน้าที่สรุปสารสนเทศที่จำเป็นสำหรับการทำความเข้าใจสภาพของชุดข้อมูลดังกล่าว ได้แก่ การเรียกดูรายการและสถานะของตัวแปรในชุดข้อมูล และการเรียกดูส่วนหัวและส่วนท้ายของชุดข้อมูล รายละเอียดมีดังนี้\n\nการเรียกดูรายการและสถานะของตัวแปร\nวิธีการเรียกดูผลลัพธ์ส่วนนี้จะแตกต่างกันไปขึ้นอยู่กับผู้วิเคราะห์ว่าใช้โปรแกรมใด เช่น ในกรณีที่ใช้ภาษา R อาจเลือกใช้ฟังก์ชัน str() หรือ glimpse() หรือในกรณีที่ใช้ภาษา Python อาจเลือก method info() ภายใต้ pandas library เป็นต้น ผลการวิเคราะห์ด้านล่างแสดงผลลัพธ์ในภาษา R และ Python ดังกล่าว\n\n# R syntax\nlibrary(dplyr)\nglimpse(gapminder)\n\nRows: 1,704\nColumns: 6\n$ country   <fct> \"Afghanistan\", \"Afghanistan\", \"Afghanistan\", \"Afghanistan\", …\n$ continent <fct> Asia, Asia, Asia, Asia, Asia, Asia, Asia, Asia, Asia, Asia, …\n$ year      <int> 1952, 1957, 1962, 1967, 1972, 1977, 1982, 1987, 1992, 1997, …\n$ lifeExp   <dbl> 28.801, 30.332, 31.997, 34.020, 36.088, 38.438, 39.854, 40.8…\n$ pop       <int> 8425333, 9240934, 10267083, 11537966, 13079460, 14880372, 12…\n$ gdpPercap <dbl> 779.4453, 820.8530, 853.1007, 836.1971, 739.9811, 786.1134, …\n\n\n\n# Python syntax\nimport pandas\ngapminder.info()\n\n\n\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 1704 entries, 0 to 1703\nData columns (total 6 columns):\n #   Column     Non-Null Count  Dtype   \n---  ------     --------------  -----   \n 0   country    1704 non-null   category\n 1   continent  1704 non-null   category\n 2   year       1704 non-null   int32   \n 3   lifeExp    1704 non-null   float64 \n 4   pop        1704 non-null   int32   \n 5   gdpPercap  1704 non-null   float64 \ndtypes: category(2), float64(2), int32(2)\nmemory usage: 50.4 KB\n\n\nเมื่อพิจารณาผลลัพธ์จากภาษา R ข้างต้นแสดงให้เห็นว่าในชุดข้อมูล gapminder ประกอบด้วยข้อมูลจำนวน 1,704 หน่วย และมีจำนวน 6 คอลัมน์ โดยมีการรายงานชื่อของตัวแปรในแต่ละคอลัมน์ พร้อมทั้งระบุสถานะของตัวแปรดังกล่าว เช่น ตัวแปร country มีสถานะเป็นตัวแปรประเภทปัจจัย (fct) หรือตัวแปร year มีสถานะเป็นตัวแปรตัวเลขจำนวนเต็ม (int) หรือตัวแปร gdrPercap มีสถานะเป็นตัวแปรประเภทจำนวนจริง (dbl) เป็นต้น ผลลัพธ์นี้ช่วยให้ผู้วิเคราะห์ทราบว่าการนำเข้าข้อมูลดังกล่าว นำเข้ามาอย่างถูกต้องหรือไม่ หากมีตัวแปรใดที่ถูกจัดเก็บอยู่ในสถานะที่ไม่เหมาะสม ผู้วิเคราะห์ก็สามารถดำเนินการแก้ไขปรับเปลี่ยนให้เหมาะสมได้ และเมื่อพิจารณาผลลัพธ์จากภาษา Python พบว่าให้สารสนเทศในลักษณะเดียวกับภาษา R\n\n\nการเรียกดูส่วนหัวและส่วนท้ายของชุดข้อมูล\nวิธีการนี้เป็นวิธีการง่าย ๆ ที่ช่วยให้ผู้วิเคราะห์ทำความเข้าใจโครงสร้างของตารางข้อมูล ขอบเขตของตัวแปร รวมทั้งลักษณะของค่าสังเกตบางส่วนที่จัดเก็บอยู่ในชุดข้อมูล การดำเนินการส่วนนี้ด้วยภาษา R สามารถทำได้โดยใช้ฟังก์ชัน head() และ tail() ดังนี้\n\n# R syntax\nhead(gapminder)\n\n# A tibble: 6 × 6\n  country     continent  year lifeExp      pop gdpPercap\n  <fct>       <fct>     <int>   <dbl>    <int>     <dbl>\n1 Afghanistan Asia       1952    28.8  8425333      779.\n2 Afghanistan Asia       1957    30.3  9240934      821.\n3 Afghanistan Asia       1962    32.0 10267083      853.\n4 Afghanistan Asia       1967    34.0 11537966      836.\n5 Afghanistan Asia       1972    36.1 13079460      740.\n6 Afghanistan Asia       1977    38.4 14880372      786.\n\n\n\n# R syntax\ntail(gapminder)\n\n# A tibble: 6 × 6\n  country  continent  year lifeExp      pop gdpPercap\n  <fct>    <fct>     <int>   <dbl>    <int>     <dbl>\n1 Zimbabwe Africa     1982    60.4  7636524      789.\n2 Zimbabwe Africa     1987    62.4  9216418      706.\n3 Zimbabwe Africa     1992    60.4 10704340      693.\n4 Zimbabwe Africa     1997    46.8 11404948      792.\n5 Zimbabwe Africa     2002    40.0 11926563      672.\n6 Zimbabwe Africa     2007    43.5 12311143      470.\n\n\nส่วนภาษา Python สามารถทำได้โดยใช้ method head() และ tail() ของ pandas libary ดังนี้\n\n# Python syntax\ngapminder.head()\n\n\n\n       country continent  year  lifeExp       pop   gdpPercap\n0  Afghanistan      Asia  1952   28.801   8425333  779.445314\n1  Afghanistan      Asia  1957   30.332   9240934  820.853030\n2  Afghanistan      Asia  1962   31.997  10267083  853.100710\n3  Afghanistan      Asia  1967   34.020  11537966  836.197138\n4  Afghanistan      Asia  1972   36.088  13079460  739.981106\n\n\n\n# Python syntax\ngapminder.tail()\n\n\n\n       country continent  year  lifeExp       pop   gdpPercap\n1699  Zimbabwe    Africa  1987   62.351   9216418  706.157306\n1700  Zimbabwe    Africa  1992   60.377  10704340  693.420786\n1701  Zimbabwe    Africa  1997   46.809  11404948  792.449960\n1702  Zimbabwe    Africa  2002   39.989  11926563  672.038623\n1703  Zimbabwe    Africa  2007   43.487  12311143  469.709298\n\n\nในทางปฏิบัติผลการวิเคราะห์ด้วยวิธีการข้างต้นเพียงพอสำหรับผู้วิเคราะห์ที่จะใช้พิจารณาว่าโครงสร้างการจัดเก็บข้อมูลในชุดข้อมูลที่นำเข้ามามีลักษณะเป็นชุดข้อมูลจัดระเบียบที่เหมาะสำหรับการนำไปวิเคราะห์ข้อมูลตามวัตถุประสงค์แล้วหรือไม่ หากยังไม่เหมาะสมผู้วิเคราะห์จำเป็นต้องแก้ปัญหาในเชิงของโครงสร้างชุดข้อมูลดังกล่าวก่อนที่จะดำเนินการในขั้นตอนต่อไป หัวข้อถัดไปจะกล่าวถึงเครื่องมือหรือวิธีการพื้นฐานที่จำเป็นสำหรับปรับเปลี่ยนลักษณะของชุดข้อมูลให้ตรงกับความต้องการ"
  },
  {
    "objectID": "tidy.html#เรองท-4.2.2-การปรบเปลยนลกษณะของชดขอมล-reshaping-data",
    "href": "tidy.html#เรองท-4.2.2-การปรบเปลยนลกษณะของชดขอมล-reshaping-data",
    "title": "ตอนที่ 4.2 การจัดระเบียบข้อมูล (tidying data)",
    "section": "เรื่องที่ 4.2.2 การปรับเปลี่ยนลักษณะของชุดข้อมูล (reshaping data)",
    "text": "เรื่องที่ 4.2.2 การปรับเปลี่ยนลักษณะของชุดข้อมูล (reshaping data)\nชุดข้อมูลที่ยังไม่เป็นระเบียบมีหลากหลายลักษณะ และโดยมากมักพบเมื่อผู้วิเคราะห์ได้ข้อมูลมาจากแหล่งข้อมูลทุติยภูมิ เช่น ฐานข้อมูล หรือแหล่ง open data ต่าง ๆ หัวข้อนี้จะกล่าวถึงปัญหาข้อมูลไม่เป็นระเบียบที่มักพบและวิธีการแก้ปัญหาดังกล่าว รายละเอียดมีดังนี้\n\nการปรับเปลี่ยนรูปแบบชุดข้อมูลระหว่างชุดข้อมูลแบบกว้างกับชุดข้อมูลแบบยาว\nชุดข้อมูลอาจจำแนกได้เป็น 2 ลักษณะ ได้แก่ ชุดข้อมูลแบบกว้าง (wide format) และชุดข้อมูลแบบยาว (long format) รายละเอียดมีดังนี้\n\nชุดข้อมูลแบบกว้าง เป็นชุดข้อมูลที่มีการกระจายค่าสังเกตของตัวแปรสำคัญขึ้นไปอยู่บนคอลัมน์ ดังตัวอย่างชุดข้อมูล onet.xlsx ในตาราง 3 โดยส่วนใหญ่ตารางลักษณะนี้เหมาะสำหรับการนำเสนอข้อมูล หรือนำไปใช้สำหรับสร้างทัศนภาพข้อมูลในบางกรณี แต่มักไม่เหมาะที่จะนำไปเข้าสู่โมเดลวิเคราะห์ข้อมูลต่าง ๆ\nชุดข้อมูลแบบยาว เป็นชุดข้อมูลที่มีลักษณะเป็นไปตามเงื่อนไขของชุดข้อมูลจัดระเบียบ โดยมิติด้านคอลัมน์ใช้เก็บข้อมูลของตัวแปรแต่ละตัว ส่วนมิติด้านแถวใช้เก็บข้อมูลของหน่วยข้อมูล ชุดข้อมูล gapminder ข้างต้นเป็นตัวอย่างของชุดข้อมูลแบบยาว ชุดข้อมูลแบบยาวเป็นรูปแบบปกติที่มักพบในฐานข้อมูลแบบ SQL ทั่วไป\n\nตาราง 4.3 : (ตัวอย่างชุดข้อมูลแบบกว้าง) จำนวนนักเรียนจำแนกตามรายวิชาและช่วงคะแนนผลการสอบ O-NET ระดับชั้น ม.6 ปีการศึกษา 2560\n\n\n\n\n \n\n\nช่วงคะแนนผลสอบ O-NET\n\n  \n    วิชา \n    < 10 คะแนน \n    10-20 \n    20-30 \n    30-40 \n    40-50 \n    50-60 \n    60-70 \n    70-80 \n    80-90 \n    90-100 \n  \n \n\n  \n    ภาษาไทย \n    205 \n    10918 \n    39277 \n    59459 \n    80767 \n    84977 \n    61052 \n    28544 \n    6623 \n    221 \n  \n  \n    สังคมศึกษา \n    93 \n    11450 \n    119492 \n    155338 \n    64380 \n    17638 \n    3721 \n    447 \n    8 \n    0 \n  \n  \n    ภาษาอังกฤษ \n    2664 \n    120768 \n    146339 \n    48926 \n    21706 \n    12859 \n    8510 \n    5868 \n    3791 \n    1156 \n  \n  \n    คณิตศาสตร์ \n    52250 \n    163221 \n    81737 \n    29113 \n    14854 \n    9772 \n    7302 \n    5524 \n    4516 \n    4564 \n  \n  \n    วิทยาศาสตร์ \n    950 \n    61511 \n    183241 \n    75152 \n    25353 \n    12909 \n    7437 \n    3944 \n    1578 \n    157 \n  \n\n\n\n\n\nในทางปฏิบัติผู้วิเคราะห์มีโอกาสพบชุดข้อมูลทั้งสองลักษณะ การปรับเปลี่ยนรูปแบบของชุดข้อมูลดังกล่าว จากชุดข้อมูลแบบกว้างให้เป็นแบบยาว และจากให้อยู่ในรูปแบบยาวให้เป็นรูปแบบกว้าง จึงเป็นทักษะพื้นฐานที่จำเป็นสำหรับนักวิทยาการข้อมูล ในทำนองเดียวกับการสำรวจโครงสร้างชุดข้อมูล วิธีการปรับเปลี่ยนรูปแบบตารางข้อมูลมีความแตกต่างกันขึ้นอยู่กับโปรแกรมวิเคราะห์ข้อมูลที่เลือกใช้\nในกรณีที่ใช้ภาษา R ผู้วิเคราะห์สามารถดำเนินการได้หลายแบบ วิธีการหนึ่งที่สามารถทำได้สะดวกคือการใช้เครื่องมือใน package-tidyr พิจารณาชุดข้อมูล จำนวนผู้สำเร็จการศึกษา.xlsx ที่จัดเก็บอยู่ในชุดข้อมูล wide_data ด้านล่าง จะเห็นว่าเป็นชุดข้อมูลรูปแบบกว้างที่แสดงจำนวนผู้สำเร็จการศึกษาในระดับ ปวช. และ ปวส. จำแนกตามสาขาวิชา\n\n\n# A tibble: 9 × 4\n  `สาขาวิชา`               รวม  ปวช.  ปวส.\n  <chr>                 <dbl> <dbl> <dbl>\n1 อุตสาหกรรม            123268 65724 57544\n2 พาณิชยกรรม /บริหารธุรกิจ 106556 55257 51299\n3 อุตสาหกรรมการท่องเที่ยว   10779  6696  4083\n4 คหกรรม                 7171  4101  3070\n5 เกษตรกรรม              6026  2926  3100\n6 ศิลปกรรม                5175  4163  1012\n7 เทคโนโลยีสารสนเทศฯ      3702  1758  1944\n8 ประมง                   576    91   485\n9 อุตสาหกรรมสิ่งทอ            87    39    48\n\n\nหากผู้วิเคราะห์ต้องการปรับรูปแบบของชุดข้อมูล wide_data ข้างต้นให้เป็นชุดข้อมูลแบบยาว สามารถทำได้โดยใช้ฟังก์ชัน pivot_longer() โดยกำหนดอารกิวเมนท์ data เพื่อระบุชุดข้อมูลที่ต้องการปรับให้เป็นรูปแบบยาว cols เพื่อกำหนดคอลัมน์ในชุดข้อมูลแบบกว้างที่จะยุบรวมไว้ภายในคอลัมน์เดียวกัน names_to ใช้กำหนดชื่อคอลัมน์ใหม่สำหรับบรรจุคอลัมน์ที่ยุบรวมมาจากชุดข้อมูลแบบกว้างเดิม และ values_to ใช้กำหนดชื่อคอลัมน์สำหรับจัดเก็บค่าสังเกตที่อยู่ภายใต้คอลัมน์ที่ยุบรวมมา ตัวอย่างด้านล่างแสดงการปรับรูปแบบของชุดข้อมูล จำนวนผู้สำเร็จการศึกษา.xlsx ที่จัดเก็บอยู่ในชุดข้อมูล wide_data ให้เป็นชุดข้อมูลแบบยาว\n\n# R syntax\nlong_data<-pivot_longer(data=wide_data, \n                        cols=2:4, \n                        names_to = \"category\", \n                        values_to = \"number\")\nlong_data%>%data.frame()\n\n               สาขาว.ชา category number\n1             อุตสาหกรรม      รวม 123268\n2             อุตสาหกรรม     ปวช.  65724\n3             อุตสาหกรรม     ปวส.  57544\n4  พาณิชยกรรม /บริหารธุรกิจ      รวม 106556\n5  พาณิชยกรรม /บริหารธุรกิจ     ปวช.  55257\n6  พาณิชยกรรม /บริหารธุรกิจ     ปวส.  51299\n7   อุตสาหกรรมการท่องเที่ยว      รวม  10779\n8   อุตสาหกรรมการท่องเที่ยว     ปวช.   6696\n9   อุตสาหกรรมการท่องเที่ยว     ปวส.   4083\n10               คหกรรม      รวม   7171\n11               คหกรรม     ปวช.   4101\n12               คหกรรม     ปวส.   3070\n13            เกษตรกรรม      รวม   6026\n14            เกษตรกรรม     ปวช.   2926\n15            เกษตรกรรม     ปวส.   3100\n16              ศิลปกรรม      รวม   5175\n17              ศิลปกรรม     ปวช.   4163\n18              ศิลปกรรม     ปวส.   1012\n19    เทคโนโลยีสารสนเทศฯ      รวม   3702\n20    เทคโนโลยีสารสนเทศฯ     ปวช.   1758\n21    เทคโนโลยีสารสนเทศฯ     ปวส.   1944\n22                ประมง      รวม    576\n23                ประมง     ปวช.     91\n24                ประมง     ปวส.    485\n25        อุตสาหกรรมสิ่งทอ      รวม     87\n26        อุตสาหกรรมสิ่งทอ     ปวช.     39\n27        อุตสาหกรรมสิ่งทอ     ปวส.     48\n\n\nในทางกลับกันหากมีชุดข้อมูลแบบยาว และผู้วิเคราะห์ต้องการปรับเปลี่ยนให้เป็นชุดข้อมูลแบบกว้างสามารถทำได้ด้วยฟังก์ชัน pivot_wider() ฟังก์ชันนี้มีอาร์กิวเมนท์จำเป็นที่จะต้องระบุ 3 ตัวได้แก่ data เพื่อระบุชุดข้อมูลที่ต้องการปรับให้เป็นรูปแบบกว้าง names_from เพื่อระบุว่าจะนำค่าสังเกตจากคอลัมน์ใดขยายไปเป็นหัวคอลัมน์ของตารางใหม่ และ values_from ใช้ระบุว่าจะเอาข้อมูล/ค่าสังเกตจากคอลัมน์ใดไปอยู่ภายใต้คอลัมน์ใหม่ที่ขยายจากการระบุใน names_from ตัวอย่างด้านล่างแสดงการเปลี่ยนชุดข้อมูล long_data ในข้างต้นให้กลับเป็นชุดข้อมูลแบบกว้างเหมือนเดิม\n\n# R syntax\npivot_wider(data = long_data,\n            names_from = \"category\",\n            values_from = \"number\")\n\n# A tibble: 9 × 4\n  `สาขาวิชา`               รวม  ปวช.  ปวส.\n  <chr>                 <dbl> <dbl> <dbl>\n1 อุตสาหกรรม            123268 65724 57544\n2 พาณิชยกรรม /บริหารธุรกิจ 106556 55257 51299\n3 อุตสาหกรรมการท่องเที่ยว   10779  6696  4083\n4 คหกรรม                 7171  4101  3070\n5 เกษตรกรรม              6026  2926  3100\n6 ศิลปกรรม                5175  4163  1012\n7 เทคโนโลยีสารสนเทศฯ      3702  1758  1944\n8 ประมง                   576    91   485\n9 อุตสาหกรรมสิ่งทอ            87    39    48\n\n\nถ้าผู้วิเคราะห์ต้องการศึกษารายละเอียดเพิ่มเติมเกี่ยวกับฟังก์ชันต่าง ๆ ของโปรแกรม R สามารถเรียกดูคู่มือของฟังก์ชันดังกล่าวได้โดยใช้คำสั่ง ?XXX หรือ help(XXX) เช่น หากต้องการรายละเอียดของฟังก์ชัน pivot_longer() ให้พิมพ์คำสั่ง ?pivot_longer() หรือ help(pivot_longer() เป็นต้น\nในกรณีที่ใช้ภาษา Python การปรับเปลี่ยนชุดข้อมูลแบบกว้างให้เป็นแบบยาวสามารถทำได้โดยใช้ฟังก์ชัน melt() ภายใต้ pandas library ฟังก์ชัน melt() มีพารามิเตอร์ควบคุมการทำงานของฟังก์ชันที่สำคัญ 3 ตัวได้แก่ frame ใช้ระบุชุดข้อมูล (pandas.DataFrame) ที่ต้องการดำเนินงาน id_vars ใช้ระบุคอลัมน์หรือตัวแปรที่เป็น id ของหน่วยข้อมูล และ value_vars ทำงานเหมือนกับอาร์กิวเมนท์ names_to ของ pivot_longer() ในโปรแกรม R ตัวอย่างด้านล่างแสดงการปรับรูปแบบชุดข้อมูล จำนวนผู้สำเร็จการศึกษา.xlsx ที่เป็นชุดข้อมูลแบบกว้างให้เป็นชุดข้อมูลแบบยาวด้วยฟังก์ชันดังกล่าว โดยในตัวอย่างชุดข้อมูลดังกล่าวจัดเก็บอยู่ในตัวแปรชื่อ wide_data\n\n\n\n\n# Python syntax\nimport pandas as pd\nlong_data = pd.melt(frame = wide_data, \n                    id_vars=['สาขาวิชา'],\n                    value_vars=['รวม','ปวช.', 'ปวส.'])\nlong_data\n\n                    สาขาวิชา variable     value\n0                 อุตสาหกรรม      รวม  123268.0\n1   พาณิชยกรรม /บริหารธุรกิจ      รวม  106556.0\n2    อุตสาหกรรมการท่องเที่ยว      รวม   10779.0\n3                     คหกรรม      รวม    7171.0\n4                  เกษตรกรรม      รวม    6026.0\n5                   ศิลปกรรม      รวม    5175.0\n6         เทคโนโลยีสารสนเทศฯ      รวม    3702.0\n7                      ประมง      รวม     576.0\n8           อุตสาหกรรมสิ่งทอ      รวม      87.0\n9                 อุตสาหกรรม     ปวช.   65724.0\n10  พาณิชยกรรม /บริหารธุรกิจ     ปวช.   55257.0\n11   อุตสาหกรรมการท่องเที่ยว     ปวช.    6696.0\n12                    คหกรรม     ปวช.    4101.0\n13                 เกษตรกรรม     ปวช.    2926.0\n14                  ศิลปกรรม     ปวช.    4163.0\n15        เทคโนโลยีสารสนเทศฯ     ปวช.    1758.0\n16                     ประมง     ปวช.      91.0\n17          อุตสาหกรรมสิ่งทอ     ปวช.      39.0\n18                อุตสาหกรรม     ปวส.   57544.0\n19  พาณิชยกรรม /บริหารธุรกิจ     ปวส.   51299.0\n20   อุตสาหกรรมการท่องเที่ยว     ปวส.    4083.0\n21                    คหกรรม     ปวส.    3070.0\n22                 เกษตรกรรม     ปวส.    3100.0\n23                  ศิลปกรรม     ปวส.    1012.0\n24        เทคโนโลยีสารสนเทศฯ     ปวส.    1944.0\n25                     ประมง     ปวส.     485.0\n26          อุตสาหกรรมสิ่งทอ     ปวส.      48.0\n\n\nใน Python ผู้อ่านสามารถเรียกดูรายละเอียดของฟังก์ชันที่ต้องการใช้งานโดยพิมพ์คำส่ง ?XXX หรือ help(XXXX) เหมือนกับภาษา R เช่นในกรณีนี้ต้องการรายละเอียดการใช้งานฟังก์ชัน melt()ให้พิมพ์คำสั่ง help(pd.melt)\nในทางกลับกันหากต้องการปรับเปลี่ยนรูปแบบของตารางแบบยาวให้เป็นแบบกว้างสามารถทำได้ด้วยฟังก์ชัน pivot() ดังตัวอย่างต่อไปนี้\n\npd.pivot(data= long_data, \n                    index=['สาขาวิชา'],\n                    columns=['variable'],\n                    values=['value'])\n\n                            value                   \nvariable                     ปวช.     ปวส.       รวม\nสาขาวิชา                                            \nคหกรรม                     4101.0   3070.0    7171.0\nประมง                        91.0    485.0     576.0\nพาณิชยกรรม /บริหารธุรกิจ  55257.0  51299.0  106556.0\nศิลปกรรม                   4163.0   1012.0    5175.0\nอุตสาหกรรม                65724.0  57544.0  123268.0\nอุตสาหกรรมการท่องเที่ยว    6696.0   4083.0   10779.0\nอุตสาหกรรมสิ่งทอ             39.0     48.0      87.0\nเกษตรกรรม                  2926.0   3100.0    6026.0\nเทคโนโลยีสารสนเทศฯ         1758.0   1944.0    3702.0\n\n\nอีกวิธีการหนึ่งในการปรับรูปแบบตารางระหว่างตารางรูปแบบกว้างกับยาวด้วยภาษา Python คือการใช้ library datar ที่เป็น API ของ package-dplyr และ tidyr ที่ใช้จัดกระทำและจัดระเบียบชุดข้อมูลใน R กล่าวคือ ผู้วิเคราะห์สามารถใช้ฟังก์ชัน pivot_longer() และ pivot_wider() รวมทั้งฟังก์ชันอื่น ๆ ที่เกี่ยวข้องใน Python ได้เหมือนกับที่ดำเนินการในภาษา R ก่อนการใช้งาน library ผู้วิเคราะห์จำเป็นต้องดาวน์โหลดและติดตั้ง library ลงในเครื่องก่อน โดยภายในหน้าต่าง terminal ให้พิมพ์คำสั่ง pip install -U datar รายละเอียดเพิ่มเติมสามารถศึกษาได้จาก https://github.com/pwwang/datar\n\n\nการแยกคอลัมน์\nในบางกรณีชุดข้อมูลที่นำใช้ในการวิเคราะห์อาจมีบางคอลัมน์ที่จัดเก็บค่าสังเกตของหลายตัวแปรอยู่ภายในเซลล์เดียวกัน ดังตัวอย่างในตาราง 4 (ดาวน์โหลดได้จาก คะแนนเชาวน์ปัญญาของนักเรียน.xlsx (สิวะโชติ ศรีสุทธิยากร, 2564)) จากตารางจะเห็นว่าคอลัมน์ที่ 3 (gender.age) เป็นคอลัมน์ที่จัดเก็บค่าสังเกตของตัวแปรจำนวน 2 ตัวร่วมกัน ได้แก่ เพศ และ อายุ ของนักเรียน ซึ่งละเมิดเงื่อนไขของชุดข้อมูลจัดระเบียบ การแก้ปัญหาจึงจำเป็นต้องแยกค่าสังเกตในคอลัมน์ดังกล่าวออกจากกันให้เป็น 2 คอลัมน์ได้แก่ คอลัมน์ของเพศ และอายุ ตามลำดับ\nตาราง 4.4 คะแนนเชาว์ปัญญาของนักเรียน\n\n\n\n\n \n  \n    id \n    จังหวัด \n    gender.age \n    IQ \n  \n \n\n  \n    1 \n    กรุงเทพฯ \n    ชาย/14 \n    80 \n  \n  \n    2 \n    กรุงเทพฯ \n    ชาย/24 \n    101 \n  \n  \n    3 \n    กรุงเทพฯ \n    ชาย/25 \n    105 \n  \n  \n    4 \n    กรุงเทพฯ \n    หญิง/54 \n    99 \n  \n  \n    5 \n    กรุงเทพฯ \n    ชาย/18 \n    100 \n  \n  \n    6 \n    กรุงเทพฯ \n    หญิง/65 \n    105 \n  \n  \n    7 \n    เชียงใหม่ \n    ชาย/14 \n    90 \n  \n  \n    8 \n    เชียงใหม่ \n    หญิง/15 \n    110 \n  \n  \n    9 \n    เชียงใหม่ \n    ชาย/37 \n    103 \n  \n  \n    10 \n    เชียงใหม่ \n    หญิง/28 \n    108 \n  \n  \n    11 \n    เชียงใหม่ \n    ชาย/44 \n    98 \n  \n  \n    12 \n    เชียงใหม่ \n    หญิง/34 \n    106 \n  \n\n\n\n\n\nที่มา: สิวะโชติ ศรีสุทธิยากร (2564)\nการแยกคอลัมน์ในชุดข้อมูลดังกล่าวด้วยภาษา R สามารถทำได้หลายวิธีการ ใน package-tidyr มีฟังก์ชัน seperate() ที่สามารถใช้ดำเนินการดังกล่าวได้ ฟังก์ชัน separate() มีอาร์กิวเมนท์สำคัญจำนวน 4 ตัวได้แก่ data ใช้สำหรับระบุชุดข้อมูลที่ต้องการแยกคอลัมน์ col ใช้ระบุคอลัมน์ที่ต้องการแยกค่าสังเกตออกจากกัน into ใช้กำหนดชื่อของคอลัมน์ใหม่ที่ภายหลังจากแยกค่าสังเกตของคอลัมน์เดิมออกจากกัน และ sep ใช้ระบุลลักษณะของตัวคั่น (seperator) ที่ใช้สำหรับแยกข้อมูล การกำหนดตัวคั่นนี้สามารถทำได้ 3 ลักษณะ ได้แก่ การกำหนดด้วยตัวอักษร การกำหนดด้วยตำแหน่งของตัวคั่น และการกำหนดด้วยนิพจน์ปกติ (regular expression) รายละเอียดสามารถศึกษาได้จาก สิวะโชติ ศรีสุทธิยากร (2564)\nตัวอย่างด้านล่างแสดงการใช้ฟังก์ชัน separate() เพื่อแยกค่าสังเกตในคอลัมน์ gender.age ออกเป็นคอลัมน์ gender และ age ตามลำดับ จากตัวอย่างจะเห็นว่าในคอลัมน์ gender.age มีการใช้ตัวคั่นข้อมูลเป็น / จึงกำหนดอาร์กิวเมนท์ sep=\"/\"\n\n# R syntax\niq_sep<-separate(data = iq,\n         col = \"gender.age\",\n         into = c(\"gender\",\"age\"),\n         sep=\"/\")\niq_sep\n\n# A tibble: 12 × 5\n      id `จังหวัด` gender age      IQ\n   <dbl> <chr>   <chr>  <chr> <dbl>\n 1     1 กรุงเทพฯ ชาย    14       80\n 2     2 กรุงเทพฯ ชาย    24      101\n 3     3 กรุงเทพฯ ชาย    25      105\n 4     4 กรุงเทพฯ หญิง    54       99\n 5     5 กรุงเทพฯ ชาย    18      100\n 6     6 กรุงเทพฯ หญิง    65      105\n 7     7 เชียงใหม่ ชาย    14       90\n 8     8 เชียงใหม่ หญิง    15      110\n 9     9 เชียงใหม่ ชาย    37      103\n10    10 เชียงใหม่ หญิง    28      108\n11    11 เชียงใหม่ ชาย    44       98\n12    12 เชียงใหม่ หญิง    34      106\n\n\nในกรณีที่ใช้ภาษา Python สามารถดำเนินการได้โดยใช้ฟังก์ชัน str.split() ภายใต้ pandas library โดยฟังก์ชันดังกล่าวมีพารามิเตอร์ที่สำคัญ 1 ตัวได้แก่ separator ที่ใช้สำหรับระบุลักษณะของตัวคั่นข้อมูลในคอลัมน์ที่ต้องการแยก ตัวอย่างการใช้ฟังก์ชัน str.split() เพื่อแยกคอลัมน์ gender.age ในชุดข้อมูล iq เป็นดังนี้\n\n\n\n\n# Python syntax\niq[\"gender\"] = iq[\"gender.age\"].str.split(\"/\", expand=True)[0]\niq[\"age\"] = iq[\"gender.age\"].str.split(\"/\", expand=True)[1]\niq\n\n      id    จังหวัด gender.age     IQ gender age\n0    1.0   กรุงเทพฯ     ชาย/14   80.0    ชาย  14\n1    2.0   กรุงเทพฯ     ชาย/24  101.0    ชาย  24\n2    3.0   กรุงเทพฯ     ชาย/25  105.0    ชาย  25\n3    4.0   กรุงเทพฯ    หญิง/54   99.0   หญิง  54\n4    5.0   กรุงเทพฯ     ชาย/18  100.0    ชาย  18\n5    6.0   กรุงเทพฯ    หญิง/65  105.0   หญิง  65\n6    7.0  เชียงใหม่     ชาย/14   90.0    ชาย  14\n7    8.0  เชียงใหม่    หญิง/15  110.0   หญิง  15\n8    9.0  เชียงใหม่     ชาย/37  103.0    ชาย  37\n9   10.0  เชียงใหม่    หญิง/28  108.0   หญิง  28\n10  11.0  เชียงใหม่     ชาย/44   98.0    ชาย  44\n11  12.0  เชียงใหม่    หญิง/34  106.0   หญิง  34\n\n\n\n\nการยุบรวมคอลัมน์\nอีกกรณีคือเป็นไปได้ที่ข้อมูลของตัวแปรเดียวกันอาจถูกเก็บอยู่ในหลายคอลัมน์ เช่นข้อมูลคำนำหน้า ชื่อ และนามสกุล หรือ ข้อมูลเวลา (วัน เดือน ปี) ตาราง 5 แสดงข้อมูลจากชุดข้อมูล login.xlsx ที่มีปัญหาดังกล่าว จากตารางจะเห็นว่ามีการจัดเก็บคำนำหน้า และชื่อของผู้เข้าระบบอยู่คนละคอลัมน์กัน\nตาราง 5 จำนวนครั้งของการเข้าระบบ\n\n\n\n\n \n  \n    คำนำหน้า \n    ชื่อ \n    จำนวนครั้งที่เข้าระบบ \n  \n \n\n  \n    นาย \n    บุญถึง \n    14 \n  \n  \n    นางสาว \n    บุญเติม \n    20 \n  \n  \n    นาย \n    บุญมาก \n    17 \n  \n  \n    นางสาว \n    บุญมี \n    18 \n  \n  \n    นาย \n    บุญหนัก \n    6 \n  \n  \n    นาง \n    บุญอยู่ \n    18 \n  \n  \n    นางสาว \n    บุญมา \n    18 \n  \n  \n    นาย \n    บุญทับ \n    14 \n  \n  \n    นาง \n    บุญชอบ \n    18 \n  \n\n\n\n\n\nการยุบรวมคอลัมน์ทั้งสองเข้าด้วยกันในภาษา R สามารถทำได้ด้วยฟังก์ชัน unite() ของ package-tidyr ฟังก์ชันนี้มีอาร์กิวเมนท์ที่สำคัญได้แก่ data ใช้ระบุชุดข้อมูลที่ต้องการดำเนินงาน col ใช้ระบุชื่อของคอลัมน์ใหม่ภายหลังจากยุบรวมคอลัมน์เดิมเข้าด้วยกัน และ sep ใช้สำหรับระบุตัวคั่นสำหรับคั่นข้อมูลที่ยุบรวมกัน (ค่าเริ่มต้นของอาร์กิวเมนท์นี้กำหนดให้ใช้สัญลักษณ์ underscore sep=\"_\")\nตัวอย่างต่อไปนี้แสดงการใช้ฟังก์ชัน unite() ดังกล่าว สมมุติว่า login.xlsx ในข้างต้นถูกจัดเก็บในโปรแกรม R โดยเก็บไว้ในตัวแปร login ผู้วิเคราะห์สามารถยุบรวมคอลัมน์ คำนำหน้า และ ชื่อ เข้าด้วยกัน โดยใช้ฟังก์ชัน unite() ได้ดังนี้\n\n# R syntax\nlogin_united<-unite(login, \n      col=\"name\",\n      \"คำนำหน้า\", \"ชื่อ\")\nlogin_united\n\n# A tibble: 9 × 2\n  name         `จำนวนครั้งที่เข้าระบบ`\n  <chr>                     <dbl>\n1 นาย_บุญถึง                     14\n2 นางสาว_บุญเติม                 20\n3 นาย_บุญมาก                    17\n4 นางสาว_บุญมี                   18\n5 นาย_บุญหนัก                     6\n6 นาง_บุญอยู่                     18\n7 นางสาว_บุญมา                  18\n8 นาย_บุญทับ                     14\n9 นาง_บุญชอบ                    18\n\n\nสำหรับภาษา Python การยุบรวมคอลัมน์ตั้งแต่ 2 คอลัมน์ขึ้นไปเข้าด้วยกันทำได้ง่ายมากโดยการใช้ตัวดำเนินการเชื่อม (concatenate operator) ดังตัวอย่างต่อไปนี้\n\n\n\n\n# Python syntax\nlogin[\"name\"] = login[\"คำนำหน้า\"] + login[\"ชื่อ\"]\nlogin\n\n  คำนำหน้า     ชื่อ  จำนวนครั้งที่เข้าระบบ           name\n0      นาย   บุญถึง                   14.0      นายบุญถึง\n1   นางสาว  บุญเติม                   20.0  นางสาวบุญเติม\n2      นาย   บุญมาก                   17.0      นายบุญมาก\n3   นางสาว    บุญมี                   18.0    นางสาวบุญมี\n4      นาย  บุญหนัก                    6.0     นายบุญหนัก\n5      นาง  บุญอยู่                   18.0     นางบุญอยู่\n6   นางสาว    บุญมา                   18.0    นางสาวบุญมา\n7      นาย   บุญทับ                   14.0      นายบุญทับ\n8      นาง   บุญชอบ                   18.0      นางบุญชอบ\n\n\n\n\nการรวมชุดข้อมูลตามแถว (rows combined)\nงานทางด้านสถิติและวิทยาการข้อมูลในปัจจุบันบ่อยครั้งข้อมูลสำคัญมักมาจากหลายแหล่งข้อมูล เช่น อาจได้มาจากการเก็บเกี่ยวข้อมูลจากเว็ปไซด์ส่วนนึง (web scraping) และส่วนที่เหลืออาจเป็นข้อมูลที่ได้จากฐานข้อมูลเปิดต่าง ๆ หากชุดข้อมูลดังกล่าวเป็นข้อมูลของหน่วยการวิเคราะห์เดียวกัน หรือสามารถจัดกระทำให้เป็นข้อมูลของหน่วยการวิเคราะห์เดียวกันได้แล้ว การจะนำข้อมูลดังกล่าวมาวิเคราะห์ร่วมกันจำเป็นที่จะต้องยุบรวมชุดข้อมูลดังกล่าวเข้าด้วยกันก่อน การยุบรวมชุดข้อมูลอาจจำแนกได้เป็น 2 ลักษณะ ได้แก่ การยุบรวมข้อมูลตามแถว (rows combined) และการยุบรวมข้อมูลตามคอลัมน์ (columns combined) หัวข้อนี้จะกล่าวถึงการยุบรวมข้อมูลตามแถว รายละเอียดมีดังนี้\nรูป 4.2 แสดงลักษณะของการยุบรวมข้อมูลตามแถว จากรูปจะเห็นว่าเริ่มต้นมีชุดข้อมูลจากแหล่งข้อมูลที่แตกต่างกันจำนวน 3 แหล่ง ได้แก่ A, B และ C โดยที่ชุดข้อมูลจากแต่ละแหล่งดังกล่าวเก็บข้อมูลของตัวแปรเดียวกัน และมีจำนวนคอลัมน์เท่ากัน แต่จะสังเกตเห็นว่าแต่ละชุดข้อมูลมีหน่วยข้อมูลที่แตกต่างกัน การยุบรวมชุดข้อมูลทั้ง 3 ตามแถวจะให้ผลลัพธ์เป็นชุดข้อมูลที่ใหญ่ขึ้นจากเดิม โดยมีหน่วยข้อมูลทั้งหมดจากทั้ง 3 ชุดข้อมูลข้างต้นมาจัดเก็บอยู่ภายใต้ชุดข้อมูลใหม่ขนาด 9 x 3\n\n\n\nรูป 4.2 ตัวอย่างแสดงลักษณะการยุบรวมชุดข้อมูลตามแถว (row combined)\n\n\nที่มา : สิวะโชติ ศรีสุทธิยากร (2564)\nการรวมชุดข้อมูลตามแถวด้วยภาษา R สามารถทำได้หลายวิธีการ ฟังก์ชัน bind_rows() ของ package-dplyr สามารถใช้เพื่อรวมชุดข้อมูลดังกล่าวได้ อาร์กิวเมนท์ของฟังก์ชัน bind_rows() ได้แก่ชุดข้อมูลแบบ Dataframe ที่ต้องการนำมารวมกันตามแถว เงื่อนไขของการใช้ฟังก์ชันนี้คือชุดข้อมูลที่จะนำมารวมกันจำเป็นต้องมีจำนวนคอลัมน์เท่ากัน แต่ละคอลัมน์จัดเก็บข้อมูลของตัวแปรเดียวกันและมีการจัดเรียงลำดับของตัวแปรที่เหมือนกัน\nตัวอย่างต่อไปนี้แสดงการยุบรวมข้อมูลตามแถวด้วยฟังก์ชัน bind_rows() สมมุติว่าผู้วิเคราะห์มีไฟล์ข้อมูลของกลุ่มเป้าหมายเดียวกันจำนวน 4 ไฟล์ ที่สามารถดาวน์โหลดไฟล์ดังกล่าวได้จาก https://bit.ly/2AuQgqr (สิวะโชติ ศรีสุทธิยากร, 2564) ไฟล์ข้อมูลทั้ง 4 ประกอบด้วย file1.xlsx, file2.xlsx, file3.xlsx และ file4.xlsx ตามลำดับ โดยที่แต่ละไฟล์จัดเก็บข้อมูลของนักเรียนไฟล์ละ 5 คน ตารางด้านล่างแสดงข้อมูลที่จัดเก็บอยู่ในไฟล์ file1.xlsx\n\n\n# A tibble: 5 × 5\n  student.name Lecture.pre PBL.pre Lecture.post PBL.post\n  <chr>              <dbl>   <dbl>        <dbl>    <dbl>\n1 บุญมี                   20      NA           45       NA\n2 บุญมาก                 16      NA           34       NA\n3 บุญเกิน                 NA      18           NA       67\n4 บุญถึง                  NA      25           NA       93\n5 บุญธรรม                13      NA           50       NA\n\n\nเมื่อผู้อ่านได้ดำเนินการสำรวจไฟล์ข้อมูลทั้ง 4 แล้วจะพบว่าโครงการการจัดเก็บข้อมูลของทั้ง 4 ไฟล์มีลักษณะเหมือนกัน ชุดข้อมูลทั้ง 4 จึงสามารถยุบรวมกันตามแถวได้โดยใช้ฟังก์ชัน rbind() ในข้างต้น ตัวอย่างนี้ผู้เขียนได้นำเข้าข้อมูลจากทั้ง 4 ไฟล์และจัดเก็บอยู่ในชุดข้อมูลชื่อ dat1, dat2, dat3 และ dat4 ตามลำดับ การเขียนคำสั่งเพิ่มยุบรวมชุดข้อมูลดังกล่าวตามแถวเป็นดังนี้\n\n# R syntax\ndat_rbind <-bind_rows(dat1, dat2, dat3, dat4)\ndat_rbind\n\n# A tibble: 20 × 5\n   student.name Lecture.pre PBL.pre Lecture.post PBL.post\n   <chr>              <dbl>   <dbl>        <dbl>    <dbl>\n 1 บุญมี                   20      NA           45       NA\n 2 บุญมาก                 16      NA           34       NA\n 3 บุญเกิน                 NA      18           NA       67\n 4 บุญถึง                  NA      25           NA       93\n 5 บุญธรรม                13      NA           50       NA\n 6 บุญใหญ่                 NA      17           NA       71\n 7 บุญหนัก                 14      NA           48       NA\n 8 บุญมา                  NA      20           NA       83\n 9 บุญเยอะ                NA      28           NA       75\n10 บุญแฝง                 NA      21           NA       73\n11 บุญดี                   22      NA           32       NA\n12 บุญแรง                 NA      17           NA       68\n13 บุญดัง                  14      NA           70       NA\n14 บุญจริง                 15      NA           64       NA\n15 บุญเติม                 19      NA           55       NA\n16 บุญรอด                 NA      15           NA       82\n17 บุญชอบ                 18      NA           59       NA\n18 บุญผ่อง                 NA      12           NA       68\n19 บุญสืบ                   8      NA           62       NA\n20 บุญเหลือ                NA      25           NA       87\n\n\nสำหรับภาษา Python การยุบรวมชุดข้อมูลตามแถวสามารถดำเนินการได้หลายวิธีการเช่นเดียวกับภาษา R ฟังก์ชันหนึ่งที่สามารถทำได้คือฟังก์ชัน append() ภายใต้ pandas library ตัวอย่างต่อไปนี้แสดงการยุบรวมชุดข้อมูลใน file1.xlsx, file2.xlsx, file3.xlsx และ file4.xlsx ตามแถว ทั้งนี้ในตัวอย่างดังกล่าวได้จัดเก็บข้อมูลทั้ง 4 ไว้ในตัวแปรได้แก่ dat1, dat2, …, dat4 เช่นเดียวกับตัวอย่างของภาษา R ผลลัพธ์ด้านล่างแสดงตัวอย่างของชุดข้อมูล dat1 ที่เก็บอยู่ใน Python\n\n\n\n\n# Python syntax\ndat1\n\n  student.name  Lecture.pre  PBL.pre  Lecture.post  PBL.post\n0        บุญมี         20.0      NaN          45.0       NaN\n1       บุญมาก         16.0      NaN          34.0       NaN\n2      บุญเกิน          NaN     18.0           NaN      67.0\n3       บุญถึง          NaN     25.0           NaN      93.0\n4      บุญธรรม         13.0      NaN          50.0       NaN\n\ndat1.info()\n\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 5 entries, 0 to 4\nData columns (total 5 columns):\n #   Column        Non-Null Count  Dtype  \n---  ------        --------------  -----  \n 0   student.name  5 non-null      object \n 1   Lecture.pre   3 non-null      float64\n 2   PBL.pre       2 non-null      float64\n 3   Lecture.post  3 non-null      float64\n 4   PBL.post      2 non-null      float64\ndtypes: float64(4), object(1)\nmemory usage: 328.0+ bytes\n\n\nการยุบรวมชุดข้อมูลทั้ง 4 ตามแถวด้วยฟังก์ชัน append() สามารถทำได้ดังนี้\n\n# Python syntax\nimport pandas as pd\ndat_rbind = dat1.append(dat2)\n\n<string>:1: FutureWarning: The frame.append method is deprecated and will be removed from pandas in a future version. Use pandas.concat instead.\n\ndat_rbind\n\n  student.name  Lecture.pre  PBL.pre  Lecture.post  PBL.post\n0        บุญมี         20.0      NaN          45.0       NaN\n1       บุญมาก         16.0      NaN          34.0       NaN\n2      บุญเกิน          NaN     18.0           NaN      67.0\n3       บุญถึง          NaN     25.0           NaN      93.0\n4      บุญธรรม         13.0      NaN          50.0       NaN\n0      บุญใหญ่          NaN     17.0           NaN      71.0\n1      บุญหนัก         14.0      NaN          48.0       NaN\n2        บุญมา          NaN     20.0           NaN      83.0\n3      บุญเยอะ          NaN     28.0           NaN      75.0\n4       บุญแฝง          NaN     21.0           NaN      73.0\n\n\nในกรณีที่มีชุดข้อมูลมากกว่า 2 ชุด ที่ต้องการยุบรวมเข้าด้วยกันตามแถว สามารถใช้ฟังก์ชัน append() เรียงต่อกกันได้ดังตัวอย่างต่อไปนี้\n\n# Python syntax\ndat_rbind = dat1.append(dat2).append(dat3).append(dat4)\n\n<string>:1: FutureWarning: The frame.append method is deprecated and will be removed from pandas in a future version. Use pandas.concat instead.\n<string>:1: FutureWarning: The frame.append method is deprecated and will be removed from pandas in a future version. Use pandas.concat instead.\n\ndat_rbind\n\n  student.name  Lecture.pre  PBL.pre  Lecture.post  PBL.post\n0        บุญมี         20.0      NaN          45.0       NaN\n1       บุญมาก         16.0      NaN          34.0       NaN\n2      บุญเกิน          NaN     18.0           NaN      67.0\n3       บุญถึง          NaN     25.0           NaN      93.0\n4      บุญธรรม         13.0      NaN          50.0       NaN\n0      บุญใหญ่          NaN     17.0           NaN      71.0\n1      บุญหนัก         14.0      NaN          48.0       NaN\n2        บุญมา          NaN     20.0           NaN      83.0\n3      บุญเยอะ          NaN     28.0           NaN      75.0\n4       บุญแฝง          NaN     21.0           NaN      73.0\n0        บุญดี         22.0      NaN          32.0       NaN\n1       บุญแรง          NaN     17.0           NaN      68.0\n2       บุญดัง         14.0      NaN          70.0       NaN\n3      บุญจริง         15.0      NaN          64.0       NaN\n4      บุญเติม         19.0      NaN          55.0       NaN\n0       บุญรอด          NaN     15.0           NaN      82.0\n1       บุญชอบ         18.0      NaN          59.0       NaN\n2      บุญผ่อง          NaN     12.0           NaN      68.0\n3       บุญสืบ          8.0      NaN          62.0       NaN\n4     บุญเหลือ          NaN     25.0           NaN      87.0\n\n\n\n\nการยุบรวมข้อมูลตามคอลัมน์ (columns combined)\nการยุบรวมข้อมูลตามคอลัมน์มีการดำเนินการคล้ายกับการยุบรวมตามแถว แต่เปลี่ยนมิติของการจับคู่เป็นการจับคู่ข้อมูลระหว่างหน่วยข้อมูลเดียวกันที่อยู่ต่างชุดข้อมูลกัน รูป 4.3 แสดงลักษณะของการยุบรวมข้อมูลตามคอลัมน์ จากรูปจะเห็นว่า การยุบรวมข้อมูลลักษณะนี้เป็นการนำชุดข้อมูลหลายชุดของหน่วยข้อมูลเดียวกันหรือมีหน่วยข้อมูลเป็นส่วนย่อยของกันและกัน และมีตัวแปรที่แตกต่างกันมารวมเข้าเป็นชุดข้อมูลเดียวกัน\n\n\n\nรูป 4.3 ตัวอย่างแสดงลักษณะการยุบรวมชุดข้อมูลตามคอลัมน์ (column combined)\n\n\nที่มา : สิวะโชติ ศรีสุทธิยากร (2564)\nการยุบรวมข้อมูลตามคอลัมน์ด้วยภาษา R สามารถดำเนินการได้หลายวิธีการมาก วิธีการแรกคือการใช้ฟังก์ชัน bind_cols() ของ package-dplyr ที่มีการทำงานเหมือนกับฟังก์ชัน bind_rows() แต่จะดำเนินการรวมข้อมูลตามคอลัมน์แทน เงื่อนไขของฟังก์ชันนี้ที่ไม่ค่อยสะดวกนักคือ ชุดข้อมูลที่จะยุบรวมกันตามคอลัมน์ต้องเป็นชุดข้อมูลของหน่วยข้อมูลเดียวกัน แต่มีตัวแปรที่แตกต่างกัน และการจัดเรียงหน่วยข้อมูลต้องเป็นไปในลำดับเดียวกัน ดังในรูป 4.3 ข้างต้น (ผู้อ่านสามารถศึกษารายละเอียดของฟังก์ชัน bind_cols() ได้โดยพิมพ์คำสั่ง ?bind_cols())\nในทางปฏิบัติเมื่อผู้วิเคราะห์ดำเนินการกับข้อมูลขนาดใหญ่หลายชุดที่มาจากฐานข้อมูลที่แตกต่างกัน ชุดข้อมูลดังกล่าวมักจะมีการจัดเรียงลำดับของหน่วยข้อมูลที่แตกต่างกัน นอกจากนี้ชุดข้อมูลทั้งหมดยังอาจมีบางหน่วยข้อมูลที่แตกต่างกันและไม่สามารถยุบรวมกันได้ สถานการณ์ที่ซับซ้อนลักษณะนี้การยุบรวมด้วยฟังก์ชัน bind_cols() จะเป็นวิธีการที่ค่อนข้างลำบาก การใช้กลุ่มฟังก์ชัน join ของ package-dplyr เป็นวิธีการที่เหมาะสมมากกว่า กลุ่มฟังก์ชัน join ดังกล่าวประกอบด้วยฟังก์ชัน 4 ตัวที่ทำงานแตกต่างกัน เพื่อรองรับความต้องการในการยุบรวมข้อมูลตามคอลัมน์ของผู้วิเคราะห์ที่แตกต่างกัน ได้แก่ inner_join(), full_join(), left_join() และ right_join() รูป 4.4 แสดงลักษณะการทำงานของกลุ่มฟังก์ชัน join ดังกล่าว จากรูปจะเห็นความแตกต่างของฟังก์ชันทั้ง 4 ตัวว่าอยู่ที่การเลือกจัดเก็บหรือไม่จัดเก็บหน่วยข้อมูลจากชุดข้อมูลที่จะยุบรวมกันอย่างไร กล่าวคือ inner_join() จะเลือกจัดเก็บเฉพาะหน่วยข้อมูลที่มีร่วมกันระหว่างชุดข้อมูลทั้งสองเท่านั้น ในขณะที่ left_join() จะเก็บหน่วยข้อมูลชุดทางซ้าย (เรียกว่าชุด x) ไว้ทั้งหมด แต่จะเลือกจัดเก็บข้อมูลชุดทางขวา (เรียกว่าชุด y) เฉพาะส่วนที่มีข้อมูลร่วมกันกับชุด x เท่านั้น ฟังก์ชัน right_joint() มีการดำเนินการเหมือนกับ left_join() แต่มีทิศทางการจัดเก็บข้อมูลที่ตรงข้ามกัน ส่วนฟังก์ชัน full_join() จะเก็บหน่วยข้อมูลทุกหน่วยไว้ไม่ว่าหน่วยข้อมูลนั้นจะมีอยู่ร่วมกันในทั้งสองชุดข้อมูลหรือไม่\n\n\n\nรูป 4.4 ตัวอย่างแสดงลักษณะการทำงานของฟังก์ชันในกลุ่ม join\n\n\nที่มา : สิวะโชติ ศรีสุทธิยากร (2564)\nฟังก์ชันในกลุ่ม join มีอาร์กิวเมนท์ที่สำคัญเหมือนกันได้แก่ x และ y คือชุดข้อมูลที่ต้องการยุบรวมกันตามคอลัมน์ และ by ใช้ระบุตัวแปร id ที่จะใช้จับคู่หน่วยข้อมูลระหว่างชุดข้อมูลทั้งสอง ทั้งนี้การระบุอาร์กิวเมนท์นี้จะต้องระบุเป็นเวกเตอร์ตัวอักษร (character vector)\nตัวอย่างต่อไปนี้แสดงการใช้ฟังก์ชัน join ทั้ง 4 ตัวเพื่อยุบรวมข้อมูลตามคอลัมน์ ชุดข้อมูลที่ใช้เป็นตัวอย่างเป็นชุดข้อมูลที่สร้างขึ้นด้วยการกำหนดค่าด้วยมือ ประกอบด้วยชุดข้อมูล X และ Y สังเกตว่าชุดข้อมูลทั้งหมดมีตัวแปร id ที่ใช้สำหรับอ้างอิงหน่วยข้อมูล นอกจากนี้ชุดข้อมูลทั้งสองมีหน่วยข้อมูลที่เหมือนกันเพียงบางส่วน และมีการจัดเก็บข้อมูลของตัวแปรที่แตกต่างกัน\n\n# R syntax\nX<-data.frame(id=c(1,2,3,4),\n              gender = c(\"m\",\"f\",\"f\",\"m\"),\n              income = c(10,5,20,15))\n\nY<-data.frame(id=c(1,2,5,6,7),\n              score = c(30,50,20,100, 75),\n              location = c(\"N\",\"NE\",\"S\",\"C\",\"W\"))\n\n\n# R syntax\nX\n\n  id gender income\n1  1      m     10\n2  2      f      5\n3  3      f     20\n4  4      m     15\n\nY\n\n  id score location\n1  1    30        N\n2  2    50       NE\n3  5    20        S\n4  6   100        C\n5  7    75        W\n\n\nผลลัพธ์ที่ได้จากการยุบรวมข้อมูลตามคอลัมน์ด้วยฟังก์ชัน join ทั้ง 4 ตัวเป็นดังนี้ ผู้อ่านลองพิจารณาความแตกต่างของผลลัพธ์ที่ได้จากฟังก์ชันทั้ง 4 ใน output ด้านล่าง\n\n# R syntax\ninner_join(X, Y, by = \"id\")\n\n  id gender income score location\n1  1      m     10    30        N\n2  2      f      5    50       NE\n\nleft_join(X, Y, by = \"id\")\n\n  id gender income score location\n1  1      m     10    30        N\n2  2      f      5    50       NE\n3  3      f     20    NA     <NA>\n4  4      m     15    NA     <NA>\n\nright_join(X, Y, by = \"id\")\n\n  id gender income score location\n1  1      m     10    30        N\n2  2      f      5    50       NE\n3  5   <NA>     NA    20        S\n4  6   <NA>     NA   100        C\n5  7   <NA>     NA    75        W\n\nfull_join(X, Y, by = \"id\")\n\n  id gender income score location\n1  1      m     10    30        N\n2  2      f      5    50       NE\n3  3      f     20    NA     <NA>\n4  4      m     15    NA     <NA>\n5  5   <NA>     NA    20        S\n6  6   <NA>     NA   100        C\n7  7   <NA>     NA    75        W\n\n\nในภาษา Python มีฟังก์ชันที่เทียบเคียงได้กับกลุ่มฟังก์ชัน join ของภาษา R เช่นเดียวกันได้แก่ ฟังก์ชัน merge() ภายใต้ pandas library ฟังก์ชันดังกล่าวมีพารามิเตอร์ที่สำคัญได้แก่ left และ right ใช้ระบุชุดข้อมูลทางซ้ายและทางขวาสำหรับการยุบรวม on ใช้ระบุ id สำหรับการจับคู่หน่วยข้อมูลเดียวกันระหว่างสองชุดข้อมูลที่ต้องการยุบรวมกัน และ how ใช้ระบุลักษณะของการยุบรวมระหว่างชุดข้อมูล โดยสามารถเลือกกำหนดได้ 4 แบบเช่นเดียวกับภาษา R ได้แก่ inner, left, right และ outer โดยที่ outer จะเทียบเท่ากับ full_join() ในภาษา R ข้างต้น\nตัวอย่างต่อไปนี้แสดงการใช้ฟังก์ชัน pd.merge() เพื่อยุบรวมชุดข้อมูล X และ Y ด้านล่าง ด้วยวิธีการทั้ง 4 แบบ\n\n# Python syntax\nX = {'id': [1,2,3,4],\n     'gender': [\"m\",\"f\",\"f\",\"m\"],\n     'income': [10,5,20,15]}\n\nY = {'id': [1,2,5,6,7],\n    'score': [30,50,20,100, 75],\n    'location': [\"N\",\"NE\",\"S\",\"C\",\"W\"]}\n    \nX = pd.DataFrame(X)\nY = pd.DataFrame(Y)\n\n\n# Python syntax\nX\n\n   id gender  income\n0   1      m      10\n1   2      f       5\n2   3      f      20\n3   4      m      15\n\nY\n\n   id  score location\n0   1     30        N\n1   2     50       NE\n2   5     20        S\n3   6    100        C\n4   7     75        W\n\n\n\n# Python syntax\npd.merge(X, Y, on=\"id\", how=\"inner\")\n\n   id gender  income  score location\n0   1      m      10     30        N\n1   2      f       5     50       NE\n\npd.merge(X, Y, on=\"id\", how=\"left\")\n\n   id gender  income  score location\n0   1      m      10   30.0        N\n1   2      f       5   50.0       NE\n2   3      f      20    NaN      NaN\n3   4      m      15    NaN      NaN\n\npd.merge(X, Y, on=\"id\", how=\"right\")\n\n   id gender  income  score location\n0   1      m    10.0     30        N\n1   2      f     5.0     50       NE\n2   5    NaN     NaN     20        S\n3   6    NaN     NaN    100        C\n4   7    NaN     NaN     75        W\n\npd.merge(X, Y, on=\"id\", how=\"outer\")\n\n   id gender  income  score location\n0   1      m    10.0   30.0        N\n1   2      f     5.0   50.0       NE\n2   3      f    20.0    NaN      NaN\n3   4      m    15.0    NaN      NaN\n4   5    NaN     NaN   20.0        S\n5   6    NaN     NaN  100.0        C\n6   7    NaN     NaN   75.0        W"
  },
  {
    "objectID": "import.html#เรองท-4.1.1-การกำหนด-working-directory",
    "href": "import.html#เรองท-4.1.1-การกำหนด-working-directory",
    "title": "ตอนที่ 4.1 การนำเข้าและเขียนชุดข้อมูล (importing and writing data)",
    "section": "เรื่องที่ 4.1.1 การกำหนด working directory",
    "text": "เรื่องที่ 4.1.1 การกำหนด working directory\nสิ่งสำคัญอย่างแรกที่ผู้ใช้ภาษา R และ Python จำเป็นต้องทราบก่อนที่จะนำเข้าหรือเขียนชุดข้อมูลคือการเรียกดูและกำหนด working directory ของโปรแกรม working directory คือ folder ที่ R หรือ Python ใช้สำหรับเรียกไฟล์ข้อมูลหรือบันทึกไฟล์ข้อมูล รวมทั้งไฟล์อื่น ๆ ที่เกี่ยวข้อง\n\nภาษา R\nใน R ผู้วิเคราะห์สามารถเรียกดู working directory ของโปรแกรมได้โดยใช้ฟังก์ชัน getwd() ดังตัวอย่างต่อไปนี้\n\ngetwd()\n\n\n\n[1] \"/Users/siwachoat/Desktop\"\n\n\nผลลัพธ์ในข้างต้นแสดงว่า working directory ที่กำหนดมีที่อยู่คือ “/Users/siwachoat/Desktop” ในกรณีที่ต้องการเปลี่ยนที่อยู่ของ working directory สามารถทำได้ด้วยฟังก์ชัน setwd() โดยกำหนดที่อยู่ของ working directory ที่ต้องการเอาไว้ภายใต้เครื่องหมาย quotation ยกตัวอย่างเช่นต้องการเปลี่ยน working directory จากเดิม “/Users/siwachoat/Desktop” เป็น “/Users/siwachoat/Documents” สามารถเขียนคำสั่งได้ดังนี้\n\nsetwd(\"/Users/siwachoat/Documents\")\ngetwd()\n\n[1] \"/Users/siwachoat/Documents\"\n\n\nจากคำสั่งข้างต้นจะเห็นว่า working directory เปลี่ยนจาก “/Users/siwachoat/Desktop” ไปเป็น “/Users/siwachoat/Documents” ตามที่ต้องการ\nหมายเหตุ : เนื่องจากที่อยู่ของ working directory อาจเป็น subfolder ภายใต้ folder ใด ๆ บนเครื่องคอมพิวเตอร์ การกำหนดที่อยู่ของ working directory ที่ต้องการจึงจะกำหนดโดยเขียนเรียงเป็นลำดับชั้นจาก directory ที่อยู่บนสุดลงไปจาก subdirectory ที่อยู่ภายใต้ directory นั้น และจะมีการใช้สัญลักษณ์ \\ หรือ // อย่างใดอย่างหนึ่งเป็นตัวคั่นระหว่าง directory กับ subdirectory ดังกล่าว\n\n\nภาษา Python\nสำหรับภาษา Python การเรียกดูและกำหนด working directory สามารถทำได้ด้วย library os โดยใช้ฟังก์ชัน os.getcwd() และ os.chdir() ตามลำดับ ตัวอย่างต่อไปนี้แสดงการเรียกดู working directory ในภาษา Python\n\nimport os\nos.getcwd()\n\n'/Users/siwachoat/Library/CloudStorage/OneDrive-ChulalongkornUniversity/Documents/บริการวิชาการ/chapterbook มสธ./chapter/chapter'\n\n\n\nimport os\nos.chdir(\"/Users/siwachoat/Desktop\")\nos.getcwd()\n\n'/Users/siwachoat/Desktop'\n\n\nในทำนองเดียวกับตัวอย่างในภาษา R ผลลัพธ์ข้างต้นแสดงให้เห็นว่า working directory ที่กำหนดไว้คือ “/Users/siwachoat/Desktop” ในกรณีที่ต้องการเปลี่ยน working directory ดังกล่าวสามารถได้โดยเขียนคำสั่งในทำนองเดียวกับโปรแกรม R ดังนี้\n\nos.chdir(\"/Users/siwachoat/Documents\")\nos.getcwd()\n\n'/Users/siwachoat/Documents'"
  },
  {
    "objectID": "import.html#เรองท-4.1.2-การนำเขาขอมลประเภท-flat-file",
    "href": "import.html#เรองท-4.1.2-การนำเขาขอมลประเภท-flat-file",
    "title": "ตอนที่ 4.1 การนำเข้าและเขียนชุดข้อมูล (importing and writing data)",
    "section": "เรื่องที่ 4.1.2 การนำเข้าข้อมูลประเภท flat file",
    "text": "เรื่องที่ 4.1.2 การนำเข้าข้อมูลประเภท flat file\nflat files เป็นไฟล์ข้อมูลที่อยู่ในรูปแบบข้อความ (plain text) และชุดข้อมูลไม่ได้มีโครงสร้างการจัดเก็บในรูปแบบตารางหรือ spreadsheet แต่ flat file จะมีการใช้ตัวอักษรพิเศษ เช่น comma (,), slash (/) หรือ underscore (_) เป็นตัวคั่น (separator or delimiter) เพื่อจำแนกข้อมูลที่แตกต่างกันออกจากกัน รูป 4.1 แสดงลักษณะของชุดข้อมูลแบบ flat file ที่มีการใช้ตัวคั่นแบบ comma (,) และแบบเว้นวรรค (tab) จากรูปจะเห็นว่าตัวอย่างของไฟล์ข้อมูลทั้งสองมีโครงสร้างการจัดเก็บข้อมูลที่เหมือนกันกล่าวคือ ในแถวแรกของไฟล์ข้อมูลเป็นที่จัดเก็บชื่อของตัวแปรภายในชุดข้อมูล และตั้งแต่แถวที่สองเป็นต้นไปเป็นที่จัดเก็บข้อมูลของตัวแปรต่าง ๆ ของแต่ละหน่วยข้อมูล อย่างไรก็ตามในทางปฏิบัติแถวแรกของไฟล์ข้อมูลไม่จำเป็นจะต้องเป็นชื่อของตัวแปรเสมอไป\n\n\n\nรูป 4.1 ตัวอย่างโครงสร้างของ flat file แบบ CSV และ TSV\n\n\nที่มา : สิวะโชติ ศรีสุทธิยากร (2564)\nflat file ยังมีการเรียกชื่อที่เฉพาะตามลักษณะของตัวคั่นที่ใช้ในชุดข้อมูล จากรูปจะเห็นว่าชุดข้อมูลด้านบนมีการใช้ comma (,) เป็นตัวคั่น จะเรียกไฟล์ข้อมูลประเภทนี้ว่า comma separated values (CSV) หรืออาจเรียกว่า comma-delimited ก็ได้ ส่วนชุดข้อมูลด้านล่างของรูปมีการใช้ตัวคั่นเป็นการเว้นวรรค (tab) จะเรียกชุดข้อมูลประเภทนี้ว่า tab separated values (TSV) หรือ tab-delimited\n\nการนำเข้าและเขียนไฟล์แบบ CSV\nหัวข้อนี้จะกล่าวถึงวิธีการนำเข้าและเขียนไฟล์ข้อมูลแบบ CSV โดยจำแนกเนื้อหาออกเป็นสองส่วนได้แก่ ส่วนของภาษา R และ ภาษา Python รายละเอียดมีดังนี้\n\nภาษา R\nภาษา R สามารถนำเข้าและเขียนไฟล์ CSV ได้หลายวิธี วิธีการแรกเป็นการนำเข้าด้วยฟังก์ชันจาก package-utils ที่เป็น package พื้นฐานของ R ได้แก่ฟังก์ชัน read.csv() ที่มีอาร์กิวเมนท์สำคัญได้แก่ file ใช้ระบุที่อยู่และชื่อของไฟล์ข้อมูลแบบ CSV ที่ต้องการนำเข้าอาร์กิวเมนท์นี้ผู้วิเคราะห์จำเป็นต้องกำหนดแบบตัวแปรตัวอักษร (กล่าวคือต้องระบุไว้ภายใต้เครื่องหมาย quotation) อาร์กิวเมนท์ header ใช้ระบุว่าไฟล์ข้อมูลที่นำเข้ามีแถวแรกของไฟล์เป็นชื่อของตัวแปรหรือไม่ การกำหนดอาร์กิวเมนท์นี้กำหนดเป็นค่าความจริงได้แก่ TRUE หรือ FALSE โดยหากกำหนดเป็น TRUE (ค่าเริ่มต้น) จะหมายถึงการระบุว่าใช้แถวแรกของไฟล์ข้อมูลเป็นชื่อของตัวแปรในแต่ละคอลัมน์ ในกรณีที่กำหนดเป็น FALSE ฟังก์ชัน CSV จะกำหนดชื่อของคอลัมน์ให้โดยอัตโนมัติ ตัวอย่างด้านล่างแสดงการนำเข้าชุดข้อมูล gapminder_mini.csv\n\n# R syntax\ndat <- read.csv(\"gapminder_mini.csv\", header = TRUE)\nstr(dat)\n\n\n\n'data.frame':   142 obs. of  4 variables:\n $ X        : int  1 2 3 4 5 6 7 8 9 10 ...\n $ country  : chr  \"Afghanistan\" \"Albania\" \"Algeria\" \"Angola\" ...\n $ gdpPercap: num  975 5937 6223 4797 12779 ...\n $ lifeExp  : num  43.8 76.4 72.3 42.7 75.3 ...\n\n\nอาร์กิวเมนท์อีกตัวที่สำคัญของฟังก์ชัน read.csv() คืออาร์กิวเมนท์ na.strings ใช้ในกรณีที่ชุดข้อมูลที่ต้องการนำเข้ามีค่าสูญหาย การระบุอาร์กิวเมนท์ดังกล่าวให้ระบุเป็นสัญลักษณ์ที่ใช้แทนค่าสูญหายของชุดข้อมูลที่ต้องการนำเข้า เช่น หากชุดข้อมูลที่นำเข้าใช้สัญลักษณ์ -999 แทนค่าสูญหายให้กำหนด na.strings = -999 เป็นต้น นอกจากนี้ฟังก์ชัน read.csv() ยังมีอาร์กิวเมนท์ stringsAsFactors ที่กำหนดค่าเป็น TRUE หรือ FALSE เพื่อแปลงคอลัมน์ตัวอักษรในชุดข้อมูลให้เป็นตัวแปรแบบ factor ซึ่งเป็นตัวแปรแบบจัดประเภทของ R ผู้อ่านสามารถศึกษารายละเอียดเพิ่มเติมได้จาก สิวะโชติ ศรีสุทธิยากร (2564) หน้า 40\nตัวอย่างข้างต้นมีการใช้ฟังก์ชัน str() เพื่อเรียกดูข้อมูลเบื้องต้นของชุดข้อมูล gapminder_mini.csv ที่นำเข้ามาด้วยฟังก์ชัน read.csv() ในข้างต้น ฟังก์ชันดังกล่าวจะรายงานมิติหรือขนาดของชุดข้อมูล ชื่อของตัวแปรในแต่ละคอลัมนท์ รวมทั้งคุณลักษณะของตัวแปรภายในแต่ละคอลัมน์ สำหรับผู้ที่เคยใช้ SPSS จะพอเทียบเคียงได้ว่าผลลัพธ์จากฟังก์ชัน str() นี้จะให้สารสนเทศในทำนองเดียวกับหน้าต่าง variable view ของโปรแกรม SPSS รายละเอียดของฟังก์ชันนี้จะกล่าวอีกครั้งหนึ่งในหัวข้อ 4.2\nภาษา R ยังมีความสามารถในการเขียนไฟล์ชุดข้อมูลเพื่อส่งออกไปบันทึกในคอมพิวเตอร์สำหรับนำไปใช้ในวัตถุประสงค์ต่าง ๆ การเขียนไฟล์แบบ CSV สามารถทำได้หลายวิธีการเช่นกัน วิธีการพื้นฐานคือการใช้ฟังก์ชัน write.csv() ที่มีอาร์กิวเมนท์สำคัญ 2 ตัวได้แก่ x คือชุดข้อมูลแบบ Dataframe ที่ต้องการเขียนออกไปเป็นไฟล์แบบ CSV และ file ใช้ระบุที่อยู่และชื่อของไฟล์ปลายทางที่จะให้ R เขียนออกไปบันทึกในคอมพิวเตอร์ ทั้งนี้รูปแบบของชื่อไฟล์ต้องเขียนในลักษณะตัวอักษรกล่าวคืออยู่ภายใต้เครื่องหมาย quotation และมีนามสกุลของไฟล์เป็นแบบ `*.csv` ดังตัวอย่างด้านล่าง\n\n# R syntax\nwrite.csv(dat, file=\"Desktop/mydata.csv\")\n\nคำสั่งด้านบนจะเขียนไฟล์ my.data.csv ไว้บน Desktop ของเครื่องคอมพิวเตอร์ ในกรณีที่ผู้วิเคราะห์กำหนดแค่ชื่อไฟล์ปลายทางแต่ไม่ได้กำหนดที่อยู่ของไฟล์ เช่น write.csv(dat, file=\"mydata.csv\") ไฟล์ที่สร้างขึ้นจะบันทึกไว้ใน folder เป็นค่าเริ่มต้นหรือ folder ที่กำหนดเป็น working directory เอาไว้ การกำหนด working directory สามารถทำได้โดยใช้ฟังก์ชัน setwd() โดยภายในฟังก์ชันให้ใส่ที่อยู่ของ folder ที่ต้องการกำหนดให้เป็น working directory ในลักษณะตัวอักษร เช่น setwd(\"/Desktop/myjob\") หมายถึงกำหนดให้ working directory เป็น folder myjob ที่อยู่บน Desktop ของเครื่องคอมพิวเตอร์ รายละเอียดอื่น ๆ เกี่ยวกับการกำหนด working directory ใน R สามารถศึกษาเพิ่มเติมได้จาก สิวะโชติ ศรีสุทธิยากร (2564)\nรูปด้านล่างแสดงลักษณะของไฟล์ข้อมูล mydata.csv ที่เขียนออกจากโปรแกรม R ด้วยคำสั่งในข้างต้น จากรูปใช้โปรแกรม text editor เพื่อเปิดไฟล์ดังกล่าว\n\n\n\nไฟล์ข้อมูล myCSV.csv\n\n\nโดยปกติแล้ว MS Excel หรือ Number หรือ googlesheet มีตัวอ่านไฟล์ข้อมูลประเภท flatfile อยู่แล้วผู้อ่านสามารถใช้โปรแกรมดังกล่าวเพื่อเปิดไฟล์ข้อมูลประเภท CSV หรือ flatfile ประเภทอื่น ๆ ได้โดยง่าย\n\n\nภาษา Python\nสำหรับการนำเข้าและเขียนไฟล์ข้อมูลแบบ CSV ด้วยภาษา Python สามารถทำได้โดยใช้ฟังก์ชัน pd.read_csv() ของ pandas library ฟังก์ชันนี้มีพารามิเตอร์ได้แก่ filepath ใช้กำหนดที่อยู่และชื่อของไฟล์ที่ต้องการนำเข้า พารามิเตอร์ sep สำหรับระบุตัวอักษรที่ใช้เป็นตัวคั่นในชุดข้อมูล ซึ่งในกรณีนี้จะกำหนดให้ sep=\",\" เพื่อนำเข้าชุดข้อมูลแบบ CSV พารามิเตอร์ header สำหรับระบุว่าแถวที่เท่าไหร่ในตารางข้อมูลจะใช้เป็นชื่อของตัวแปร (เริ่มจาก 0) พารามิเตอร์ skiprows ใช้กำหนดให้ Python อ่านไฟล์ข้อมูลโดยข้ามแถวไปจำนวนเท่ากับที่กำหนด พารามิเตอร์นี้มีประโยชน์มากสำหรับการนำเข้าไฟล์ข้อมูลจากองค์กร หรือ logfile ที่หัวของตารางมักมีคำอธิบายหรือ caption ต่าง ๆ ก่อนที่จะเป็นส่วนของตารางข้อมูล ฟังก์ชัน pd.read_csv() ยังมีพารามิเตอร์อีกหลายตัว (optional parameters) ที่สามารถกำหนดเพื่อปรับแต่งลักษณะของข้อมูลที่นำเข้ามาได้ รายละเอียดอื่น ๆ ผู้อ่านสามารถศึกษาเพิ่มเติมได้จาก https://pandas.pydata.org/docs/reference/api/pandas.read_csv.html\n\n# Python syntax\nimport pandas as pd\ndat = pd.read_csv(\"/Users/siwachoat/Downloads/gapminder.csv\", header=0)\ndat\n\n     Unnamed: 0             country     gdpPercap  lifeExp\n0             1         Afghanistan    974.580338   43.828\n1             2             Albania   5937.029526   76.423\n2             3             Algeria   6223.367465   72.301\n3             4              Angola   4797.231267   42.731\n4             5           Argentina  12779.379640   75.320\n..          ...                 ...           ...      ...\n137         138             Vietnam   2441.576404   74.249\n138         139  West Bank and Gaza   3025.349798   73.422\n139         140         Yemen, Rep.   2280.769906   62.698\n140         141              Zambia   1271.211593   42.384\n141         142            Zimbabwe    469.709298   43.487\n\n[142 rows x 4 columns]\n\n\nการเขียนไฟล์ CSV ด้วยภาษา Python สามารถทำได้หลายวิธี วิธีการหนึ่งคือการใช้ method to_csv() ซึ่งเป็น method หนึ่งภายใต้ pandas library พารามิเตอร์สำคัญของ method นี้ได้แก่ ตัวอย่างด้านล่างแสดงการเขียนไฟล์ข้อมูลใน Python เพื่อบันทึกลงใน folder ที่กำหนดไว้บนเครื่องคอมพิวเตอร์ สมมุติว่าผู้วิเคราะห์สร้างชุดข้อมูลใน Python เพื่อเก็บข้อมูลคะแนนสอบของนิสิตในรายวิชาแคลคูลัส (calculus) สถิติ (statistics) และคณิตศาสตร์ (math) การเขียนไฟล์ข้อมูลดังกล่าวเป็นไฟล์ CSV สามารถทำได้ดังนี้\n\nimport pandas as pd\nheader = [\"students\",\"calculus\",\"statistics\",\"math\"]\nrow_data = [[1,80,75,70],\n            [2,40,55,60],\n            [3,84,85,86],\n            [4,51,38,43],\n            [5,67,73,77]]\ndata = pd.DataFrame(row_data, columns=header)\ndata\n\n   students  calculus  statistics  math\n0         1        80          75    70\n1         2        40          55    60\n2         3        84          85    86\n3         4        51          38    43\n4         5        67          73    77\n\ndata.to_csv(\"myCSV.csv\", sep=\",\")\n\nผู้อ่านสามารถศึกษารายละเอียดของ to_csv() ได้จาก https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.to_csv.html\n\n\n\nการนำเข้าและเขียนไฟล์แบบ TSV\nดังที่กล่าวไปแล้วข้างต้น ไฟล์แบบ TSV เป็นไฟล์ข้อมูลแบบ flat file ที่มีการใช้ตัวคั่นข้อมูลเป็นเครื่องหมายเว้นวรรค (tab) การนำเข้าไฟล์ข้อมูล TSV การนำเข้าและเขียนไฟล์ลักษณะดังกล่าวของแต่ละภาษาจึงสามารถดำเนินการได้ในทำนองเดียวกับไฟล์แบบ CSV รายละเอียดมีดังนี้\n\nภาษา R\nในภาษา R สามารถทำได้โดยใช้ฟังก์ชัน read.table() โดยอาร์กิวเมนท์ของฟังก์ชันนี้มีส่วนของอาร์กิวเมนท์จำเป็นที่เหมือนกับของฟังก์ชัน read.csv() ได้แก่ file ที่ใช้ระบุที่อยู่และชื่อของไฟล์ข้อมูลที่ต้องการนำเข้า โดยจะต้องระบุในลักษณะของตัวแปรตัวอักษรใน R กล่าวคือต้องระบุภายใต้เครื่องหมาย quotation อาร์กิวเมนท์ header ที่กำหนดได้ 2 ค่าคือ TRUE และ FALSE โดยที่ค่าเริ่มต้นคือ header=FALSE ซึ่งหมายความว่าตารางข้อมูลที่จะนำเข้ามานั้นเป็นตารางที่ไม่มีหัวตาราง และอาร์กิวเมนท์ sep ใช้ระบุลักษณะของตัวคั่นข้อมูลที่ใช้ในไฟล์ข้อมูล อาร์กิวเมนท์นี้จึงทำให้ฟังก์ชัน read.table() สามารถนำเข้า flat file ได้หลายประเภทไม่ได้จำกัดแค่เฉพาะ CSV หรือ TSV เท่านั้น นอกจากนี้ยังมีอาร์กิวเมนท์ skip ที่ทำงานเหมือนกับพารามิเตอร์ skiprows ในฟังก์ชัน pd.read_csv() ของภาษา Python ฟังก์ชัน read.table() เป็นฟังก์ชันที่มีอาร์กิวเมนท์ที่สามารถกำหนดได้จำนวนมาก รายละเอียดอื่น ๆ เกี่ยวข้องผู้อ่านสามารถศึกษาได้จากคู่มือของฟังก์ชันโดยพิมพ์คำสั่ง ?read.table()\nจากที่กล่าวในข้างต้นจะเห็นว่า read.table() เป็นฟังก์ชันทั่วไปของ read.csv() ตัวอย่างต่อไปนี้แสดงให้เห็นว่าสามารถใช้ฟังก์ชัน read.table() เพื่อนำเข้าไฟล์แบบ CSV ได้\n\ndat <- read.table(\"/Users/siwachoat/Downloads/gapminder.csv\", header=TRUE, sep=\",\")\nhead(dat)\n\n  X     country  gdpPercap lifeExp\n1 1 Afghanistan   974.5803  43.828\n2 2     Albania  5937.0295  76.423\n3 3     Algeria  6223.3675  72.301\n4 4      Angola  4797.2313  42.731\n5 5   Argentina 12779.3796  75.320\n6 6   Australia 34435.3674  81.235\n\n\nชุดข้อมูล myTSV.txt เป็นชุดข้อมูลแบบ flat file ที่มีการใช้ตัวคั่นเป็นเครื่องหมายเว้นวรรค (tab) การนำชุดข้อมูลดังกล่าวเข้าสู่โปรแกรม R ด้วยฟังก์ชัน read.table() สามารถทำได้โดยกำหนดอาร์กิวเมนท์ sep = \" \" ดังตัวอย่างต่อไปนี้\n\ndat_TSV <- read.table(\"https://raw.githubusercontent.com/ssiwacho/dataset/main/myTSV.txt\",\n                      header = TRUE, sep = \" \")\ndat_TSV\n\n  X students calculus statistics math\n1 0        1       80         75   70\n2 1        2       40         55   60\n3 2        3       84         85   86\n4 3        4       51         38   43\n5 4        5       67         73   77\n\n\nในทำนองเดียวกับการนำเข้าและเขียนไฟล์ CSV การเขียนไฟล์ TSV สามารถทำได้โดยใช้ฟังก์ชัน write.table() ที่มีอาร์กิวเมนท์สำคัญเหมือนกับฟังก์ชัน write.csv() ทุกประการ ความแตกต่างระหว่าง write.table() กับ write.csv() อันหนึ่งคือฟังก์ชัน write.table() มีอาร์กิวเมนท์ sep ที่ทำให้ผู้วิเคราะห์สามารถเลือกกำหนดได้ว่าจะเขียนไฟล์ข้อมูลของตนเองโดยใช้ตัวคั่นแบบใด ตัวอย่างต่อไปนี้แสดงการเขียนไฟล์ TSV ด้วยฟังก์ชัน write.table() จากชุดข้อมูลแบบ data.frame ที่สร้างเองบนโปรแกรม R\n\n#เพศของนักเรียน\ngender <- c(\"M\",\"M\",\"F\",\"F\",\"F\",\"M\") \n#วิธีการสอนของครู\nmethod <- c(\"LEC\",\"LEC\",\"LEC\",\"PBL\",\"PBL\",\"PBL\") \n# คะแนนสอบวิชา Eng\neng <- c(6, 5.5, 7, 7, 8, 8.5)\n\nmydat<-data.frame(gender, method, eng)\nmydat\n\n  gender method eng\n1      M    LEC 6.0\n2      M    LEC 5.5\n3      F    LEC 7.0\n4      F    PBL 7.0\n5      F    PBL 8.0\n6      M    PBL 8.5\n\n\nชุดคำสั่งข้างต้นเป็นการสร้างชุดข้อมูลแบบ data.frame ในโปรแกรม R ด้วยฟังก์ชัน data.frame() โดยเก็บชุดข้อมูลดังกล่าวเอาไว้ในตัวแปรชื่อ mydat การเขียนชุดข้อมูลนี้ออกไปบนเครื่องคอมพิวเตอร์เพื่อเก็บเป็นไฟล์ข้อมูลประเภท TSV สามารถดำเนินการได้ด้วยฟังก์ชัน write.table() ดังนี้\n\nwrite.table(mydat, file=\"mytsvfromR.txt\", sep=\" \")\n\nรูปต่อไปนี้แสดงลักษณะของไฟล์ข้อมูล mstsvformR.txt ที่เขียนด้วยฟังก์ชัน write.table() ในข้างต้น จากรูปไฟล์ข้อมูลดังกล่าวเปิดด้วยโปรแกรม text editor\n\n\n\nไฟล์ข้อมูล mytsvfromR.txt\n\n\n\n\nภาษา Python\nสำหรับภาษา Python การนำเข้าและเขียนไฟล์ TSV รวมทั้ง flat file แบบอื่น ๆ สามารถทำได้ด้วยฟังก์ชัน pd.read_csv() โดยเปลี่ยนค่าของพารามิเตอร์ sep ให้ตรงกับตัวคั่นที่ใช้ในไฟล์ข้อมูล ยกตัวอย่างเช่น หากต้องการนำเข้าชุดข้อมูล myTSV.txt สามารถดำเนินการได้ดังนี้\n\ndat_TSV = pd.read_csv(\"https://raw.githubusercontent.com/ssiwacho/dataset/main/myTSV.txt\",\nheader = 0, sep = \" \")\ndat_TSV\n\n   Unnamed: 0  students  calculus  statistics  math\n0           0         1        80          75    70\n1           1         2        40          55    60\n2           2         3        84          85    86\n3           3         4        51          38    43\n4           4         5        67          73    77\n\n\nในทำนองเดียวกันการเขียนไฟล์แบบ TSV ในภาษา Python สามารถทำได้ด้วยฟังก์ชัน data.to_csv() เหมือนกับที่ใช้เขียนไฟล์ CSV โดยเปลี่ยนตัวคั่นให้ตรงกับลักษณะไฟล์ที่ต้องการเขียนออกไปเก็บไว้บนคอมพิวเตอร์ ตัวอย่างต่อไปนี้แสดงการเขียนชุดข้อมูล dat_TSV ในตัวอย่างที่แล้วออกไปเป็นไฟล์ TSV บนเครื่องคอมพิวเตอร์\n\ndat_TSV.to_csv(\"Dataframe_to_TSV_python.txt\", sep=\" \")"
  },
  {
    "objectID": "import.html#เรองท-4.1.3-การนำเขาขอมลประเภท-spreadsheet",
    "href": "import.html#เรองท-4.1.3-การนำเขาขอมลประเภท-spreadsheet",
    "title": "ตอนที่ 4.1 การนำเข้าและเขียนชุดข้อมูล (importing and writing data)",
    "section": "เรื่องที่ 4.1.3 การนำเข้าข้อมูลประเภท spreadsheet",
    "text": "เรื่องที่ 4.1.3 การนำเข้าข้อมูลประเภท spreadsheet"
  },
  {
    "objectID": "import.html#เรองท-4.1.2-การนำเขาและเขยนขอมลประเภท-flat-file",
    "href": "import.html#เรองท-4.1.2-การนำเขาและเขยนขอมลประเภท-flat-file",
    "title": "ตอนที่ 4.1 การนำเข้าและเขียนชุดข้อมูล (importing and writing data)",
    "section": "เรื่องที่ 4.1.2 การนำเข้าและเขียนข้อมูลประเภท flat file",
    "text": "เรื่องที่ 4.1.2 การนำเข้าและเขียนข้อมูลประเภท flat file\nflat files เป็นไฟล์ข้อมูลที่อยู่ในรูปแบบข้อความ (plain text) และชุดข้อมูลไม่ได้มีโครงสร้างการจัดเก็บในรูปแบบตารางหรือ spreadsheet แต่ flat file จะมีการใช้ตัวอักษรพิเศษ เช่น comma (,), slash (/) หรือ underscore (_) เป็นตัวคั่น (separator or delimiter) เพื่อจำแนกข้อมูลที่แตกต่างกันออกจากกัน รูป 4.1 แสดงลักษณะของชุดข้อมูลแบบ flat file ที่มีการใช้ตัวคั่นแบบ comma (,) และแบบเว้นวรรค (tab) จากรูปจะเห็นว่าตัวอย่างของไฟล์ข้อมูลทั้งสองมีโครงสร้างการจัดเก็บข้อมูลที่เหมือนกันกล่าวคือ ในแถวแรกของไฟล์ข้อมูลเป็นที่จัดเก็บชื่อของตัวแปรภายในชุดข้อมูล และตั้งแต่แถวที่สองเป็นต้นไปเป็นที่จัดเก็บข้อมูลของตัวแปรต่าง ๆ ของแต่ละหน่วยข้อมูล อย่างไรก็ตามในทางปฏิบัติแถวแรกของไฟล์ข้อมูลไม่จำเป็นจะต้องเป็นชื่อของตัวแปรเสมอไป\n\n\n\nรูป 4.1 ตัวอย่างโครงสร้างของ flat file แบบ CSV และ TSV\n\n\nที่มา : สิวะโชติ ศรีสุทธิยากร (2564)\nflat file ยังมีการเรียกชื่อที่เฉพาะตามลักษณะของตัวคั่นที่ใช้ในชุดข้อมูล จากรูปจะเห็นว่าชุดข้อมูลด้านบนมีการใช้ comma (,) เป็นตัวคั่น จะเรียกไฟล์ข้อมูลประเภทนี้ว่า comma separated values (CSV) หรืออาจเรียกว่า comma-delimited ก็ได้ ส่วนชุดข้อมูลด้านล่างของรูปมีการใช้ตัวคั่นเป็นการเว้นวรรค (tab) จะเรียกชุดข้อมูลประเภทนี้ว่า tab separated values (TSV) หรือ tab-delimited\n\nการนำเข้าและเขียนไฟล์แบบ CSV\nหัวข้อนี้จะกล่าวถึงวิธีการนำเข้าและเขียนไฟล์ข้อมูลแบบ CSV โดยจำแนกเนื้อหาออกเป็นสองส่วนได้แก่ ส่วนของภาษา R และ ภาษา Python รายละเอียดมีดังนี้\n\nภาษา R\nภาษา R สามารถนำเข้าและเขียนไฟล์ CSV ได้หลายวิธี วิธีการแรกเป็นการนำเข้าด้วยฟังก์ชันจาก package-utils ที่เป็น package พื้นฐานของ R ได้แก่ฟังก์ชัน read.csv() ที่มีอาร์กิวเมนท์สำคัญได้แก่ file ใช้ระบุที่อยู่และชื่อของไฟล์ข้อมูลแบบ CSV ที่ต้องการนำเข้าอาร์กิวเมนท์นี้ผู้วิเคราะห์จำเป็นต้องกำหนดแบบตัวแปรตัวอักษร (กล่าวคือต้องระบุไว้ภายใต้เครื่องหมาย quotation) อาร์กิวเมนท์ header ใช้ระบุว่าไฟล์ข้อมูลที่นำเข้ามีแถวแรกของไฟล์เป็นชื่อของตัวแปรหรือไม่ การกำหนดอาร์กิวเมนท์นี้กำหนดเป็นค่าความจริงได้แก่ TRUE หรือ FALSE โดยหากกำหนดเป็น TRUE (ค่าเริ่มต้น) จะหมายถึงการระบุว่าใช้แถวแรกของไฟล์ข้อมูลเป็นชื่อของตัวแปรในแต่ละคอลัมน์ ในกรณีที่กำหนดเป็น FALSE ฟังก์ชัน CSV จะกำหนดชื่อของคอลัมน์ให้โดยอัตโนมัติ ตัวอย่างด้านล่างแสดงการนำเข้าชุดข้อมูล gapminder_mini.csv\n\n# R syntax\ndat <- read.csv(\"gapminder_mini.csv\", header = TRUE)\nstr(dat)\n\n\n\n'data.frame':   142 obs. of  4 variables:\n $ X        : int  1 2 3 4 5 6 7 8 9 10 ...\n $ country  : chr  \"Afghanistan\" \"Albania\" \"Algeria\" \"Angola\" ...\n $ gdpPercap: num  975 5937 6223 4797 12779 ...\n $ lifeExp  : num  43.8 76.4 72.3 42.7 75.3 ...\n\n\nอาร์กิวเมนท์อีกตัวที่สำคัญของฟังก์ชัน read.csv() คืออาร์กิวเมนท์ na.strings ใช้ในกรณีที่ชุดข้อมูลที่ต้องการนำเข้ามีค่าสูญหาย การระบุอาร์กิวเมนท์ดังกล่าวให้ระบุเป็นสัญลักษณ์ที่ใช้แทนค่าสูญหายของชุดข้อมูลที่ต้องการนำเข้า เช่น หากชุดข้อมูลที่นำเข้าใช้สัญลักษณ์ -999 แทนค่าสูญหายให้กำหนด na.strings = -999 เป็นต้น นอกจากนี้ฟังก์ชัน read.csv() ยังมีอาร์กิวเมนท์ stringsAsFactors ที่กำหนดค่าเป็น TRUE หรือ FALSE เพื่อแปลงคอลัมน์ตัวอักษรในชุดข้อมูลให้เป็นตัวแปรแบบ factor ซึ่งเป็นตัวแปรแบบจัดประเภทของ R ผู้อ่านสามารถศึกษารายละเอียดเพิ่มเติมได้จาก สิวะโชติ ศรีสุทธิยากร (2564) หน้า 40\nตัวอย่างข้างต้นมีการใช้ฟังก์ชัน str() เพื่อเรียกดูข้อมูลเบื้องต้นของชุดข้อมูล gapminder_mini.csv ที่นำเข้ามาด้วยฟังก์ชัน read.csv() ในข้างต้น ฟังก์ชันดังกล่าวจะรายงานมิติหรือขนาดของชุดข้อมูล ชื่อของตัวแปรในแต่ละคอลัมนท์ รวมทั้งคุณลักษณะของตัวแปรภายในแต่ละคอลัมน์ สำหรับผู้ที่เคยใช้ SPSS จะพอเทียบเคียงได้ว่าผลลัพธ์จากฟังก์ชัน str() นี้จะให้สารสนเทศในทำนองเดียวกับหน้าต่าง variable view ของโปรแกรม SPSS รายละเอียดของฟังก์ชันนี้จะกล่าวอีกครั้งหนึ่งในหัวข้อ 4.2\nภาษา R ยังมีความสามารถในการเขียนไฟล์ชุดข้อมูลเพื่อส่งออกไปบันทึกในคอมพิวเตอร์สำหรับนำไปใช้ในวัตถุประสงค์ต่าง ๆ การเขียนไฟล์แบบ CSV สามารถทำได้หลายวิธีการเช่นกัน วิธีการพื้นฐานคือการใช้ฟังก์ชัน write.csv() ที่มีอาร์กิวเมนท์สำคัญ 2 ตัวได้แก่ x คือชุดข้อมูลแบบ Dataframe ที่ต้องการเขียนออกไปเป็นไฟล์แบบ CSV และ file ใช้ระบุที่อยู่และชื่อของไฟล์ปลายทางที่จะให้ R เขียนออกไปบันทึกในคอมพิวเตอร์ ทั้งนี้รูปแบบของชื่อไฟล์ต้องเขียนในลักษณะตัวอักษรกล่าวคืออยู่ภายใต้เครื่องหมาย quotation และมีนามสกุลของไฟล์เป็นแบบ `*.csv` ดังตัวอย่างด้านล่าง\n\n# R syntax\nwrite.csv(dat, file=\"Desktop/mydata.csv\")\n\nคำสั่งด้านบนจะเขียนไฟล์ my.data.csv ไว้บน Desktop ของเครื่องคอมพิวเตอร์ ในกรณีที่ผู้วิเคราะห์กำหนดแค่ชื่อไฟล์ปลายทางแต่ไม่ได้กำหนดที่อยู่ของไฟล์ เช่น write.csv(dat, file=\"mydata.csv\") ไฟล์ที่สร้างขึ้นจะบันทึกไว้ใน folder เป็นค่าเริ่มต้นหรือ folder ที่กำหนดเป็น working directory เอาไว้ การกำหนด working directory สามารถทำได้โดยใช้ฟังก์ชัน setwd() โดยภายในฟังก์ชันให้ใส่ที่อยู่ของ folder ที่ต้องการกำหนดให้เป็น working directory ในลักษณะตัวอักษร เช่น setwd(\"/Desktop/myjob\") หมายถึงกำหนดให้ working directory เป็น folder myjob ที่อยู่บน Desktop ของเครื่องคอมพิวเตอร์ รายละเอียดอื่น ๆ เกี่ยวกับการกำหนด working directory ใน R สามารถศึกษาเพิ่มเติมได้จาก สิวะโชติ ศรีสุทธิยากร (2564)\nรูปด้านล่างแสดงลักษณะของไฟล์ข้อมูล mydata.csv ที่เขียนออกจากโปรแกรม R ด้วยคำสั่งในข้างต้น จากรูปใช้โปรแกรม text editor เพื่อเปิดไฟล์ดังกล่าว\n\n\n\nไฟล์ข้อมูล myCSV.csv\n\n\nโดยปกติแล้ว MS Excel หรือ Number หรือ googlesheet มีตัวอ่านไฟล์ข้อมูลประเภท flatfile อยู่แล้วผู้อ่านสามารถใช้โปรแกรมดังกล่าวเพื่อเปิดไฟล์ข้อมูลประเภท CSV หรือ flatfile ประเภทอื่น ๆ ได้โดยง่าย\n\n\nภาษา Python\nสำหรับการนำเข้าและเขียนไฟล์ข้อมูลแบบ CSV ด้วยภาษา Python สามารถทำได้โดยใช้ฟังก์ชัน pd.read_csv() ของ pandas library ฟังก์ชันนี้มีพารามิเตอร์ได้แก่ filepath ใช้กำหนดที่อยู่และชื่อของไฟล์ที่ต้องการนำเข้า พารามิเตอร์ sep สำหรับระบุตัวอักษรที่ใช้เป็นตัวคั่นในชุดข้อมูล ซึ่งในกรณีนี้จะกำหนดให้ sep=\",\" เพื่อนำเข้าชุดข้อมูลแบบ CSV พารามิเตอร์ header สำหรับระบุว่าแถวที่เท่าไหร่ในตารางข้อมูลจะใช้เป็นชื่อของตัวแปร (เริ่มจาก 0) พารามิเตอร์ skiprows ใช้กำหนดให้ Python อ่านไฟล์ข้อมูลโดยข้ามแถวไปจำนวนเท่ากับที่กำหนด พารามิเตอร์นี้มีประโยชน์มากสำหรับการนำเข้าไฟล์ข้อมูลจากองค์กร หรือ logfile ที่หัวของตารางมักมีคำอธิบายหรือ caption ต่าง ๆ ก่อนที่จะเป็นส่วนของตารางข้อมูล ฟังก์ชัน pd.read_csv() ยังมีพารามิเตอร์อีกหลายตัว (optional parameters) ที่สามารถกำหนดเพื่อปรับแต่งลักษณะของข้อมูลที่นำเข้ามาได้ รายละเอียดอื่น ๆ ผู้อ่านสามารถศึกษาเพิ่มเติมได้จาก https://pandas.pydata.org/docs/reference/api/pandas.read_csv.html\n\n# Python syntax\nimport pandas as pd\ndat = pd.read_csv(\"/Users/siwachoat/Downloads/gapminder.csv\", header=0)\ndat\n\n     Unnamed: 0             country     gdpPercap  lifeExp\n0             1         Afghanistan    974.580338   43.828\n1             2             Albania   5937.029526   76.423\n2             3             Algeria   6223.367465   72.301\n3             4              Angola   4797.231267   42.731\n4             5           Argentina  12779.379640   75.320\n..          ...                 ...           ...      ...\n137         138             Vietnam   2441.576404   74.249\n138         139  West Bank and Gaza   3025.349798   73.422\n139         140         Yemen, Rep.   2280.769906   62.698\n140         141              Zambia   1271.211593   42.384\n141         142            Zimbabwe    469.709298   43.487\n\n[142 rows x 4 columns]\n\n\nการเขียนไฟล์ CSV ด้วยภาษา Python สามารถทำได้หลายวิธี วิธีการหนึ่งคือการใช้ method to_csv() ซึ่งเป็น method หนึ่งภายใต้ pandas library พารามิเตอร์สำคัญของ method นี้ได้แก่ ตัวอย่างด้านล่างแสดงการเขียนไฟล์ข้อมูลใน Python เพื่อบันทึกลงใน folder ที่กำหนดไว้บนเครื่องคอมพิวเตอร์ สมมุติว่าผู้วิเคราะห์สร้างชุดข้อมูลใน Python เพื่อเก็บข้อมูลคะแนนสอบของนิสิตในรายวิชาแคลคูลัส (calculus) สถิติ (statistics) และคณิตศาสตร์ (math) การเขียนไฟล์ข้อมูลดังกล่าวเป็นไฟล์ CSV สามารถทำได้ดังนี้\n\nimport pandas as pd\nheader = [\"students\",\"calculus\",\"statistics\",\"math\"]\nrow_data = [[1,80,75,70],\n            [2,40,55,60],\n            [3,84,85,86],\n            [4,51,38,43],\n            [5,67,73,77]]\ndata = pd.DataFrame(row_data, columns=header)\ndata\n\n   students  calculus  statistics  math\n0         1        80          75    70\n1         2        40          55    60\n2         3        84          85    86\n3         4        51          38    43\n4         5        67          73    77\n\ndata.to_csv(\"myCSV.csv\", sep=\",\")\n\nผู้อ่านสามารถศึกษารายละเอียดของ to_csv() ได้จาก https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.to_csv.html\n\n\n\nการนำเข้าและเขียนไฟล์แบบ TSV\nดังที่กล่าวไปแล้วข้างต้น ไฟล์แบบ TSV เป็นไฟล์ข้อมูลแบบ flat file ที่มีการใช้ตัวคั่นข้อมูลเป็นเครื่องหมายเว้นวรรค (tab) การนำเข้าไฟล์ข้อมูล TSV การนำเข้าและเขียนไฟล์ลักษณะดังกล่าวของแต่ละภาษาจึงสามารถดำเนินการได้ในทำนองเดียวกับไฟล์แบบ CSV รายละเอียดมีดังนี้\n\nภาษา R\nในภาษา R สามารถทำได้โดยใช้ฟังก์ชัน read.table() โดยอาร์กิวเมนท์ของฟังก์ชันนี้มีส่วนของอาร์กิวเมนท์จำเป็นที่เหมือนกับของฟังก์ชัน read.csv() ได้แก่ file ที่ใช้ระบุที่อยู่และชื่อของไฟล์ข้อมูลที่ต้องการนำเข้า โดยจะต้องระบุในลักษณะของตัวแปรตัวอักษรใน R กล่าวคือต้องระบุภายใต้เครื่องหมาย quotation อาร์กิวเมนท์ header ที่กำหนดได้ 2 ค่าคือ TRUE และ FALSE โดยที่ค่าเริ่มต้นคือ header=FALSE ซึ่งหมายความว่าตารางข้อมูลที่จะนำเข้ามานั้นเป็นตารางที่ไม่มีหัวตาราง และอาร์กิวเมนท์ sep ใช้ระบุลักษณะของตัวคั่นข้อมูลที่ใช้ในไฟล์ข้อมูล อาร์กิวเมนท์นี้จึงทำให้ฟังก์ชัน read.table() สามารถนำเข้า flat file ได้หลายประเภทไม่ได้จำกัดแค่เฉพาะ CSV หรือ TSV เท่านั้น นอกจากนี้ยังมีอาร์กิวเมนท์ skip ที่ทำงานเหมือนกับพารามิเตอร์ skiprows ในฟังก์ชัน pd.read_csv() ของภาษา Python ฟังก์ชัน read.table() เป็นฟังก์ชันที่มีอาร์กิวเมนท์ที่สามารถกำหนดได้จำนวนมาก รายละเอียดอื่น ๆ เกี่ยวข้องผู้อ่านสามารถศึกษาได้จากคู่มือของฟังก์ชันโดยพิมพ์คำสั่ง ?read.table()\nจากที่กล่าวในข้างต้นจะเห็นว่า read.table() เป็นฟังก์ชันทั่วไปของ read.csv() ตัวอย่างต่อไปนี้แสดงให้เห็นว่าสามารถใช้ฟังก์ชัน read.table() เพื่อนำเข้าไฟล์แบบ CSV ได้\n\ndat <- read.table(\"/Users/siwachoat/Downloads/gapminder.csv\", header=TRUE, sep=\",\")\nhead(dat)\n\n  X     country  gdpPercap lifeExp\n1 1 Afghanistan   974.5803  43.828\n2 2     Albania  5937.0295  76.423\n3 3     Algeria  6223.3675  72.301\n4 4      Angola  4797.2313  42.731\n5 5   Argentina 12779.3796  75.320\n6 6   Australia 34435.3674  81.235\n\n\nชุดข้อมูล myTSV.txt เป็นชุดข้อมูลแบบ flat file ที่มีการใช้ตัวคั่นเป็นเครื่องหมายเว้นวรรค (tab) การนำชุดข้อมูลดังกล่าวเข้าสู่โปรแกรม R ด้วยฟังก์ชัน read.table() สามารถทำได้โดยกำหนดอาร์กิวเมนท์ sep = \" \" ดังตัวอย่างต่อไปนี้\n\ndat_TSV <- read.table(\"https://raw.githubusercontent.com/ssiwacho/dataset/main/myTSV.txt\",\n                      header = TRUE, sep = \" \")\ndat_TSV\n\n  X students calculus statistics math\n1 0        1       80         75   70\n2 1        2       40         55   60\n3 2        3       84         85   86\n4 3        4       51         38   43\n5 4        5       67         73   77\n\n\nในทำนองเดียวกับการนำเข้าและเขียนไฟล์ CSV การเขียนไฟล์ TSV สามารถทำได้โดยใช้ฟังก์ชัน write.table() ที่มีอาร์กิวเมนท์สำคัญเหมือนกับฟังก์ชัน write.csv() ทุกประการ ความแตกต่างระหว่าง write.table() กับ write.csv() อันหนึ่งคือฟังก์ชัน write.table() มีอาร์กิวเมนท์ sep ที่ทำให้ผู้วิเคราะห์สามารถเลือกกำหนดได้ว่าจะเขียนไฟล์ข้อมูลของตนเองโดยใช้ตัวคั่นแบบใด ตัวอย่างต่อไปนี้แสดงการเขียนไฟล์ TSV ด้วยฟังก์ชัน write.table() จากชุดข้อมูลแบบ data.frame ที่สร้างเองบนโปรแกรม R\n\n#เพศของนักเรียน\ngender <- c(\"M\",\"M\",\"F\",\"F\",\"F\",\"M\") \n#วิธีการสอนของครู\nmethod <- c(\"LEC\",\"LEC\",\"LEC\",\"PBL\",\"PBL\",\"PBL\") \n# คะแนนสอบวิชา Eng\neng <- c(6, 5.5, 7, 7, 8, 8.5)\n\nmydat<-data.frame(gender, method, eng)\nmydat\n\n  gender method eng\n1      M    LEC 6.0\n2      M    LEC 5.5\n3      F    LEC 7.0\n4      F    PBL 7.0\n5      F    PBL 8.0\n6      M    PBL 8.5\n\n\nชุดคำสั่งข้างต้นเป็นการสร้างชุดข้อมูลแบบ data.frame ในโปรแกรม R ด้วยฟังก์ชัน data.frame() โดยเก็บชุดข้อมูลดังกล่าวเอาไว้ในตัวแปรชื่อ mydat การเขียนชุดข้อมูลนี้ออกไปบนเครื่องคอมพิวเตอร์เพื่อเก็บเป็นไฟล์ข้อมูลประเภท TSV สามารถดำเนินการได้ด้วยฟังก์ชัน write.table() ดังนี้\n\nwrite.table(mydat, file=\"mytsvfromR.txt\", sep=\" \")\n\nรูปต่อไปนี้แสดงลักษณะของไฟล์ข้อมูล mstsvformR.txt ที่เขียนด้วยฟังก์ชัน write.table() ในข้างต้น จากรูปไฟล์ข้อมูลดังกล่าวเปิดด้วยโปรแกรม text editor\n\n\n\nไฟล์ข้อมูล mytsvfromR.txt\n\n\n\n\nภาษา Python\nสำหรับภาษา Python การนำเข้าและเขียนไฟล์ TSV รวมทั้ง flat file แบบอื่น ๆ สามารถทำได้ด้วยฟังก์ชัน pd.read_csv() โดยเปลี่ยนค่าของพารามิเตอร์ sep ให้ตรงกับตัวคั่นที่ใช้ในไฟล์ข้อมูล ยกตัวอย่างเช่น หากต้องการนำเข้าชุดข้อมูล myTSV.txt สามารถดำเนินการได้ดังนี้\n\ndat_TSV = pd.read_csv(\"myTSV.txt\",\n                      header = 0, sep = \" \")\ndat_TSV\n\n   Unnamed: 0  students  calculus  statistics  math\n0           0         1        80          75    70\n1           1         2        40          55    60\n2           2         3        84          85    86\n3           3         4        51          38    43\n4           4         5        67          73    77\n\n\nในทำนองเดียวกันการเขียนไฟล์แบบ TSV ในภาษา Python สามารถทำได้ด้วยฟังก์ชัน data.to_csv() เหมือนกับที่ใช้เขียนไฟล์ CSV โดยเปลี่ยนตัวคั่นให้ตรงกับลักษณะไฟล์ที่ต้องการเขียนออกไปเก็บไว้บนคอมพิวเตอร์ ตัวอย่างต่อไปนี้แสดงการเขียนชุดข้อมูล dat_TSV ในตัวอย่างที่แล้วออกไปเป็นไฟล์ TSV บนเครื่องคอมพิวเตอร์\n\ndat_TSV.to_csv(\"Dataframe_to_TSV_python.txt\", sep=\" \")"
  },
  {
    "objectID": "import.html#เรองท-4.1.3-การนำเขาและเขยนขอมลประเภท-spreadsheet",
    "href": "import.html#เรองท-4.1.3-การนำเขาและเขยนขอมลประเภท-spreadsheet",
    "title": "ตอนที่ 4.1 การนำเข้าและเขียนชุดข้อมูล (importing and writing data)",
    "section": "เรื่องที่ 4.1.3 การนำเข้าและเขียนข้อมูลประเภท spreadsheet",
    "text": "เรื่องที่ 4.1.3 การนำเข้าและเขียนข้อมูลประเภท spreadsheet\nไฟล์ข้อมูลประเภท spreadsheet เป็นไฟล์ที่มีการจัดเก็บข้อมูลในรูปแบบตารางซึ่งเป็นรูปแบบไฟล์ที่นิยมใช้ในโปรแกรมสำเร็จรูปสำหรับการคำนวณและจัดการข้อมูล เช่น Microsoft Excel, Number หรือ googlesheet หัวข้อนี้จะกล่าวถึงวิธีการนำเข้าและเขียนไฟล์ข้อมูลประเภทดังกล่าวรายละเอียดมีดังนี้\n\nการนำเข้าและเขียนไฟล์ข้อมูล .xlsx\nไฟล์ข้อมูล .xlsx เป็นไฟล์ข้อมูลของโปรแกรม Microsoft Excel (MS Excel) พื้นที่ภายในไฟล์ดังกล่าวเรียกว่า workbook โดยภายในแต่ละ workbook ประกอบด้วย worksheet ที่เป็นพื้นที่สำหรับจัดการข้อมูลและการคำนวณ worksheet ดังกล่าวมีลักษณะเป็นตาราง โดยภายในหนึ่ง workbook สามารถมีได้หลาย worksheet รูปต่อไปนี้แสดงตัวอย่าง workbook ของโปรแกรม MS Excel\n\nภาษา R\nการนำเข้าไฟล์ข้อมูล .xlsx ในโปรแกรม R สามารถทำได้หลายวิธีการ วิธีการหนึ่งคือการใช้ฟังก์ชัน read_excel() ภายใต้ package-readxl ทั้งนี้ก่อนใช้งานฟังก์ชันดังกล่าวผู้วิเคราะห์ต้องดาวน์โหลดและติดตั้ง package ดังกล่าวโดยพิมพ์คำสั่งต่อไปนี้\n\ninstall.packages(\"readxl\")\nlibrary(readxl)\n\n\n\n\nไฟล์ข้อมูล IQ.xlsx เป็นไฟล์ .xlsx ที่บันทึกข้อมูลคะแนนเชาว์ปัญญา (iq) ของนักเรียนจำแนกตามจังหวัด เพศ และอายุ เมื่อผู้วิเคราะห์ดาวน์โหลดไฟล์ข้อมูลดังกล่าวลงในคอมพิวเตอร์แล้ว สามารถนำเข้าไฟล์ข้อมูล IQ.xlsx ได้โดยพิมพ์คำสั่งดังนี้\n\n\n\n\niq <- read_excel(\"iq.xlsx\")\niq\n\n# A tibble: 12 × 4\n      id `จังหวัด` gender.age    IQ\n   <dbl> <chr>   <chr>      <dbl>\n 1     1 กรุงเทพฯ ชาย/14        80\n 2     2 กรุงเทพฯ ชาย/24       101\n 3     3 กรุงเทพฯ ชาย/25       105\n 4     4 กรุงเทพฯ หญิง/54        99\n 5     5 กรุงเทพฯ ชาย/18       100\n 6     6 กรุงเทพฯ หญิง/65       105\n 7     7 เชียงใหม่ ชาย/14        90\n 8     8 เชียงใหม่ หญิง/15       110\n 9     9 เชียงใหม่ ชาย/37       103\n10    10 เชียงใหม่ หญิง/28       108\n11    11 เชียงใหม่ ชาย/44        98\n12    12 เชียงใหม่ หญิง/34       106\n\n\nเนื่องจากภายในไฟล์ .xlsx อาจมี worksheet ได้มากกว่าหนึ่ง worksheet ในกรณีดังกล่าวการนำเข้าไฟล์ข้อมูลจึงต้องระบุเพิ่มเติมด้วยว่าผู้วิเคราะห์จะเลือกเอา worksheet ตัวไหนเข้าสู่ R พิจารณาไฟล์ข้อมูล Score.xlsx (สิวะโชติ ศรีสุทธิยากร, 2564) เมื่อดาวน์โหลดและเปิดไฟล์ข้อมูลนี้ในโปรแกรม MS Excel ผู้อ่านจะเห็นว่าไฟล์ข้อมูลดังกล่าวประกอบด้วย worksheet จำนวน 2 worksheet ได้แก่ “Score” และ “Score3” ในกรณีที่ผู้วิเคราะห์ใช้โปรแกรม R เป็นหลักสามารถเรียกดู worksheet ต่าง ๆ ในไฟล์ .xlsx ได้โดยใช้ฟังก์ชัน excel_sheets() ของ package readxl เช่นเดียวกัน ดังตัวอย่างต่อไปนี้\n\nexcel_sheets(\"Score.xlsx\")\n\n[1] \"Score\"  \"Score3\"\n\n\nจากไฟล์ข้อมูล Score.xlsx ข้างต้น หากผู้วิเคราะห์ต้องการนำเข้า worksheet “Score3” สามารถดำเนินการได้โดยใช้ฟังก์ชัน read_excel() เหมือนเดิม แต่จะต้องมีกำหนดอาร์กิวเมนท์ sheet เพื่อระบุว่าต้องการนำเข้า worksheet ใดของไฟล์ข้อมูล การระบุอาร์กิวเมนท์ sheet ดังกล่าวสามารถทำได้สองลักษณะ ลักษณะแรกคือการระบุเป็นชื่อของ worksheet โดยตรงในกรณีนี้คือ sheet = \"Score3\" และลักษณะที่สองระบุด้วยลำดับของ worksheet โดยในกรณีที่ต้องการ worksheet “Score3” ให้กำหนดเป็น sheet = 2 ตัวอย่างต่อไปนี้แสดงการนำเข้าชุดข้อมูลใน worksheet “Score3” จากไฟล์ข้อมูล Score.xlsx ดังกล่าว\n\nscore3 <- read_excel(\"Score.xlsx\", sheet = \"Score3\")\nhead(score3)\n\n# A tibble: 6 × 5\n  M     `2.7`   `9`   `4` `17.600000000000001`\n  <chr> <dbl> <dbl> <dbl>                <dbl>\n1 F       2.9    22   3.2                 23  \n2 M       3.3    12   4                   13.7\n3 M       4.2    16   4.8                 18  \n4 M       4.4    23   4.5                 14.9\n5 F       4.7    20   5.2                 25.8\n6 F       5.4    17   2.7                 13.8\n\n\nหมายเหตุ : ตัวอย่างข้างต้นมีการใช้ฟังก์ชัน head() กับชุดข้อมูล score3 ฟังก์ชันดังกล่าวมีหน้าที่กำหนดการแสดงผลของโปรแกรม R โดยจะแสดงชุดข้อมูล score เพียง 6 ค่าแรก ทั้งนี้เพื่อลดความวุ่นวายในหน้าต่างแสดงผล รายละเอียดของฟังก์ชัน head() นี้จะกล่าวถึงอีกครั้งหนึ่งในภายหลัง\nจากผลลัพธ์ที่ได้ในตัวอย่างที่ผ่านมาผู้อ่านจะเห็นว่า การนำเข้าข้อมูลดังกล่าวยังไม่ถูกต้อง ทั้งนี้เป็นเพราะหากกลับไปดูที่ไฟล์ข้อมูลต้นฉบับผู้อ่านจะพบว่าชุดข้อมูลใน worksheet “Score3” ไม่ได้มีการกำหนดชื่อของคอลัมน์ไว้ เมื่อนำเข้าด้วยฟังก์ชัน read_excel() ดังในตัวอย่าง โปรแกรมจะนำข้อมูลในแถวแรกไปเป็นชื่อคอลัมน์โดยอัตโนมัติ ในกรณีเช่นนี้ผู้วิเคราะห์สามารถกำหนดอาร์กิวเมนท์ col_names เพิ่มเติม ค่าเริ่มต้นของฟังก์ชัน read_excel() กำหนดให้ col_names = TRUE ซึ่งหมายถึงฟังก์ชันจะกำหนดให้แถวแรกของชุดข้อมูลเป็นชื่อของตัวแปร ในทางกลับกันหากกำหนดให้ col_names = FALSE ฟังก์ชันจะ generate ชื่อของคอลัมน์ขึ้นมาต่างหาก ดังตัวอย่างต่อไปนี้\n\nscore3 <- read_excel(\"Score.xlsx\", sheet = \"Score3\", col_names = FALSE)\n\nNew names:\n• `` -> `...1`\n• `` -> `...2`\n• `` -> `...3`\n• `` -> `...4`\n• `` -> `...5`\n\nhead(score3)\n\n# A tibble: 6 × 5\n  ...1   ...2  ...3  ...4  ...5\n  <chr> <dbl> <dbl> <dbl> <dbl>\n1 M       2.7     9   4    17.6\n2 F       2.9    22   3.2  23  \n3 M       3.3    12   4    13.7\n4 M       4.2    16   4.8  18  \n5 M       4.4    23   4.5  14.9\n6 F       4.7    20   5.2  25.8\n\n\nจากผลลัพธ์ข้างต้นจะเห็นว่า เมื่อกำหนดให้ col_names = FALSE ฟังก์ชัน read_excel() จะสร้างชื่อของแต่ละคอลัมน์ขึ้นมาให้เป็น …1, …2, …, .…5 ตามลำดับ ในกรณีที่ผู้วิเคราะห์ต้องการกำหนดชื่อของคอลัมน์เองสามารถกำหนดผ่านอาร์กิวเมนท์ col_names ดังกล่าวได้เลย โดยกำหนดในลักษณะเวกเตอร์ตัวอักษร (character vector) เช่นต้องการกำหนดให้คอลัมน์ทั้ง 5 ใน worksheet “Score3” เป็น gender, attitude_pre, problem_solving, attitude_post, ach_score สามารถเขียนคำสั่งได้ดังนี้\n\nscore3 <- read_excel(\"Score.xlsx\", sheet = \"Score3\", \n                     col_names = c(\"gender\", \"attitude_pre\", \n                                   \"problem_solving\", \"attitude_post\", \n                                   \"ach_score\"))\nscore3\n\n# A tibble: 20 × 5\n   gender attitude_pre problem_solving attitude_post ach_score\n   <chr>         <dbl>           <dbl>         <dbl>     <dbl>\n 1 M               2.7               9           4        17.6\n 2 F               2.9              22           3.2      23  \n 3 M               3.3              12           4        13.7\n 4 M               4.2              16           4.8      18  \n 5 M               4.4              23           4.5      14.9\n 6 F               4.7              20           5.2      25.8\n 7 F               5.4              17           2.7      13.8\n 8 M               5.8              22           3.7      17.6\n 9 F               6                20           5        23.3\n10 M               6                22           3.7      20.9\n11 F               6.1              20           5.6      21.2\n12 F               6.5              21           5.2      18.5\n13 F               6.6              22           6.2      29.6\n14 F               6.6              21           6.9      15.9\n15 F               6.7              25           7.1      24.6\n16 M               6.7              20           4.8      15.8\n17 M               7                24           6.4      29  \n18 M               7.8              24           6.7      29.3\n19 F               8.9              28           8        28.2\n20 F               9.1              28           5.4      28.6\n\n\nการเขียนไฟล์ข้อมูล .xlsx บน working directory ของ R สามารถทำได้หลายวิธีการ วิธีการหนึ่งคือการใช้ฟังก์ชัน write.xlsx() ของ package xlsx ในทำนองเดียวกับการใช้ฟังก์ชัน read_excel() ผู้วิเคราะห์จำเป็นต้องดาวน์โหลดและติดตั้ง package ดังกล่าวก่อนที่จะใช้งาน\n\ninstall.packages(\"xlsx\")\nlibrary(xlsx)\n\n\n\n\nจากชุดข้อมูล dat_TSV ในหัวข้อ 4.1.2\n\ndat_TSV\n\n  X students calculus statistics math\n1 0        1       80         75   70\n2 1        2       40         55   60\n3 2        3       84         85   86\n4 3        4       51         38   43\n5 4        5       67         73   77\n\n\nสามารถเขียนชุดข้อมูลดังกล่าวเป็นไฟล์ .xlsx บน working directory ของ R ได้โดยพิมพ์คำสั่งต่อไปนี้\n\nwrite.xlsx(dat_TSV, file=\"dat_TSV.xlsx\")\n\nรูปต่อไปนี้แสดงไฟล์ dat_TSV.xlsx ที่เขียนด้วยฟังก์ชัน write.xlsx() ในข้างต้น\n\n\n\nภาษา Python\nในทำนองเดียวกับ R ผู้วิเคราะห์สามารถเรียกดูชื่อของ worksheet ในไฟล์ .xlsx ได้ ซึ่งสามารถทำได้หลายวิธีการ วิธีการหนึ่งคือการใช้ฟังก์ชัน ExcelFile() ของ library pandas ดังนี้\n\nsheets = pd.ExcelFile(\"Score.xlsx\")\nsheets.sheet_names\n\n['Score', 'Score3']\n\n\nผลลัพธ์ข้างต้นแสดงให้เห็นว่าในไฟล์ Score.xlsx มี worksheet จำนวน 2 worksheet ได้แก่ Scoore และ Score3 สมมุติว่าผู้วิเคราะห์ต้องการนำเข้าชุดข้อมูลใน worksheet Score สามารถเขียนคำสั่งเพิ่มได้ดังนี้\n\nscore = sheets.parse(sheet_name = \"Score\")\nscore\n\n   id gender  MathScore  EngScore\n0   1      M         33        80\n1   2      M         57        20\n2   3      F         76        80\n3   4      M         80        85\n4   5      F         92        95\n\n\nฟังก์ชัน parse() ที่ใช้นำเข้าข้อมูลข้างต้นมีพารามิเตอร์ที่สามารถใช้ควบคุมการทำงานอยู่หลายตัว จากตัวอย่างข้างต้นจะเห็นว่ามีพารามิเตอร์ sheet_name ที่ใช้สำหรับระบุ worksheet ที่ไฟล์ .xlsx ที่ต้องการนำเข้า นอกจากนี้ยังมีพารามิเตอร์ header ที่ใช้ระบุแถวของชื่อตัวแปรในแต่ละคอลัมน์ ค่าเริ่มต้นของพารามิเตอร์นี้คือ header = 0 ซึ่งหมายความว่ากำหนดให้แถวแรกของชุดข้อมูลเป็นชื่อของตัวแปร นอกจากนี้ยังสามารถกำหนดชื่อของตัวแปรในแต่ละคอลัมน์ได้ผ่านพารามิเตอร์ names โดยกำหนดให้รูปแบบของ list ที่สมาชิกแต่ละตัวแปร string เป็นต้น\nอีกวิธีการหนึ่งที่สามารถใช้เพื่อนำเข้าไฟล์ .xlsx ใน Python ได้คือการใช้ฟังก์ชัน read_excel() ใน library pandas ฟังก์ชันนี้มีพารามิเตอร์สำคัญคือ io ที่ใช้ระบุชื่อหรือที่อยู่ (url) ของไฟล์ .xlsx ที่ต้องการนำเข้าสู่ Python นอกจากนี้ยังมีพารามิเตอร์ sheet_name, header, names และพารามิเตอร์อื่น ๆ ที่เหมือนกับฟังก์ชัน parse()ในตัวอย่างข้างต้น รายละเอียดของพารามิเตอร์ต่าง ๆ ผู้อ่านสามารถศึกษาเพิ่มเติมได้จาก https://pandas.pydata.org/docs/reference/api/pandas.read_excel.html\nตัวอย่างต่อไปนี้แสดงการนำเข้าชุดข้อมูลจาก worksheet Score3 ในไฟล์ Score.xlsx โดยใช้ฟังก์ชัน read_excel() ดังกล่าว เนื่องจากชุดข้อมูลใน worksheet นี้ไม่ได้มีการกำหนดชื่อของตัวแปรเอาไว้ในแถวแรกของชุดข้อมูล จึงมีการกำหนดพารามิเตอร์ header = None และกำหนดชื่อของตัวแปรในแต่ละคอลัมน์ของชุดข้อมูลผ่านพารามิเตอร์ names นอกจากนี้ เนื่องจากชุดข้อมูลใน worksheet Score3 มีจำนวนค่อนข้างมาก จากตัวอย่างข้างต้นจึงมีการใช้ฟังก์ชัน head() เพื่อควบคุมจำนวนข้อมูลที่จะนำเสนอใน printout\n\nscore3 = pd.read_excel(\"Score.xlsx\",\n                        sheet_name = \"Score3\",\n                        header = None,\n                        names = ['gender','att_pre','prob_sov', 'att_post','ach'])\nscore3.head(10)\n\n  gender  att_pre  prob_sov  att_post   ach\n0      M      2.7         9       4.0  17.6\n1      F      2.9        22       3.2  23.0\n2      M      3.3        12       4.0  13.7\n3      M      4.2        16       4.8  18.0\n4      M      4.4        23       4.5  14.9\n5      F      4.7        20       5.2  25.8\n6      F      5.4        17       2.7  13.8\n7      M      5.8        22       3.7  17.6\n8      F      6.0        20       5.0  23.3\n9      M      6.0        22       3.7  20.9\n\n\nการเขียนชุดข้อมูลใน Python ออกไปเป็นไฟล์ .xlsx สามารถทำได้โดยใช้ฟังก์ชัน to_excel() ซึ่งมีการใช้งานที่คล้ายกับกับฟังก์ชัน to_csv() อย่างไรก็ตามเนื่องจากไฟล์ .xlsx มีโครงสร้างการเก็บข้อมูลที่ซับซ้อนกว่าไฟล์ CSV หรือ flatfile อื่น ๆ ฟังก์ชันดังกล่าวจึงมีพารามิเตอร์เฉพาะสำหรับการเขียนไฟล์ .xlsx ด้วย ฟังก์ชัน to_excel() มีพารามิเตอร์ที่สำคัญได้แก่ (1) พารามิเตอร์ excel_writer ใช้ระบุที่อยู่และชื่อไฟล์ .xlsx ที่ต้องการเขียนออกไป (2) พารามิเตอร์ sheet_name ใช้กำหนดชื่อของ worksheet ภายในไฟล์ .xlsx ที่ต้องการเขียนออกไป (3) พารามิเตอร์ na_rep ใช้สำหรับระบุสัญลักษณะของข้อมูลสูญหาย (missing value representation) (4) พารามิเตอร์ startrow และ startcol ใช้สำหรับกำหนดขอบเขตของข้อมูลที่ต้องการเขียนออกไปในไฟล์ .xlsx นอกจากนี้ยังมีพารามิเตอร์อื่น ๆ อีกหลายตัว โดยผู้อ่านสามารถศึกษาได้จาก https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.to_excel.html\nตัวอย่างต่อไปนี้แสดงการใช้ฟังก์ชัน to_excel() เพื่อเขียนไฟล์ข้อมูลตัวอย่าง exam_dat ออกไปเป็นไฟล์ exam_dat.xlsx\n\n#เพศของนักเรียน\ngender = [\"M\",\"M\",\"F\",\"F\",\"F\",\"M\"]\n#วิธีการสอนของครู\nmethod = [\"LEC\",\"LEC\",\"LEC\",\"PBL\",\"PBL\",\"PBL\"]\n# คะแนนสอบวิชา Eng\neng = [6, 5.5, 7, 7, 8, 8.5]\n\ndat = {'gender': gender,\n      'method': method,\n      'eng': eng}\n\nexam_dat = pd.DataFrame(dat)\nexam_dat\n\n  gender method  eng\n0      M    LEC  6.0\n1      M    LEC  5.5\n2      F    LEC  7.0\n3      F    PBL  7.0\n4      F    PBL  8.0\n5      M    PBL  8.5\n\n\nการเขียนชุดข้อมูล exam_dat ออกไปเป็นไฟล์ exam_dat.xlsx สามารถเขียนคำสั่งได้ดังนี้\n\nexam_dat.to_excel(excel_writer = 'exam_dat.xlsx' , sheet_name=\"exam_dat\")\n\nรูปต่อไปนี้แสดงไฟล์ exam_dat.xlsx ที่เขียนด้วยฟังก์ชัน to_excel() ในข้างต้น"
  },
  {
    "objectID": "import.html#เรองท-4.1.2-การนำเขาและเขยนขอมลประเภท-flat-files",
    "href": "import.html#เรองท-4.1.2-การนำเขาและเขยนขอมลประเภท-flat-files",
    "title": "ตอนที่ 4.1 การนำเข้าและเขียนชุดข้อมูล (importing and writing data)",
    "section": "เรื่องที่ 4.1.2 การนำเข้าและเขียนข้อมูลประเภท flat files",
    "text": "เรื่องที่ 4.1.2 การนำเข้าและเขียนข้อมูลประเภท flat files\nflat files เป็นไฟล์ข้อมูลที่อยู่ในรูปแบบข้อความ (plain text) และชุดข้อมูลไม่ได้มีโครงสร้างการจัดเก็บในรูปแบบตารางหรือ spreadsheet แต่ flat file จะมีการใช้ตัวอักษรพิเศษ เช่น comma (,), slash (/) หรือ underscore (_) เป็นตัวคั่น (separator or delimiter) เพื่อจำแนกข้อมูลที่แตกต่างกันออกจากกัน รูป 4.1 แสดงลักษณะของชุดข้อมูลแบบ flat file ที่มีการใช้ตัวคั่นแบบ comma (,) และแบบเว้นวรรค (tab) จากรูปจะเห็นว่าตัวอย่างของไฟล์ข้อมูลทั้งสองมีโครงสร้างการจัดเก็บข้อมูลที่เหมือนกันกล่าวคือ ในแถวแรกของไฟล์ข้อมูลเป็นที่จัดเก็บชื่อของตัวแปรภายในชุดข้อมูล และตั้งแต่แถวที่สองเป็นต้นไปเป็นที่จัดเก็บข้อมูลของตัวแปรต่าง ๆ ของแต่ละหน่วยข้อมูล อย่างไรก็ตามในทางปฏิบัติแถวแรกของไฟล์ข้อมูลไม่จำเป็นจะต้องเป็นชื่อของตัวแปรเสมอไป\n\n\n\nรูป 4.1 ตัวอย่างโครงสร้างของ flat file แบบ CSV และ TSV\n\n\nที่มา : สิวะโชติ ศรีสุทธิยากร (2564)\nflat file ยังมีการเรียกชื่อที่เฉพาะตามลักษณะของตัวคั่นที่ใช้ในชุดข้อมูล จากรูปจะเห็นว่าชุดข้อมูลด้านบนมีการใช้ comma (,) เป็นตัวคั่น จะเรียกไฟล์ข้อมูลประเภทนี้ว่า comma separated values (CSV) หรืออาจเรียกว่า comma-delimited ก็ได้ ส่วนชุดข้อมูลด้านล่างของรูปมีการใช้ตัวคั่นเป็นการเว้นวรรค (tab) จะเรียกชุดข้อมูลประเภทนี้ว่า tab separated values (TSV) หรือ tab-delimited\n\nการนำเข้าและเขียนไฟล์แบบ CSV\nหัวข้อนี้จะกล่าวถึงวิธีการนำเข้าและเขียนไฟล์ข้อมูลแบบ CSV โดยจำแนกเนื้อหาออกเป็นสองส่วนได้แก่ ส่วนของภาษา R และ ภาษา Python รายละเอียดมีดังนี้\n\nภาษา R\nภาษา R สามารถนำเข้าและเขียนไฟล์ CSV ได้หลายวิธี วิธีการแรกเป็นการนำเข้าด้วยฟังก์ชันจาก package-utils ที่เป็น package พื้นฐานของ R ได้แก่ฟังก์ชัน read.csv() ที่มีอาร์กิวเมนท์สำคัญได้แก่ file ใช้ระบุที่อยู่และชื่อของไฟล์ข้อมูลแบบ CSV ที่ต้องการนำเข้าอาร์กิวเมนท์นี้ผู้วิเคราะห์จำเป็นต้องกำหนดแบบตัวแปรตัวอักษร (กล่าวคือต้องระบุไว้ภายใต้เครื่องหมาย quotation) อาร์กิวเมนท์ header ใช้ระบุว่าไฟล์ข้อมูลที่นำเข้ามีแถวแรกของไฟล์เป็นชื่อของตัวแปรหรือไม่ การกำหนดอาร์กิวเมนท์นี้กำหนดเป็นค่าความจริงได้แก่ TRUE หรือ FALSE โดยหากกำหนดเป็น TRUE (ค่าเริ่มต้น) จะหมายถึงการระบุว่าใช้แถวแรกของไฟล์ข้อมูลเป็นชื่อของตัวแปรในแต่ละคอลัมน์ ในกรณีที่กำหนดเป็น FALSE ฟังก์ชัน CSV จะกำหนดชื่อของคอลัมน์ให้โดยอัตโนมัติ ตัวอย่างด้านล่างแสดงการนำเข้าชุดข้อมูล gapminder_mini.csv\n\n# R syntax\ndat <- read.csv(\"gapminder_mini.csv\", header = TRUE)\nstr(dat)\n\n\n\n'data.frame':   142 obs. of  4 variables:\n $ X        : int  1 2 3 4 5 6 7 8 9 10 ...\n $ country  : chr  \"Afghanistan\" \"Albania\" \"Algeria\" \"Angola\" ...\n $ gdpPercap: num  975 5937 6223 4797 12779 ...\n $ lifeExp  : num  43.8 76.4 72.3 42.7 75.3 ...\n\n\nอาร์กิวเมนท์อีกตัวที่สำคัญของฟังก์ชัน read.csv() คืออาร์กิวเมนท์ na.strings ใช้ในกรณีที่ชุดข้อมูลที่ต้องการนำเข้ามีค่าสูญหาย การระบุอาร์กิวเมนท์ดังกล่าวให้ระบุเป็นสัญลักษณ์ที่ใช้แทนค่าสูญหายของชุดข้อมูลที่ต้องการนำเข้า เช่น หากชุดข้อมูลที่นำเข้าใช้สัญลักษณ์ -999 แทนค่าสูญหายให้กำหนด na.strings = -999 เป็นต้น นอกจากนี้ฟังก์ชัน read.csv() ยังมีอาร์กิวเมนท์ stringsAsFactors ที่กำหนดค่าเป็น TRUE หรือ FALSE เพื่อแปลงคอลัมน์ตัวอักษรในชุดข้อมูลให้เป็นตัวแปรแบบ factor ซึ่งเป็นตัวแปรแบบจัดประเภทของ R ผู้อ่านสามารถศึกษารายละเอียดเพิ่มเติมได้จาก สิวะโชติ ศรีสุทธิยากร (2564) หน้า 40\nตัวอย่างข้างต้นมีการใช้ฟังก์ชัน str() เพื่อเรียกดูข้อมูลเบื้องต้นของชุดข้อมูล gapminder_mini.csv ที่นำเข้ามาด้วยฟังก์ชัน read.csv() ในข้างต้น ฟังก์ชันดังกล่าวจะรายงานมิติหรือขนาดของชุดข้อมูล ชื่อของตัวแปรในแต่ละคอลัมนท์ รวมทั้งคุณลักษณะของตัวแปรภายในแต่ละคอลัมน์ สำหรับผู้ที่เคยใช้ SPSS จะพอเทียบเคียงได้ว่าผลลัพธ์จากฟังก์ชัน str() นี้จะให้สารสนเทศในทำนองเดียวกับหน้าต่าง variable view ของโปรแกรม SPSS รายละเอียดของฟังก์ชันนี้จะกล่าวอีกครั้งหนึ่งในหัวข้อ 4.2\nภาษา R ยังมีความสามารถในการเขียนไฟล์ชุดข้อมูลเพื่อส่งออกไปบันทึกในคอมพิวเตอร์สำหรับนำไปใช้ในวัตถุประสงค์ต่าง ๆ การเขียนไฟล์แบบ CSV สามารถทำได้หลายวิธีการเช่นกัน วิธีการพื้นฐานคือการใช้ฟังก์ชัน write.csv() ที่มีอาร์กิวเมนท์สำคัญ 2 ตัวได้แก่ x คือชุดข้อมูลแบบ Dataframe ที่ต้องการเขียนออกไปเป็นไฟล์แบบ CSV และ file ใช้ระบุที่อยู่และชื่อของไฟล์ปลายทางที่จะให้ R เขียนออกไปบันทึกในคอมพิวเตอร์ ทั้งนี้รูปแบบของชื่อไฟล์ต้องเขียนในลักษณะตัวอักษรกล่าวคืออยู่ภายใต้เครื่องหมาย quotation และมีนามสกุลของไฟล์เป็นแบบ `*.csv` ดังตัวอย่างด้านล่าง\n\n# R syntax\nwrite.csv(dat, file=\"Desktop/mydata.csv\")\n\nคำสั่งด้านบนจะเขียนไฟล์ my.data.csv ไว้บน Desktop ของเครื่องคอมพิวเตอร์ ในกรณีที่ผู้วิเคราะห์กำหนดแค่ชื่อไฟล์ปลายทางแต่ไม่ได้กำหนดที่อยู่ของไฟล์ เช่น write.csv(dat, file=\"mydata.csv\") ไฟล์ที่สร้างขึ้นจะบันทึกไว้ใน folder เป็นค่าเริ่มต้นหรือ folder ที่กำหนดเป็น working directory เอาไว้ การกำหนด working directory สามารถทำได้โดยใช้ฟังก์ชัน setwd() โดยภายในฟังก์ชันให้ใส่ที่อยู่ของ folder ที่ต้องการกำหนดให้เป็น working directory ในลักษณะตัวอักษร เช่น setwd(\"/Desktop/myjob\") หมายถึงกำหนดให้ working directory เป็น folder myjob ที่อยู่บน Desktop ของเครื่องคอมพิวเตอร์ รายละเอียดอื่น ๆ เกี่ยวกับการกำหนด working directory ใน R สามารถศึกษาเพิ่มเติมได้จาก สิวะโชติ ศรีสุทธิยากร (2564)\nรูปด้านล่างแสดงลักษณะของไฟล์ข้อมูล mydata.csv ที่เขียนออกจากโปรแกรม R ด้วยคำสั่งในข้างต้น จากรูปใช้โปรแกรม text editor เพื่อเปิดไฟล์ดังกล่าว\n\n\n\nไฟล์ข้อมูล myCSV.csv\n\n\nโดยปกติแล้ว MS Excel หรือ Number หรือ googlesheet มีตัวอ่านไฟล์ข้อมูลประเภท flatfile อยู่แล้วผู้อ่านสามารถใช้โปรแกรมดังกล่าวเพื่อเปิดไฟล์ข้อมูลประเภท CSV หรือ flatfile ประเภทอื่น ๆ ได้โดยง่าย\n\n\nภาษา Python\nสำหรับการนำเข้าและเขียนไฟล์ข้อมูลแบบ CSV ด้วยภาษา Python สามารถทำได้โดยใช้ฟังก์ชัน pd.read_csv() ของ pandas library ฟังก์ชันนี้มีพารามิเตอร์ได้แก่ filepath ใช้กำหนดที่อยู่และชื่อของไฟล์ที่ต้องการนำเข้า พารามิเตอร์ sep สำหรับระบุตัวอักษรที่ใช้เป็นตัวคั่นในชุดข้อมูล ซึ่งในกรณีนี้จะกำหนดให้ sep=\",\" เพื่อนำเข้าชุดข้อมูลแบบ CSV พารามิเตอร์ header สำหรับระบุว่าแถวที่เท่าไหร่ในตารางข้อมูลจะใช้เป็นชื่อของตัวแปร (เริ่มจาก 0) พารามิเตอร์ skiprows ใช้กำหนดให้ Python อ่านไฟล์ข้อมูลโดยข้ามแถวไปจำนวนเท่ากับที่กำหนด พารามิเตอร์นี้มีประโยชน์มากสำหรับการนำเข้าไฟล์ข้อมูลจากองค์กร หรือ logfile ที่หัวของตารางมักมีคำอธิบายหรือ caption ต่าง ๆ ก่อนที่จะเป็นส่วนของตารางข้อมูล ฟังก์ชัน pd.read_csv() ยังมีพารามิเตอร์อีกหลายตัว (optional parameters) ที่สามารถกำหนดเพื่อปรับแต่งลักษณะของข้อมูลที่นำเข้ามาได้ รายละเอียดอื่น ๆ ผู้อ่านสามารถศึกษาเพิ่มเติมได้จาก https://pandas.pydata.org/docs/reference/api/pandas.read_csv.html\n\n# Python syntax\nimport pandas as pd\ndat = pd.read_csv(\"/Users/siwachoat/Downloads/gapminder.csv\", header=0)\ndat\n\n     Unnamed: 0             country     gdpPercap  lifeExp\n0             1         Afghanistan    974.580338   43.828\n1             2             Albania   5937.029526   76.423\n2             3             Algeria   6223.367465   72.301\n3             4              Angola   4797.231267   42.731\n4             5           Argentina  12779.379640   75.320\n..          ...                 ...           ...      ...\n137         138             Vietnam   2441.576404   74.249\n138         139  West Bank and Gaza   3025.349798   73.422\n139         140         Yemen, Rep.   2280.769906   62.698\n140         141              Zambia   1271.211593   42.384\n141         142            Zimbabwe    469.709298   43.487\n\n[142 rows x 4 columns]\n\n\nการเขียนไฟล์ CSV ด้วยภาษา Python สามารถทำได้หลายวิธี วิธีการหนึ่งคือการใช้ method to_csv() ซึ่งเป็น method หนึ่งภายใต้ pandas library พารามิเตอร์สำคัญของ method นี้ได้แก่ ตัวอย่างด้านล่างแสดงการเขียนไฟล์ข้อมูลใน Python เพื่อบันทึกลงใน folder ที่กำหนดไว้บนเครื่องคอมพิวเตอร์ สมมุติว่าผู้วิเคราะห์สร้างชุดข้อมูลใน Python เพื่อเก็บข้อมูลคะแนนสอบของนิสิตในรายวิชาแคลคูลัส (calculus) สถิติ (statistics) และคณิตศาสตร์ (math) การเขียนไฟล์ข้อมูลดังกล่าวเป็นไฟล์ CSV สามารถทำได้ดังนี้\n\nimport pandas as pd\nheader = [\"students\",\"calculus\",\"statistics\",\"math\"]\nrow_data = [[1,80,75,70],\n            [2,40,55,60],\n            [3,84,85,86],\n            [4,51,38,43],\n            [5,67,73,77]]\ndata = pd.DataFrame(row_data, columns=header)\ndata\n\n   students  calculus  statistics  math\n0         1        80          75    70\n1         2        40          55    60\n2         3        84          85    86\n3         4        51          38    43\n4         5        67          73    77\n\ndata.to_csv(\"myCSV.csv\", sep=\",\")\n\nผู้อ่านสามารถศึกษารายละเอียดของ to_csv() ได้จาก https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.to_csv.html\n\n\n\nการนำเข้าและเขียนไฟล์แบบ TSV\nดังที่กล่าวไปแล้วข้างต้น ไฟล์แบบ TSV เป็นไฟล์ข้อมูลแบบ flat file ที่มีการใช้ตัวคั่นข้อมูลเป็นเครื่องหมายเว้นวรรค (tab) การนำเข้าไฟล์ข้อมูล TSV การนำเข้าและเขียนไฟล์ลักษณะดังกล่าวของแต่ละภาษาจึงสามารถดำเนินการได้ในทำนองเดียวกับไฟล์แบบ CSV รายละเอียดมีดังนี้\n\nภาษา R\nในภาษา R สามารถทำได้โดยใช้ฟังก์ชัน read.table() โดยอาร์กิวเมนท์ของฟังก์ชันนี้มีส่วนของอาร์กิวเมนท์จำเป็นที่เหมือนกับของฟังก์ชัน read.csv() ได้แก่ file ที่ใช้ระบุที่อยู่และชื่อของไฟล์ข้อมูลที่ต้องการนำเข้า โดยจะต้องระบุในลักษณะของตัวแปรตัวอักษรใน R กล่าวคือต้องระบุภายใต้เครื่องหมาย quotation อาร์กิวเมนท์ header ที่กำหนดได้ 2 ค่าคือ TRUE และ FALSE โดยที่ค่าเริ่มต้นคือ header=FALSE ซึ่งหมายความว่าตารางข้อมูลที่จะนำเข้ามานั้นเป็นตารางที่ไม่มีหัวตาราง และอาร์กิวเมนท์ sep ใช้ระบุลักษณะของตัวคั่นข้อมูลที่ใช้ในไฟล์ข้อมูล อาร์กิวเมนท์นี้จึงทำให้ฟังก์ชัน read.table() สามารถนำเข้า flat file ได้หลายประเภทไม่ได้จำกัดแค่เฉพาะ CSV หรือ TSV เท่านั้น นอกจากนี้ยังมีอาร์กิวเมนท์ skip ที่ทำงานเหมือนกับพารามิเตอร์ skiprows ในฟังก์ชัน pd.read_csv() ของภาษา Python ฟังก์ชัน read.table() เป็นฟังก์ชันที่มีอาร์กิวเมนท์ที่สามารถกำหนดได้จำนวนมาก รายละเอียดอื่น ๆ เกี่ยวข้องผู้อ่านสามารถศึกษาได้จากคู่มือของฟังก์ชันโดยพิมพ์คำสั่ง ?read.table()\nจากที่กล่าวในข้างต้นจะเห็นว่า read.table() เป็นฟังก์ชันทั่วไปของ read.csv() ตัวอย่างต่อไปนี้แสดงให้เห็นว่าสามารถใช้ฟังก์ชัน read.table() เพื่อนำเข้าไฟล์แบบ CSV ได้\n\ndat <- read.table(\"/Users/siwachoat/Downloads/gapminder.csv\", header=TRUE, sep=\",\")\nhead(dat)\n\n  X     country  gdpPercap lifeExp\n1 1 Afghanistan   974.5803  43.828\n2 2     Albania  5937.0295  76.423\n3 3     Algeria  6223.3675  72.301\n4 4      Angola  4797.2313  42.731\n5 5   Argentina 12779.3796  75.320\n6 6   Australia 34435.3674  81.235\n\n\nชุดข้อมูล myTSV.txt เป็นชุดข้อมูลแบบ flat file ที่มีการใช้ตัวคั่นเป็นเครื่องหมายเว้นวรรค (tab) การนำชุดข้อมูลดังกล่าวเข้าสู่โปรแกรม R ด้วยฟังก์ชัน read.table() สามารถทำได้โดยกำหนดอาร์กิวเมนท์ sep = \" \" ดังตัวอย่างต่อไปนี้\n\ndat_TSV <- read.table(\"https://raw.githubusercontent.com/ssiwacho/dataset/main/myTSV.txt\",\n                      header = TRUE, sep = \" \")\ndat_TSV\n\n  X students calculus statistics math\n1 0        1       80         75   70\n2 1        2       40         55   60\n3 2        3       84         85   86\n4 3        4       51         38   43\n5 4        5       67         73   77\n\n\nในทำนองเดียวกับการนำเข้าและเขียนไฟล์ CSV การเขียนไฟล์ TSV สามารถทำได้โดยใช้ฟังก์ชัน write.table() ที่มีอาร์กิวเมนท์สำคัญเหมือนกับฟังก์ชัน write.csv() ทุกประการ ความแตกต่างระหว่าง write.table() กับ write.csv() อันหนึ่งคือฟังก์ชัน write.table() มีอาร์กิวเมนท์ sep ที่ทำให้ผู้วิเคราะห์สามารถเลือกกำหนดได้ว่าจะเขียนไฟล์ข้อมูลของตนเองโดยใช้ตัวคั่นแบบใด ตัวอย่างต่อไปนี้แสดงการเขียนไฟล์ TSV ด้วยฟังก์ชัน write.table() จากชุดข้อมูลแบบ data.frame ที่สร้างเองบนโปรแกรม R\n\n#เพศของนักเรียน\ngender <- c(\"M\",\"M\",\"F\",\"F\",\"F\",\"M\") \n#วิธีการสอนของครู\nmethod <- c(\"LEC\",\"LEC\",\"LEC\",\"PBL\",\"PBL\",\"PBL\") \n# คะแนนสอบวิชา Eng\neng <- c(6, 5.5, 7, 7, 8, 8.5)\n\nmydat<-data.frame(gender, method, eng)\nmydat\n\n  gender method eng\n1      M    LEC 6.0\n2      M    LEC 5.5\n3      F    LEC 7.0\n4      F    PBL 7.0\n5      F    PBL 8.0\n6      M    PBL 8.5\n\n\nชุดคำสั่งข้างต้นเป็นการสร้างชุดข้อมูลแบบ data.frame ในโปรแกรม R ด้วยฟังก์ชัน data.frame() โดยเก็บชุดข้อมูลดังกล่าวเอาไว้ในตัวแปรชื่อ mydat การเขียนชุดข้อมูลนี้ออกไปบนเครื่องคอมพิวเตอร์เพื่อเก็บเป็นไฟล์ข้อมูลประเภท TSV สามารถดำเนินการได้ด้วยฟังก์ชัน write.table() ดังนี้\n\nwrite.table(mydat, file=\"mytsvfromR.txt\", sep=\" \")\n\nรูปต่อไปนี้แสดงลักษณะของไฟล์ข้อมูล mstsvformR.txt ที่เขียนด้วยฟังก์ชัน write.table() ในข้างต้น จากรูปไฟล์ข้อมูลดังกล่าวเปิดด้วยโปรแกรม text editor\n\n\n\nไฟล์ข้อมูล mytsvfromR.txt\n\n\n\n\nภาษา Python\nสำหรับภาษา Python การนำเข้าและเขียนไฟล์ TSV รวมทั้ง flat file แบบอื่น ๆ สามารถทำได้ด้วยฟังก์ชัน pd.read_csv() โดยเปลี่ยนค่าของพารามิเตอร์ sep ให้ตรงกับตัวคั่นที่ใช้ในไฟล์ข้อมูล ยกตัวอย่างเช่น หากต้องการนำเข้าชุดข้อมูล myTSV.txt สามารถดำเนินการได้ดังนี้\n\ndat_TSV = pd.read_csv(\"myTSV.txt\",\n                      header = 0, sep = \" \")\ndat_TSV\n\n   Unnamed: 0  students  calculus  statistics  math\n0           0         1        80          75    70\n1           1         2        40          55    60\n2           2         3        84          85    86\n3           3         4        51          38    43\n4           4         5        67          73    77\n\n\nในทำนองเดียวกันการเขียนไฟล์แบบ TSV ในภาษา Python สามารถทำได้ด้วยฟังก์ชัน data.to_csv() เหมือนกับที่ใช้เขียนไฟล์ CSV โดยเปลี่ยนตัวคั่นให้ตรงกับลักษณะไฟล์ที่ต้องการเขียนออกไปเก็บไว้บนคอมพิวเตอร์ ตัวอย่างต่อไปนี้แสดงการเขียนชุดข้อมูล dat_TSV ในตัวอย่างที่แล้วออกไปเป็นไฟล์ TSV บนเครื่องคอมพิวเตอร์\n\ndat_TSV.to_csv(\"Dataframe_to_TSV_python.txt\", sep=\" \")"
  },
  {
    "objectID": "import.html#เรองท-4.1.4-การนำเขาและเขยนขอมลแบบ-json",
    "href": "import.html#เรองท-4.1.4-การนำเขาและเขยนขอมลแบบ-json",
    "title": "ตอนที่ 4.1 การนำเข้าและเขียนชุดข้อมูล (importing and writing data)",
    "section": "เรื่องที่ 4.1.4 การนำเข้าและเขียนข้อมูลแบบ JSON",
    "text": "เรื่องที่ 4.1.4 การนำเข้าและเขียนข้อมูลแบบ JSON\nชุดข้อมูลแบบ JSON (JavaScript Object Notation) เป็นชุดข้อมูลอีกประเภทหนึ่งที่ในปัจจุบันถูกใช้กันอย่างแพร่หลาย และมีความยืดหยุ่นในการทำงานมากกว่าชุดข้อมูลประเภท spreadsheet หรือ flat files โดยเฉพาะงานที่ต้องมีการส่งผ่าน แก้ไข หรือเพิ่มข้อมูลระหว่าง server ผ่าน Web APIs ซึ่งเป็นส่วนที่ใช้เชื่อมต่อการทำงานหรือประสานข้อมูลกันระหว่าง web server ต่าง ๆ ปัจจุบันมี Web APIs จำนวนมากที่เปิดให้ใช้งานเช่น Facebook, Line, Twitter หรือ IMDB เป็นต้น ผู้ที่ใช้ API ของ application ดังกล่าวสามารถเข้าถึงข้อมูล เช่น การโพสหรือการให้ความคิดเห็นต่าง ๆ ของผู้ใช้ ซึ่งปัจจุบันข้อมูลดังกล่าวถูกนำมาใช้เพื่อสร้างมูลค่าเพิ่มให้ข้อมูลอย่างแพร่หลาย เช่น การทำ social network, social listening หรือการทำ sentiment analysis เป็นต้น\nเพื่อให้ผู้อ่านเข้าใจเกี่ยวกับ web API มากขึ้นลองพิจารณาตัวอย่างต่อไปนี้ สมมุติว่านักวิทยาการข้อมูลต้องการเข้าถึงข้อมูลภาพยนต์เรื่อง Captain Marvel จาก website IMDB (https://www.imdb.com/title/tt4154664/)\n\n\n\nCaptain Marvel จาก IMDB\n\n\nผู้อ่านจะเห็นว่าบนหน้า website ดังกล่าวมีข้อมูลเกี่ยวกับภาพยนต์จำนวนมาก อย่างไรก็ตามหากผู้วิเคราะห์ดำเนินการดาว์โหลดข้อมูลบน website ดังกล่าวโดยตรงพบว่าจะได้ข้อมูลเป็นไฟล์นามสกุล .html เมื่อเปิดดูพบว่าไฟล์ดังกล่าวมีส่วนของชุดคำสั่งที่ใช้กำหนดรูปแบบการแสดงผลบน web browser อยู่ด้วยซึ่งไม่เกี่ยวกับข้อมูลของภาพยนต์ หากผู้วิเคราะห์จะค้นหาข้อมูลที่ดังกล่าวด้วยสายตาก็จะเป็นการเสียเวลาอย่างมาก\nรูปต่อไปนี้แสดงตัวอย่างไฟล์ captain_marvel.html ที่ดาวน์โหลดมาจาก website IMDB ข้างต้น\n\nurl<-\"https://www.imdb.com/title/tt4154664/\"\ndownload.file(url, \"captain_marvel.html\")\n\n\n\n\nส่วนหนึ่งของไฟล์ captain_marvel.html\n\n\nจากสถานการณ์ข้างต้น มีวิธีการที่ง่ายและมีประสิทธิภาพสูงกว่าในการนำเข้าข้อมูลจาก website IMDB คือการใช้ web API เช่นในกรณีนี้อาจใช้ OMDb API ผู้อ่านจะเห็นว่าข้อมูลที่ดาวน์โหลดผ่าน API ดังกล่าวนั้นเป็นชุดข้อมูลแบบ JSON ที่มีโครงสร้างที่เป็นระเบียบ และง่ายกว่าข้อมูลภายในไฟล์ .html อย่างมาก ผู้อ่านลองพิจารณาไฟล์ข้อมูลด้านล่างจะเห็นว่าข้อมูลที่นำเข้าจาก API ดังกล่าวประกอบด้วย ชื่อเรื่อง ปีที่ฉาย ความยาวของภาพยนต์​ ประเภท ผู้กำกับ ผู้เขียนบท นักแสดง ไปจนถึงรางวัล และคะแนนที่ได้รับต่าง ๆ\n\n\n\n{\"Title\":[\"Captain Marvel\"],\n\"Year\":[\"2019\"],\n\"Rated\":[\"PG-13\"],\n\"Released\":[\"08 Mar 2019\"],\n\"Runtime\":[\"123 min\"],\n\"Genre\":[\"Action, Adventure, Sci-Fi\"],\n\"Director\":[\"Anna Boden, Ryan Fleck\"],\n\"Writer\":[\"Anna Boden, Ryan Fleck, Geneva Robertson-Dworet\"],\n\"Actors\":[\"Brie Larson, Samuel L. Jackson, Ben Mendelsohn\"],\n\"Plot\":[\"Carol Danvers becomes one of the universe's most powerful heroes when Earth is caught in the middle of a galactic war between two alien races.\"],\n\"Language\":[\"English\"],\n\"Country\":[\"United States, Australia\"],\n\"Awards\":[\"9 wins & 56 nominations\"],\n\"Poster\":[\"https://m.media-amazon.com/images/M/MV5BMTE0YWFmOTMtYTU2ZS00ZTIxLWE3OTEtYTNiYzBkZjViZThiXkEyXkFqcGdeQXVyODMzMzQ4OTI@._V1_SX300.jpg\"],\n\"Ratings\":[{\"Source\":\"Internet Movie Database\",\"Value\":\"6.8/10\"},{\"Source\":\"Rotten Tomatoes\",\"Value\":\"79%\"},{\"Source\":\"Metacritic\",\"Value\":\"64/100\"}],\n\"Metascore\":[\"64\"],\n\"imdbRating\":[\"6.8\"],\n\"imdbVotes\":[\"559,100\"],\n\"imdbID\":[\"tt4154664\"],\n\"Type\":[\"movie\"],\n\"DVD\":[\"28 May 2019\"],\n\"BoxOffice\":[\"$426,829,839\"],\n\"Production\":[\"N/A\"],\n\"Website\":[\"N/A\"],\n\"Response\":[\"True\"]\n} \nจากตัวอย่างข้างต้นแสดงให้เห็นว่าเมื่อผู้วิเคราะห์ต้องไปทำงานที่เกี่ยวข้องกับข้อมูลบน website และมีการเรียกดูหรือดึงข้อมูลผ่าน web API ต่าง ๆ ผู้วิเคราะห์มักต้องทำงานร่วมกับชุดข้อมูลแบบ JSON เสมอ บทเรียนนี้จะกล่าวถึงการนำชุดข้อมูลแบบ JSON เข้าสู่ R และ Python รวมทั้งการแปลงชุดข้อมูลแบบ JSON เพื่อให้อยู่ในรูปตัวแปรมาตรฐานของภาษาทั้งสองและเหมาะที่จะนำไปดำเนินการต่อไปนี้\n\nภาษา R\nมี package หลายตัวที่สามารถทำงานร่วมกับชุดข้อมูบแบบ JSON ได้ ในบทเรียนนี้จะกล่าวถึงการใช้ package-jsonlite โดยในทำนองเดียวกับการใช้งาน package อื่น ๆ ผู้วิเคราะห์จำเป็นต้องดาวน์โหลดและติดตั้ง package ดังกล่าวก่อนการใช้งานฟังก์ชันภายใน package โดยพิมพ์คำสั่งดังนี้\n\ninstall.packages(\"jsonlite\")\nlibrary(jsonlite)\n\n\n\n\nฟังก์ชัน fromJSON() เป็นฟังก์ชันภายใต้ package-jsonlite ที่มีหน้าที่แปลงเวกเตอร์ตัวอักษร (character vector) ที่สร้างขึ้นตามโครงสร้างของ JSON ให้เป็นตัวแปรประเภทลิสท์ (list) ใน R ยกตัวอย่างเช่น ผู้วิเคราะห์มีชุดข้อมูลแบบ JSON ที่เป็น character vector ดังนี้\n\nstudent_json <- '\n{\"name\": \"บุญมี\",\n\"gender\": \"ชาย\",\n\"subject\": \"คณิตศาสตร์\",\n\"score\": 80\n}'\n\nผู้วิเคราะห์สามารถแปลง student_json ให้เป็นตัวแปรแบบ list ใน R ได้ด้วยฟังก์ชัน fromJSON() ดังนี้\n\nstudent_list <- fromJSON(student_json)\nstudent_list\n\n$name\n[1] \"บุญมี\"\n\n$gender\n[1] \"ชาย\"\n\n$subject\n[1] \"คณิตศาสตร์\"\n\n$score\n[1] 80\n\n\nในกรณีที่ JSON ที่นำเข้าเป็นไฟล์ขนาดใหญ่ ผู้วิเคราะห์สามารถเรียกดูโครงสร้างการเก็บข้อมูลของ JSON ที่บันทึกในตัวแปร list ของ R โดยใช้ฟังก์ชัน str() ภายใต้ package-utils ดังตัวอย่างต่อไปนี้ (package-utils เป็น package เริ่มต้นที่ถูกติดตั้งมาพร้อมกับ R อยู่แล้วดังนั้นจึงไม่ต้องติดตั้งและดาวน์โหลดอีก)\n\nstr(student_list)\n\nList of 4\n $ name   : chr \"บุญมี\"\n $ gender : chr \"ชาย\"\n $ subject: chr \"คณิตศาสตร์\"\n $ score  : int 80\n\n\nผลลัพธ์ข้างต้นแสดงให้เห็นว่าชุดข้อมูลประกอบด้วยข้อมูลของนักเรียน 4 ด้านได้แก่ ชื่อของนักเรียน เพศ รายวิชาที่ลงทะเบียนเรียน และคะแนนของรายวิชา ตามลำดับ\nจากตัวอย่างข้อมูลภาพยนต์เรื่อง Captain Marvel ใน website IMDB ข้างต้น ผู้วิเคราะห์สามารถนำเข้าข้อมูลของภาพยนต์โดยใช้ OMDb API (http://www.omdbapi.com/?i=tt3896198&apikey=d97bab1b) เนื่องจาก API ดังกล่าวเป็น API ที่ไม่ต้องลงทะเบียนการใช้งานและผู้ใช้สามารถขอ api key ได้โดยที่ไม่ต้องลงทะเบียน ทำให้ผู้วิเคราะห์สามารถเข้าถึงชุดข้อมูลแบบ JSON ของภาพยนต์ผ่านลิงค์ในข้างต้นได้โดยตรง การนำเข้าไฟล์ข้อมูลดังกล่าวจึงสามารถทำได้โดยใช้ฟังก์ชัน fromJSON() ดังตัวอย่างต่อไปนี้\n\nlibrary(jsonlite)\ncaptain_mv<-fromJSON(\"http://www.omdbapi.com/?i=tt4154664&apikey=d97bab1b\")\nstr(captain_mv)\n\nList of 25\n $ Title     : chr \"Captain Marvel\"\n $ Year      : chr \"2019\"\n $ Rated     : chr \"PG-13\"\n $ Released  : chr \"08 Mar 2019\"\n $ Runtime   : chr \"123 min\"\n $ Genre     : chr \"Action, Adventure, Sci-Fi\"\n $ Director  : chr \"Anna Boden, Ryan Fleck\"\n $ Writer    : chr \"Anna Boden, Ryan Fleck, Geneva Robertson-Dworet\"\n $ Actors    : chr \"Brie Larson, Samuel L. Jackson, Ben Mendelsohn\"\n $ Plot      : chr \"Carol Danvers becomes one of the universe's most powerful heroes when Earth is caught in the middle of a galact\"| __truncated__\n $ Language  : chr \"English\"\n $ Country   : chr \"United States, Australia\"\n $ Awards    : chr \"9 wins & 56 nominations\"\n $ Poster    : chr \"https://m.media-amazon.com/images/M/MV5BMTE0YWFmOTMtYTU2ZS00ZTIxLWE3OTEtYTNiYzBkZjViZThiXkEyXkFqcGdeQXVyODMzMzQ\"| __truncated__\n $ Ratings   :'data.frame': 3 obs. of  2 variables:\n  ..$ Source: chr [1:3] \"Internet Movie Database\" \"Rotten Tomatoes\" \"Metacritic\"\n  ..$ Value : chr [1:3] \"6.8/10\" \"79%\" \"64/100\"\n $ Metascore : chr \"64\"\n $ imdbRating: chr \"6.8\"\n $ imdbVotes : chr \"559,100\"\n $ imdbID    : chr \"tt4154664\"\n $ Type      : chr \"movie\"\n $ DVD       : chr \"28 May 2019\"\n $ BoxOffice : chr \"$426,829,839\"\n $ Production: chr \"N/A\"\n $ Website   : chr \"N/A\"\n $ Response  : chr \"True\"\n\n\nจากการใช้คำสั่ง str(captain_mv) ข้างต้นจะเห็นว่าชุดข้อมูลแบบ JSON ที่นำเข้าด้วยฟังก์ชัน fromJSON() ถูกนำเข้าและแปลงให้อยู่ในรูปตัวแปรแบบ list โดยมีข้อมูลของตัวแปรทั้งหมด 25 ตัว\nในการทำงานจริงยังมี web API ที่จำเป็นต้องลงทะเบียนก่อนการใช้งานด้วย API ประเภทนี้ผู้วิเคราะห์จะไม่สามารถเข้าถึงและดาวน์โหลดข้อมูลได้โดยตรงเหมือนกับในตัวอย่าง website IMDB ในข้างต้น แต่จำเป็นต้องมีการใช้ access token หรือ api key เพื่อเป็นกุญแจหรือรหัสผ่านสำหรับดาวน์โหลดข้อมูลด้วย ตัวอย่างของ API ประเภทที่เช่น API ของ website Open Government Data of Thailand\n\n\n\nwebsite Open Government Data of Thailand\n\n\nการใช้งาน API ของ Open Government Data of Thailand ผู้ใช้จำเป็นต้องลงทะเบียนเพื่อขอเข้าใช้งาน API ก่อน โดยเข้าไปที่เมนู “สำหรับนักพัฒนา” แล้วคลิกเลือก “สมัครเป็นผู้ใช้” จากนั้นทำตามขั้นตอนที่ website แนะนำ เมื่อดำเนินการเสร็จผู้ใช้จะได้รับ user token ที่จะใช้เป็นรหัสสำหรับการดาวน์โหลดข้อมูลผ่าน API ของ website\nเมื่อได้รับ user token แล้วผู้วิเคราะห์สามารถเข้าสู่ website เพื่อดาวน์โหลดชุดข้อมูลที่ต้องการผ่าน API ได้ ยกตัวอย่างเช่น ผู้วิเคราะห์ต้องการนำเข้าชุดข้อมูลจำนวนนักเรียนพิการและด้อยโอกาส ปีการศึกษา 2565 เทอม 1 ของสำนักงานเขตพื้นที่การศึกษามัธยมศึกษา เขต 4 (https://opendata.data.go.th/dataset/disable2565) สามารถเขียนคำสั่งได้ดังนี้\n\nlibrary(httr)\nlibrary(jsonlite)\nheaders ='api-key' = 'XXXXXXXXXXXXXXXXXXXXXXXXXX'\n\nresponse <- VERB(\"POST\", \n                 url = \"https://opend.data.go.th/get-ckan/datastore_search?resource_id=cd232113-3350-43fb-a80d-34cd6263c780\",   \n                 add_headers(headers))\n\n\n\n\nตัวแปร response ในตัวอย่างคำสังข้างต้นเป็นตัวแปรแบบ list ที่ไม่ได้มีเฉพาะข้อมูลที่นำเข้า แต่ยังมีค่าพารามิเตอร์ต่าง ๆ ของ API ผู้วิเคราะห์สามารถเรียกดูส่วนที่เป็นข้อมูล JSON โดยใช้ฟังก์ชัน content() ดังนี้\n\ntemp<-content(response)\nstr(temp,2)\n\nList of 3\n $ help   : chr \"https://data.go.th/api/3/action/help_show?name=datastore_search\"\n $ success: logi TRUE\n $ result :List of 7\n  ..$ include_total : logi TRUE\n  ..$ resource_id   : chr \"cd232113-3350-43fb-a80d-34cd6263c780\"\n  ..$ fields        :List of 6\n  ..$ records_format: chr \"objects\"\n  ..$ records       :List of 100\n  ..$ _links        :List of 2\n  ..$ total         : int 360\n\n\nเมื่อพิจารณาผลลัพธ์จากฟังก์ชัน str(temp,2) ข้างต้นจะเห็นว่าส่วนที่เก็บข้อมูลค่าสังเกตของชุดข้อมูล JSON ชุดนี้อยู่ภายใต้สมาชิกของ list ที่ชื่อ result และ sublist ที่ชื่อ records ทั้งนี้เมื่อเรียกดูโดยพิมพ์คำสั่ง temp$result$records จะพบว่าเป็นตัวแปรแบบ list ที่มีสมาชิกเป็น sublist จำนวน 100 ตัว (สามารถพิมพ์คำสั่ง length(temp$result$records) เพื่อเรียกดูจำนวนสมาชิกภายใน list ได้) และเมื่อพิจารณาสมาชิกแต่ละตัวภายใน list ดังกล่าวจะพบว่าเป็นข้อมูลของแต่ละ record ซึ่งเราสามารถใช้ฟังก์ชัน bind_rows() ของ package-dplyr เพื่อยุบรวมสมาชิกท้ัง 100 ตัวภายใน list ดังกล่าวให้อยู่ในรูปของตารางแบบ dataframe ดังตัวอย่างต่อไปนี้\n\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\ndat <- bind_rows(temp$result$records)\nhead(dat)\n\n# A tibble: 6 × 6\n  `_id` SchoolName    YearTerm DisableType    Level Total\n  <int> <chr>         <chr>    <chr>          <chr> <int>\n1     1 โรงเรียนปทุมวิไล 2565/1   นักเรียนด้อยโอกาส P1        0\n2     2 โรงเรียนปทุมวิไล 2565/1   นักเรียนด้อยโอกาส P2        0\n3     3 โรงเรียนปทุมวิไล 2565/1   นักเรียนด้อยโอกาส P3        0\n4     4 โรงเรียนปทุมวิไล 2565/1   นักเรียนด้อยโอกาส P4        0\n5     5 โรงเรียนปทุมวิไล 2565/1   นักเรียนด้อยโอกาส P5        0\n6     6 โรงเรียนปทุมวิไล 2565/1   นักเรียนด้อยโอกาส P6        0\n\n\n\n\nภาษา Python\nสำหรับภาษา Python การนำเข้าข้อมูลผ่าน web API ที่ไม่ต้องลงทะเบียนดังในตัวอย่าง website IMDB ข้างต้นสามารถดำเนินการได้ในทำนองเดียวกับภาษา R โดยมี library ที่เกี่ยวข้องสองตัวได้แก่ library requests ใช้สำหรับดาวน์โหลดชุดข้อมูลจาก web API และ library json ใช้สำหรับดำเนินการกับชุดข้อมูลแบบ JSON ดังตัวอย่างต่อไปนี้\n\nimport requests\nimport json\nurl = \"http://www.omdbapi.com/?i=tt4154664&apikey=d97bab1b\"\nresponse = requests.get(url)\ndat = json.loads(response.text)\ndat\n\n{'Title': 'Captain Marvel', 'Year': '2019', 'Rated': 'PG-13', 'Released': '08 Mar 2019', 'Runtime': '123 min', 'Genre': 'Action, Adventure, Sci-Fi', 'Director': 'Anna Boden, Ryan Fleck', 'Writer': 'Anna Boden, Ryan Fleck, Geneva Robertson-Dworet', 'Actors': 'Brie Larson, Samuel L. Jackson, Ben Mendelsohn', 'Plot': \"Carol Danvers becomes one of the universe's most powerful heroes when Earth is caught in the middle of a galactic war between two alien races.\", 'Language': 'English', 'Country': 'United States, Australia', 'Awards': '9 wins & 56 nominations', 'Poster': 'https://m.media-amazon.com/images/M/MV5BMTE0YWFmOTMtYTU2ZS00ZTIxLWE3OTEtYTNiYzBkZjViZThiXkEyXkFqcGdeQXVyODMzMzQ4OTI@._V1_SX300.jpg', 'Ratings': [{'Source': 'Internet Movie Database', 'Value': '6.8/10'}, {'Source': 'Rotten Tomatoes', 'Value': '79%'}, {'Source': 'Metacritic', 'Value': '64/100'}], 'Metascore': '64', 'imdbRating': '6.8', 'imdbVotes': '559,100', 'imdbID': 'tt4154664', 'Type': 'movie', 'DVD': '28 May 2019', 'BoxOffice': '$426,829,839', 'Production': 'N/A', 'Website': 'N/A', 'Response': 'True'}\n\ndat\n\n{'Title': 'Captain Marvel', 'Year': '2019', 'Rated': 'PG-13', 'Released': '08 Mar 2019', 'Runtime': '123 min', 'Genre': 'Action, Adventure, Sci-Fi', 'Director': 'Anna Boden, Ryan Fleck', 'Writer': 'Anna Boden, Ryan Fleck, Geneva Robertson-Dworet', 'Actors': 'Brie Larson, Samuel L. Jackson, Ben Mendelsohn', 'Plot': \"Carol Danvers becomes one of the universe's most powerful heroes when Earth is caught in the middle of a galactic war between two alien races.\", 'Language': 'English', 'Country': 'United States, Australia', 'Awards': '9 wins & 56 nominations', 'Poster': 'https://m.media-amazon.com/images/M/MV5BMTE0YWFmOTMtYTU2ZS00ZTIxLWE3OTEtYTNiYzBkZjViZThiXkEyXkFqcGdeQXVyODMzMzQ4OTI@._V1_SX300.jpg', 'Ratings': [{'Source': 'Internet Movie Database', 'Value': '6.8/10'}, {'Source': 'Rotten Tomatoes', 'Value': '79%'}, {'Source': 'Metacritic', 'Value': '64/100'}], 'Metascore': '64', 'imdbRating': '6.8', 'imdbVotes': '559,100', 'imdbID': 'tt4154664', 'Type': 'movie', 'DVD': '28 May 2019', 'BoxOffice': '$426,829,839', 'Production': 'N/A', 'Website': 'N/A', 'Response': 'True'}\n\n\nนอกจากฟังก์ชัน fromJSON() แล้ว package-jsonlite ยังมีฟังก์ชันที่จำเป็นต้องการทำงานร่วมกับชุดข้อมูล JSON อีกหลายตัว เช่น toJSON() ใช้สำหรับสร้างไฟล์ข้อมูลแบบ JSON จากชุดข้อมูลของ R ฟังก์ชัน prettify() และ minify() ที่ใช้ปรับเปลี่ยนรูปแบบการนำเสนอของไฟล์ข้อมูล JSON"
  }
]